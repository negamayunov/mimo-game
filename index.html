<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<meta charset="UTF-8"/>
<title>–ú–ò–ú–û!</title>
<style>
body{margin:0;overflow:hidden;background:#111;font-family:sans-serif;color:#fff}
canvas{display:block}
#ui{position:absolute;top:10px;left:10px;font-size:18px}
/* ===== –£–ª—É—á—à–µ–Ω–Ω—ã–π —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —ç–∫—Ä–∞–Ω (–∞–¥–∞–ø—Ç–∏–≤–Ω—ã–π) ===== */
#msg{
  position:fixed;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:20px;
  z-index:100000;
  background:linear-gradient(180deg, rgba(0,0,0,0.65), rgba(0,0,0,0.85));
  box-sizing:border-box;
  pointer-events:auto;
}

#msg .modal {
  width: min(720px, 94%);
  max-width: 720px;
  background: linear-gradient(180deg, rgba(10,12,20,0.98), rgba(0,0,0,0.9));
  border-radius: 14px;
  padding: 18px 20px;
  color: #fff;
  text-align: center;
  box-shadow: 0 8px 30px rgba(0,0,0,0.6);
}

#msg .modal h2 {
  margin: 6px 0 10px;
  font-size: 26px;
  letter-spacing: 0.4px;
}

#msg .modal p.lead {
  margin: 8px 0 14px;
  font-size: 16px;
  color: #ddd;
}

#msg .lb-row {
  display:flex;
  gap:8px;
  justify-content:center;
  flex-wrap:wrap;
  margin-top:10px;
}

#msg input[type="text"], #msg input[type="email"] {
  font-size: 15px;
  padding: 8px 10px;
  border-radius: 8px;
  border: 1px solid #333;
  background: rgba(255,255,255,0.03);
  color: #fff;
  outline: none;
  min-width: 160px;
  box-sizing: border-box;
}

#msg button.lb-btn {
  font-size: 15px;
  padding: 8px 12px;
  border-radius: 8px;
  border: none;
  cursor: pointer;
  background: linear-gradient(180deg,#00ff88,#00d06a);
  color: #000;
  font-weight:700;
}

#msg .secondary {
  background: transparent;
  border: 1px solid #555;
  color: #fff;
}

#msg #lb_status { margin-top:10px; font-size:14px; color:#cfcfcf; min-height:18px; }

#msg #lb_top { 
    margin-top:12px; 
    text-align:left; 
    color:#000; /* –ß–µ—Ä–Ω—ã–π —Ç–µ–∫—Å—Ç */
    max-height:180px; 
    overflow:auto; 
    padding:6px; 
    background: transparent; /* –£–±–∏—Ä–∞–µ–º —Ç–µ–º–Ω—ã–π —Ñ–æ–Ω */
}

/* –°—Ç–∏–ª–∏ –¥–ª—è –±—É–º–∞–∂–Ω–æ–≥–æ –º–µ–Ω—é –∫–æ–Ω—Ü–∞ –∏–≥—Ä—ã */
.paper-modal {
    background: #f4f4f4 !important;
    color: #000 !important;
    border: 4px solid #000;
    box-shadow: 15px 15px 0px rgba(0,0,0,0.8);
    position: relative;
    padding: 2rem !important;
    transform: rotate(-1deg);
}
.paper-modal h2 {
    font-family: 'Arial Black', sans-serif;
    background: #000;
    color: #fff;
    padding: 10px;
    transform: rotate(1deg);
    display: inline-block;
    width: 100%;
    margin-bottom: 15px;
}
.paper-input {
    border: 2px solid #000 !important;
    background: #fff !important;
    color: #000 !important;
    padding: 10px !important;
    font-weight: bold;
}

/* Mobile small text */
@media (max-width:420px) {
  #msg .modal h2 { font-size:20px; }
  #msg .modal p.lead { font-size:14px; }
  #msg input[type="text"], #msg input[type="email"] { min-width:120px; font-size:14px; padding:7px; }
  #msg button.lb-btn { padding:7px 10px; font-size:14px; }
}


#preloader{
  position:fixed; inset:0;
  background:#0a1030;
  color:#fff;
  font-family:sans-serif;
  display:flex; flex-direction:column;
  align-items:center; justify-content:center;
  gap:25px;
  z-index:10;
}
#preloader h1{ font-size:48px; margin:0 0 20px; }
#social{ display:flex; gap:20px; }
#social a{
  color:#fff; background:#ffffff20;
  padding:8px 16px; border-radius:6px;
  text-decoration:none; font-size:18px;
  transition:background .2s;
}
#social a:hover{ background:#ffffff40; }
#startBtn{
  font-size:24px; padding:12px 32px;
  border:none; border-radius:8px; cursor:pointer;
  background:#00ff88; color:#000;
}
#startBtn:disabled{ background:#666; cursor:not-allowed; }

#loadProgress{ appearance:none; }
#loadProgress::-webkit-progress-bar{ background:#222; }
#loadProgress::-webkit-progress-value{ background:#00ff88; }

#progressBar{
  position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
  width:60%; height:6px; background:#222; border-radius:3px;
  overflow:hidden; z-index:5;
}
#progressFill{
  height:100%; width:0%; background:#00ff88; transition:width 0.1s;
}

.gateLabel{
  font-family:sans-serif;
  font-size:26px;
  font-weight:bold;
  color:#fff;
  text-align:center;
  width:100%;
  position:absolute;
  top:4px;
}
.gateValue{
  font-family:sans-serif;
  font-size:42px;
  font-weight:bold;
  color:#fff;
  text-align:center;
  width:100%;
  position:absolute;
  top:50%;
  transform:translateY(-50%);
}
/* --- Scoreboard (top center) --- */
#scoreboard{
  position: absolute;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  font-size: 20px;
  font-weight: 700;
  color: #fff;
  z-index: 99999;
  text-align: center;
  pointer-events: none;
  user-select: none;
}
#scoreboard #scoreCount{
  display: inline-block;
  font-size: 22px;
  margin-left: 8px;
  color: #ffdcdc;
}
/* --- MOBILE: –≤—Ä–µ–º–µ–Ω–Ω–æ –æ–ø—É—Å—Ç–∏—Ç—å UI –≤–Ω–∏–∑, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ—Å–µ–∫–∞–ª—Å—è —Å–æ —Å—á—ë—Ç—á–∏–∫–æ–º --- */
@media (max-width: 700px) {
  /* –ø–µ—Ä–µ–º–µ—â–∞–µ–º –æ—Å–Ω–æ–≤–Ω–æ–π UI –≤–Ω–∏–∑ –ø–æ —Ü–µ–Ω—Ç—Ä—É */
  #ui {
    position: absolute !important;
    top: auto !important;
    bottom: 25px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    max-width: 95% !important;
    box-sizing: border-box !important;
    padding-left: 6px !important;
    padding-right: 6px !important;
    pointer-events: auto !important;
    z-index: 99990 !important; /* –Ω–∏–∂–µ —Å—á—ë—Ç—á–∏–∫–∞ */
  }

  /* –≥–∞—Ä–∞–Ω—Ç–∏—Ä—É–µ–º, —á—Ç–æ —Å—á—ë—Ç—á–∏–∫ –æ—Å—Ç–∞—ë—Ç—Å—è —Å–≤–µ—Ä—Ö—É –≤–≤–µ—Ä—Ö—É –ø–æ —Ü–µ–Ω—Ç—Ä—É */
  #scoreboard {
    position: fixed !important;
    top: 8px !important;
    left: 50% !important;
    transform: translateX(-50%) !important;
    z-index: 99999 !important;
  }

  /* –µ—Å–ª–∏ –µ—Å—Ç—å —Ç–µ–∫—Å—Ç–æ–≤—ã–µ –∫–Ω–æ–ø–∫–∏/–∏–∫–æ–Ω–∫–∏ –≤–Ω—É—Ç—Ä–∏ UI ‚Äî —á—É—Ç—å —É–º–µ–Ω—å—à–∏—Ç—å —Ä–∞–∑–º–µ—Ä, —á—Ç–æ–±—ã –ø–æ–º–µ—Å—Ç–∏–ª–æ—Å—å */
  #ui * {
    font-size: 14px !important;
  }
}
/* ========== –ú–ï–ù–Æ –ü–ê–£–ó–´ ========== */
#pauseOverlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  backdrop-filter: blur(5px);
  z-index: 99998;
  display: none;
  align-items: center;
  justify-content: center;
}

#pauseOverlay.active {
  display: flex;
}

#pauseMenu {
  width: min(480px, 90%);
  background: #f4f4f4;
  color: #000;
  border: 4px solid #000;
  box-shadow: 15px 15px 0px rgba(0,0,0,0.8);
  position: relative;
  padding: 2rem;
  transform: rotate(-1deg);
  font-family: 'Merriweather', serif;
}

#pauseMenu::before {
  content: '';
  position: absolute;
  top: -12px;
  left: 50%;
  transform: translateX(-50%) rotate(-2deg);
  width: 120px;
  height: 30px;
  background: rgba(255,255,255,0.4);
  backdrop-filter: blur(2px);
  box-shadow: 0 1px 3px rgba(0,0,0,0.2);
}

.pause-title {
  font-family: 'Arial Black', sans-serif;
  font-weight: 900;
  text-transform: uppercase;
  background: #000;
  color: #fff;
  padding: 12px;
  transform: rotate(1deg);
  text-align: center;
  font-size: 1.5rem;
  margin-bottom: 1.5rem;
  border: 2px solid #000;
}

.pause-section {
  margin-bottom: 1.5rem;
  padding-bottom: 1rem;
  border-bottom: 2px dashed #ccc;
}

.pause-section:last-of-type {
  border-bottom: none;
}

.pause-label {
  font-weight: 700;
  font-size: 0.9rem;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  margin-bottom: 0.5rem;
  display: block;
}

/* –ö–Ω–æ–ø–∫–∏ –≤—ã–±–æ—Ä–∞ —Ç—Ä–µ–∫–∞ */
.track-select {
  display: flex;
  gap: 0.5rem;
  flex-wrap: wrap;
}

.track-btn {
  flex: 1;
  min-width: 120px;
  padding: 10px 16px;
  border: 2px solid #000;
  background: #fff;
  font-family: 'Merriweather', serif;
  font-weight: 700;
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s;
  text-transform: uppercase;
}

.track-btn:hover {
  transform: translate(-2px, -2px);
  box-shadow: 4px 4px 0 #000;
}

.track-btn.active {
  background: #0077FF;
  color: #fff;
  box-shadow: 4px 4px 0 #000;
}

/* –°–ª–∞–π–¥–µ—Ä—ã –≥—Ä–æ–º–∫–æ—Å—Ç–∏ */
.volume-control {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 0.75rem;
}

.volume-slider {
  flex: 1;
  -webkit-appearance: none;
  appearance: none;
  height: 8px;
  background: #ddd;
  border: 2px solid #000;
  outline: none;
}

.volume-slider::-webkit-slider-thumb {
  -webkit-appearance: none;
  appearance: none;
  width: 24px;
  height: 24px;
  background: #0077FF;
  border: 2px solid #000;
  cursor: pointer;
  box-shadow: 2px 2px 0 #000;
}

.volume-slider::-moz-range-thumb {
  width: 24px;
  height: 24px;
  background: #0077FF;
  border: 2px solid #000;
  cursor: pointer;
  box-shadow: 2px 2px 0 #000;
}

.volume-value {
  min-width: 50px;
  text-align: right;
  font-weight: 700;
  font-family: monospace;
  font-size: 1rem;
}

/* –ö–Ω–æ–ø–∫–∞ MUTE */
.mute-btn {
  width: 40px;
  height: 40px;
  border: 2px solid #000;
  background: #fff;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  transition: all 0.15s;
}

.mute-btn:hover {
  transform: scale(1.05);
}

.mute-btn.muted {
  background: #ff0040;
  color: #fff;
}

/* –ö–Ω–æ–ø–∫–∏ —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è */
.pause-actions {
  display: flex;
  gap: 1rem;
  margin-top: 1.5rem;
}

.pause-btn {
  flex: 1;
  padding: 14px 20px;
  border: 3px solid #000;
  font-family: 'Arial Black', sans-serif;
  font-weight: 900;
  font-size: 1rem;
  text-transform: uppercase;
  cursor: pointer;
  transition: all 0.15s;
  box-shadow: 4px 4px 0 #000;
}

.pause-btn:hover {
  transform: translate(-2px, -2px);
  box-shadow: 6px 6px 0 #000;
}

.pause-btn:active {
  transform: translate(2px, 2px);
  box-shadow: 0 0 0 #000;
}

.pause-btn.primary {
  background: #0077FF;
  color: #fff;
}

.pause-btn.secondary {
  background: #fff;
  color: #000;
}

/* –ò–Ω–¥–∏–∫–∞—Ç–æ—Ä –≥–æ—Ä—è—á–µ–π –∫–ª–∞–≤–∏—à–∏ */
.hotkey-hint {
  position: absolute;
  top: 1rem;
  right: 1rem;
  font-family: monospace;
  font-size: 0.75rem;
  color: #666;
  background: #fff;
  border: 1px solid #000;
  padding: 4px 8px;
  transform: rotate(2deg);
}
/* ========== –ö–ù–û–ü–ö–ê –ü–ê–£–ó–´ –í –ò–ì–†–ï ========== */
/* ========== –ö–ù–û–ü–ö–ê –ü–ê–£–ó–´ –í –ò–ì–†–ï ========== */
#pauseGameBtn {
  position: fixed;
  bottom: 20px;
  right: 20px;
  width: 50px;
  height: 50px;
  background: #0077FF; /* –°–∏–Ω–∏–π —Ñ–æ–Ω */
  border: 3px solid #000;
  box-shadow: 4px 4px 0 rgba(0,0,0,0.8);
  z-index: 99990;
  cursor: pointer;
  display: none; /* –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ —Å—Ç–∞—Ä—Ç–∞ –∏–≥—Ä—ã */
  align-items: center;
  justify-content: center;
  font-size: 20px;
  color: #fff; /* –ë–µ–ª—ã–π –∑–Ω–∞—á–æ–∫ */
  transition: all 0.15s;
  transform: rotate(-2deg);
}

#pauseGameBtn:hover {
  background: #0055cc; /* –¢–µ–º–Ω–µ–µ –ø—Ä–∏ –Ω–∞–≤–µ–¥–µ–Ω–∏–∏ */
  transform: rotate(0deg) scale(1.05);
  box-shadow: 6px 6px 0 rgba(0,0,0,0.8);
}

#pauseGameBtn:active {
  background: #004499;
  transform: rotate(0deg) scale(0.95);
  box-shadow: 2px 2px 0 rgba(0,0,0,0.8);
}

/* –ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —á—É—Ç—å –±–æ–ª—å—à–µ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ */
@media (max-width: 700px) {
  #pauseGameBtn {
    width: 60px;
    height: 60px;
    font-size: 24px;
    bottom: 25px;
    right: 25px;
  }
}

#pauseGameBtn.visible {
  display: flex;
}
/* –ù–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö —á—É—Ç—å –±–æ–ª—å—à–µ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞ */
@media (max-width: 700px) {
  #pauseGameBtn {
    width: 60px;
    height: 60px;
    font-size: 24px;
    bottom: 25px;
    right: 25px;
  }
}

#pauseGameBtn.visible {
  display: flex;
}
</style>
</head>
<body>
<div id="ui" style="display:none">
  –ì–≤–æ–∑–¥–µ–π: <span id="count">1</span> |
  –£—Ä–æ–≤–Ω–µ–π: <span id="levels">1</span><br>
  –°–∫–æ—Ä–æ—Å—Ç—å —Å—Ç—Ä–µ–ª—å–±—ã: <span id="rate">1.0</span>/—Å–µ–∫ |
  –î–∞–ª—å–Ω–æ—Å—Ç—å: <span id="range">15</span><br>
  FPS: <span id="fps">0</span>
  MaxDamage: <span id="maxd">0</span> |
  CurrentDamage: <span id="curd">0</span>
</div>
<!-- Scoreboard: –ø–æ–∫–∞–∑—ã–≤–∞–µ—Ç –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —É–Ω–∏—á—Ç–æ–∂–µ–Ω–Ω—ã—Ö —Å–µ—Ä–¥–µ—Ü -->
<div id="scoreboard" style="display:none">–°—á—ë—Ç: <span id="scoreCount">0</span></div>

<div id="msg" style="display:none">
  <div id="msgText"></div>
  <button onclick="location.reload()">Restart</button>
</div>

<div id="progressBar">
  <div id="progressFill"></div>
</div>

<!-- === –ù–û–í–û–ï –ì–õ–ê–í–ù–û–ï –ú–ï–ù–Æ (V2) === -->
<script src="https://cdn.tailwindcss.com/3.4.17"></script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
<style>
    /* –ü–æ–¥–∫–ª—é—á–∞–µ–º –∂–∏—Ä–Ω—ã–π —à—Ä–∏—Ñ—Ç —Å –∑–∞—Å–µ—á–∫–∞–º–∏ (Courier Prime) */
    @import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@900&display=swap');

    /* –°—Ç–∏–ª—å –¥–ª—è "—Ä–≤–∞–Ω—ã—Ö" –∫–Ω–æ–ø–æ–∫ */
    .jagged-btn { 
        clip-path: polygon(
            0% 5%, 5% 0%, 15% 5%, 25% 0%, 35% 5%, 45% 0%, 55% 5%, 65% 0%, 75% 5%, 85% 0%, 95% 5%, 100% 0%,
            100% 95%, 95% 100%, 85% 95%, 75% 100%, 65% 95%, 55% 100%, 45% 95%, 35% 100%, 25% 95%, 15% 100%, 5% 95%, 0% 100%
        ); 
    }
    
    /* –ë—É–∫–≤—ã –Ω–∞–∑–≤–∞–Ω–∏—è (Arial Black) */
    .ransom-title { 
        font-family: 'Arial Black', 'Arial Bold', sans-serif; 
        font-weight: 900;
        text-transform: uppercase; 
        text-shadow: 4px 4px 0px #000;
    }

    /* –û—Å–Ω–æ–≤–Ω–æ–π —à—Ä–∏—Ñ—Ç –¥–ª—è –≤—Å–µ–≥–æ –æ—Å—Ç–∞–ª—å–Ω–æ–≥–æ */
    .paper-font {
        font-family: 'Merriweather', serif;
        font-weight: 700;
    }

    /* –ê–Ω–∏–º–∞—Ü–∏—è –ø–∞—Ä–µ–Ω–∏—è –¥–ª—è —Ñ–æ—Ç–æ */
    @keyframes float { 0% { transform: translateY(0px) rotate(0deg); } 50% { transform: translateY(-10px) rotate(1deg); } 100% { transform: translateY(0px) rotate(0deg); } }
    
    /* –°–∫–æ—Ç—á */
    .tape { background-color: rgba(255, 255, 255, 0.4); box-shadow: 0 1px 3px rgba(0,0,0,0.2); backdrop-filter: blur(2px); }

    #mainMenu { position: fixed; inset: 0; z-index: 99999; background: #111; overflow: hidden; }
    #loadProgress { display: none; }

    /* –°—Ç–∏–ª–∏ –¥–ª—è –º–æ–¥–∞–ª—å–Ω–æ–≥–æ –æ–∫–Ω–∞ (–ü—Ä–∞–≤–∏–ª–∞) */
    #rulesModal {
        display: none; /* –°–∫—Ä—ã—Ç–æ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é */
        position: fixed; inset: 0; z-index: 100000;
        background: rgba(0,0,0,0.85);
        backdrop-filter: blur(5px);
        align-items: center; justify-content: center;
    }

/* –≠—Ñ—Ñ–µ–∫—Ç —à—É–º–∞ (–∑–µ—Ä–Ω–∏—Å—Ç–æ—Å—Ç—å) - –º–µ–ª–∫–∏–π –∏ –∞–∫–∫—É—Ä–∞—Ç–Ω—ã–π */
    .grain-overlay {
        position: fixed; top: 0; left: 0; width: 100%; height: 100%;
        pointer-events: none; z-index: 90; opacity: 0.05;
        background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)'/%3E%3C/svg%3E");
    }
</style>

<div id="mainMenu" class="w-full h-screen text-white relative flex flex-col items-center justify-center bg-[#111] paper-font">
    
    <!-- –°–õ–û–ñ–ù–´–ô –§–û–ù –ò–ó –û–†–ò–ì–ò–ù–ê–õ–ê -->
    <div class="fixed inset-0 bg-[#0a0a15] z-[-10]"></div>
    
    <!-- –ó–µ—Ä–Ω–∏—Å—Ç–æ—Å—Ç—å -->
    <div class="grain-overlay"></div>

    <!-- –ì–µ–æ–º–µ—Ç—Ä–∏—è –∏ –ø—è—Ç–Ω–∞ -->
    <div class="fixed inset-0 z-[-5] overflow-hidden">
        <!-- –°–∏–Ω—è—è –ø–æ–ª–æ—Å–∞ -->
        <div class="absolute top-[-10%] left-[-10%] w-[80%] h-[150%] bg-[#0044cc] opacity-20 transform rotate-[25deg]"></div>
        <!-- –¢–µ–º–Ω–æ–µ –ø—è—Ç–Ω–æ —Å–ø—Ä–∞–≤–∞ -->
        <div class="absolute top-[20%] right-[-20%] w-[120%] h-[40%] bg-[#002266] opacity-30 transform -rotate-[15deg]"></div>
        <!-- –°–≤–µ—Ç—è—â–µ–µ—Å—è –ø—è—Ç–Ω–æ —Å–Ω–∏–∑—É -->
        <div class="absolute bottom-[-10%] left-[20%] w-[40%] h-[80%] bg-[#0088ff] opacity-10 blur-[100px] rounded-full"></div>
        
        <!-- –ê–±—Å—Ç—Ä–∞–∫—Ç–Ω—ã–µ —Ñ–∏–≥—É—Ä—ã -->
        <div class="absolute top-[10%] right-[30%] w-64 h-64 bg-white opacity-5 transform rotate-45 hidden md:block" style="clip-path: polygon(50% 0%, 0% 100%, 100% 100%);"></div>
        <div class="absolute bottom-[20%] left-[10%] w-96 h-96 bg-blue-500 opacity-5 transform -rotate-12 hidden md:block" style="clip-path: polygon(20% 0%, 80% 0%, 100% 100%, 0% 100%);"></div>
    </div>
    <!-- –§–û–¢–û –ì–û–†–û–î–ê –°–ü–†–ê–í–ê (–ö–∞–∫ –≤ –º–∞–∫–µ—Ç–µ) -->
    <div class="fixed right-[-5%] top-[-5%] h-[120%] w-[50%] z-[-2] hidden lg:block pointer-events-none">
        <div class="relative w-full h-full transform -rotate-[5deg] opacity-70 mix-blend-hard-light">
             <!-- –ë–µ–ª–∞—è –ø–æ–¥–ª–æ–∂–∫–∞ –¥–ª—è –∫–æ–Ω—Ç—Ä–∞—Å—Ç–∞ -->
            <div class="absolute inset-0 bg-white/10" style="clip-path: polygon(20% 0%, 100% 0, 100% 100%, 0% 100%);"></div>
            
            <!-- –§–û–¢–û (–£–ª–∏—Ü–∞/–ì–æ—Ä–æ–¥) -->
            <img src="https://sun9-10.userapi.com/s/v1/ig2/URLbrhF_f0-VJKf_UFx1eXkR8J17uTeoq1HtJ46xuvadE892aROEiH3YVmXVnA1RaGkAhvANWgL4RhFuvVQy_W_i.jpg?quality=95&as=32x32,48x48,72x72,108x108,160x160,240x240,360x360,480x480,540x540,640x640,720x720,1080x1080,1280x1280,1440x1440,2560x2560&from=bu&cs=2560x0" 
                 class="absolute inset-0 w-full h-full object-cover grayscale contrast-125 brightness-75"
                 style="clip-path: polygon(25% 0%, 100% 0, 100% 100%, 0% 100%);">
            
            <!-- –ö—Ä–∞—Å–Ω–∞—è –ª–∏–Ω–∏—è -->
            <div class="absolute top-[55%] right-[0%] w-full h-[2px] bg-red-600 transform rotate-2 shadow-[0_0_10px_red]"></div>
            <!-- –°–∏–Ω—è—è –ª–∏–Ω–∏—è -->
            <div class="absolute top-[57%] left-[50%] right-[50%] w-full h-[2px] bg-blue-600 transform rotate-2 shadow-[0_0_10px_blue]"></div>
        </div>
    </div>
    <svg class="fixed inset-0 w-full h-full z-0 pointer-events-none opacity-20" xmlns="http://www.w3.org/2000/svg" vid="124">
        <line x1="0" y1="100%" x2="100%" y2="0" stroke="white" stroke-width="1" vid="125"></line>
        <line x1="20%" y1="0" x2="0" y2="40%" stroke="white" stroke-width="2" vid="126"></line>
        <line x1="80%" y1="100%" x2="100%" y2="60%" stroke="blue" stroke-width="2" vid="127"></line>
        <path d="M 100 100 L 300 150 L 200 300 Z" fill="none" stroke="#0044cc" stroke-width="1" vid="128"></path>
    </svg>
    
    <!-- –ö–û–ù–¢–ï–ù–¢ -->
    <div class="relative w-full h-full max-w-[1600px] flex p-4 md:p-8 box-border z-10">
        
        <!-- –õ–ï–í–ê–Ø –ü–ê–ù–ï–õ–¨ (–°–æ—Ü—Å–µ—Ç–∏) -->
        <div class="w-16 md:w-24 h-full flex flex-col justify-center items-start md:items-center gap-6 z-20 absolute left-4 md:static top-0 pointer-events-auto">
            <a href="https://www.tiktok.com/@gvozdiband" target="_blank" class="group relative transition-transform hover:scale-110">
                <div class="w-10 h-10 md:w-12 md:h-12 bg-black border-2 border-white flex items-center justify-center shadow-[4px_4px_0_white] group-hover:bg-[#00f2ea] transition-colors"><i class="fab fa-tiktok text-white group-hover:text-black text-xl"></i></div>
            </a>
            <a href="https://t.me/gvozdi_band" target="_blank" class="group relative transition-transform hover:scale-110">
                <div class="w-10 h-10 md:w-12 md:h-12 bg-blue-500 border-2 border-white flex items-center justify-center shadow-[4px_4px_0_black]"><i class="fab fa-telegram-plane text-white text-xl"></i></div>
            </a>
            <a href="https://vk.com/gvozdi_band" target="_blank" class="group relative transition-transform hover:scale-110">
                <div class="w-10 h-10 md:w-12 md:h-12 bg-[#0077FF] border-2 border-white flex items-center justify-center shadow-[4px_4px_0_black]"><i class="fab fa-vk text-white text-xl"></i></div>
            </a>
            <a href="https://www.youtube.com/channel/UCzNrI47UMc8ie3cnITUW-Dg" target="_blank" class="group relative transition-transform hover:scale-110">
                <div class="w-10 h-10 md:w-12 md:h-12 bg-red-600 border-2 border-white flex items-center justify-center shadow-[4px_4px_0_black]"><i class="fab fa-youtube text-white text-xl"></i></div>
            </a>
        </div>

        <!-- –¶–ï–ù–¢–† -->
        <div class="flex-1 relative flex flex-col items-center justify-center">
            
            <!-- –§–û–¢–û –õ–ï–í–û–ï (–°–∫—Ä—ã—Ç–æ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö, –≤–∏–¥–Ω–æ –Ω–∞ –ü–ö) -->
            <div class="absolute top-10 left-0 hidden lg:block animate-[float_7s_ease-in-out_infinite]">
                <div class="relative w-56 h-64 transform -rotate-6 transition-transform hover:rotate-0 duration-500">
                    <div class="absolute inset-0 bg-white p-2 shadow-[8px_8px_0_rgba(0,0,0,0.5)]">
                        <!-- –ó–ê–ú–ï–ù–ò –°–°–´–õ–ö–£ –ù–ò–ñ–ï –ù–ê –°–í–û–ï –§–û–¢–û -->
                        <img src="https://sun9-4.userapi.com/s/v1/ig2/DBw_86ea3ATcOr-SqbCC_0Mgtd5MD7lFqpQ9TKp1ExHr_WAb9gg0TXL48YQ9PTgZq0Y3x5tRtq7ipXJENaF_Rwhp.jpg?quality=95&as=32x24,48x36,72x54,108x81,160x119,240x179,360x269,480x358,540x403,640x478,720x538,1080x806,1280x956,1440x1075,1500x1120&from=bu&cs=1500x0" class="w-full h-full object-cover grayscale contrast-125">
                    </div>
                    <div class="tape absolute -top-3 left-1/2 w-24 h-8 transform -translate-x-1/2 rotate-3"></div>
                </div>
            </div>

            <!-- –õ–û–ì–û–¢–ò–ü –ò –ó–ê–ì–û–õ–û–í–û–ö -->
            <div class="mb-10 select-none relative flex flex-col items-center z-30">
                <!-- –ú–ò–ú–û (Arial Black) -->
                <div class="flex gap-1 md:gap-3">
                    <span class="ransom-title bg-white text-black text-7xl md:text-9xl p-1 md:p-2 border-4 border-black transform -rotate-2 hover:scale-105 duration-100">–ú</span>
                    <span class="ransom-title bg-black text-white text-7xl md:text-9xl p-1 md:p-2 border-4 border-white transform rotate-1 hover:scale-105 duration-100">–ò</span>
                    <span class="ransom-title bg-blue-600 text-white text-7xl md:text-9xl p-1 md:p-2 border-4 border-white transform -rotate-1 hover:scale-105 duration-100">–ú</span>
                    <span class="ransom-title bg-white text-black text-7xl md:text-9xl p-1 md:p-2 border-4 border-black transform rotate-2 hover:scale-105 duration-100">–û</span>
                </div>
                
                <!-- –ì–í–û–ó–î–ò BAND (–°–∏–Ω–∏–π —Ñ–æ–Ω) -->
                <div class="mt-6 transform -rotate-1 bg-blue-700 text-white px-6 py-1 text-xl md:text-2xl border-2 border-white shadow-[5px_5px_0_rgba(0,0,0,1)] hover:rotate-1 hover:scale-105 duration-100">
                    –ì–í–û–ó–î–ò BAND
                </div>
                
            </div>

            <!-- –ö–ù–û–ü–ö–ò –ú–ï–ù–Æ (–û–ë–™–ï–î–ò–ù–ï–ù–ù–´–ï) -->
            <div class="flex flex-col gap-7 items-center w-full max-w-[300px] z-30 mt-4">
                
                <!-- 1. –°–ª—É—à–∞—Ç—å —Ç—Ä–µ–∫ -->
                <a href="https://band.link/snova_mimo" target="_blank" class="w-auto transform rotate-1 hover:rotate-0 transition-transform">
                    <div class="bg-white border-2 border-black px-5 py-2 shadow-[4px_4px_0_black] hover:shadow-[1px_1px_0_black] hover:translate-y-0.5 hover:translate-x-0.5 transition-all flex items-center gap-3">
                        <i class="fas fa-play text-blue-600 text-xs"></i>
                        <span class="text-black font-bold tracking-widest text-xs uppercase">–°–õ–£–®–ê–¢–¨ –¢–†–ï–ö</span>
                    </div>
                </a>

                <!-- 2. –ö–Ω–æ–ø–∫–∞ –ò–ì–†–ê–¢–¨ (–£–º–µ–Ω—å—à–µ–Ω–Ω–∞—è) -->
                <button id="startBtn" disabled class="group relative w-[65%] h-14 transform transition-transform hover:scale-105 active:scale-95 cursor-not-allowed opacity-70">
                    <div class="absolute inset-0 bg-black translate-x-1.5 translate-y-1.5 jagged-btn"></div>
                    <div class="absolute inset-0 bg-white jagged-btn border-[3px] border-black flex items-center justify-center">
                        <span id="btnText" class="text-3xl text-black font-black uppercase tracking-tighter z-10 group-hover:text-blue-700 transition-colors">
                            –ó–ê–ì–†–£–ó–ö–ê
                        </span>
                    </div>
                </button>

                <!-- 3. –ö–Ω–æ–ø–∫–∞ –ö–ê–ö –ò–ì–†–ê–¢–¨ -->
                <button onclick="document.getElementById('rulesModal').style.display='flex'" class="relative w-[65%] h-12 transform rotate-1 hover:rotate-0 hover:scale-105 transition-all">
                    <div class="absolute inset-0 bg-black translate-x-1 translate-y-1" style="clip-path: polygon(2% 0, 100% 0, 98% 100%, 0% 98%)"></div>
                    <div class="absolute inset-0 bg-blue-600 border-2 border-white flex items-center justify-center" style="clip-path: polygon(2% 0, 100% 0, 98% 100%, 0% 98%)">
                        <span class="text-lg text-white font-bold tracking-wider">–ö–ê–ö –ò–ì–†–ê–¢–¨?</span>
                    </div>
                </button>

                <div id="menuLoadStatus" class="font-mono text-[10px] text-white/40 mt-1 uppercase">–°–∏—Å—Ç–µ–º–∞ –≥–æ—Ç–æ–≤–∞</div>
            </div>

            <!-- –§–û–¢–û –ü–†–ê–í–û–ï (–°–∫—Ä—ã—Ç–æ –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö, –≤–∏–¥–Ω–æ –Ω–∞ –ü–ö) -->
            <div class="absolute bottom-10 right-0 hidden lg:block animate-[float_8s_ease-in-out_infinite]">
                <div class="relative w-60 h-72 transform rotate-3 transition-transform hover:rotate-0 duration-500">
                    <div class="absolute inset-0 bg-white p-2 shadow-[8px_8px_0_rgba(0,0,0,0.5)]">
                        <!-- –ó–ê–ú–ï–ù–ò –°–°–´–õ–ö–£ –ù–ò–ñ–ï –ù–ê –°–í–û–ï –§–û–¢–û -->
                        <img src="https://sun9-48.userapi.com/s/v1/ig2/6yhcPGk9ZMuBwX5ugEEWAzaMxF4SSBjjnZ8l1fvKKbw2ns0ujaxeh68BJX_qzphf8mdQHvY-O8wKFLj0VmZUjlmA.jpg?quality=95&as=32x21,48x32,72x48,108x72,160x107,240x160,360x240,480x320,540x360,640x427,720x480,1080x720,1280x853,1440x960,2560x1707&from=bu&cs=2560x0" class="w-full h-full object-cover grayscale contrast-125">
                    </div>
                    <div class="tape absolute -top-3 left-1/2 w-24 h-8 transform -translate-x-1/2 -rotate-3"></div>
                </div>
            </div>

        </div>

        <!-- –ü–†–ê–í–ê–Ø –ü–ê–ù–ï–õ–¨ (–õ–∏–¥–µ—Ä–±–æ—Ä–¥) -->
        <div class="w-80 h-full hidden xl:flex items-center justify-center z-20 pl-8 pointer-events-none">
            <div class="relative w-full transform rotate-2 transition-transform duration-300 pointer-events-auto">
                <div class="absolute -top-4 left-1/2 transform -translate-x-1/2 w-24 h-8 bg-white/30 tape z-30"></div>
                <div class="bg-[#f4f4f4] p-1 shadow-[10px_10px_0px_rgba(0,0,0,0.8)] text-black">
                    <div class="border-2 border-dashed border-gray-600 p-4 min-h-[300px]">
                        <h2 class="text-xl font-black text-center bg-black text-white p-2 mb-4 -rotate-1">–¢–û–ü –ò–ì–†–û–ö–û–í</h2>
                        <div id="menu-leaderboard-list" class="space-y-3 text-sm">
                            <div class="animate-pulse text-center mt-10 text-gray-500">–ó–∞–≥—Ä—É–∑–∫–∞...</div>
                        </div>
                        <div class="mt-6 border-t-2 border-black pt-2 flex justify-between items-center">
                            <span class="text-[10px] font-bold uppercase tracking-widest text-blue-800">MIMO SYSTEM</span>
                            <div class="h-2 w-2 rounded-full bg-green-500 animate-pulse"></div>
                        </div>
                    </div>
                </div>
            </div>
        </div>

    </div>
</div>

<!-- –ú–û–î–ê–õ–¨–ù–û–ï –û–ö–ù–û "–ö–ê–ö –ò–ì–†–ê–¢–¨" -->
<div id="rulesModal">
    <div class="relative w-[90%] max-w-lg bg-white text-black p-2 shadow-[20px_20px_0_rgba(0,0,0,0.8)] transform rotate-1 paper-font">
        <!-- –†–∞–º–∫–∞ -->
        <div class="border-4 border-black p-6 flex flex-col gap-4">
            
            <h2 class="text-3xl font-black text-center uppercase bg-black text-white p-2 -rotate-1 mb-2">–ò–ù–°–¢–†–£–ö–¶–ò–Ø</h2>
            
            <div class="flex items-start gap-4">
                <div class="w-12 h-12 bg-blue-600 text-white flex items-center justify-center font-bold text-2xl border-2 border-black flex-shrink-0">1</div>
                <div>
                    <h3 class="font-bold text-lg uppercase">–£–ü–†–ê–í–õ–ï–ù–ò–ï</h3>
                    <p class="text-sm">–í–æ–¥–∏ –ø–∞–ª—å—Ü–µ–º –∏–ª–∏ –º—ã—à–∫–æ–π –≤–ª–µ–≤–æ-–≤–ø—Ä–∞–≤–æ, —á—Ç–æ–±—ã –¥–≤–∏–≥–∞—Ç—å —Ç–æ–ª–ø—É.</p>
                </div>
            </div>

            <div class="flex items-start gap-4">
                <div class="w-12 h-12 bg-red-600 text-white flex items-center justify-center font-bold text-2xl border-2 border-black flex-shrink-0">2</div>
                <div>
                    <h3 class="font-bold text-lg uppercase">–°–¢–†–ï–õ–¨–ë–ê</h3>
                    <p class="text-sm">–û–Ω–∞ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è. –¢–≤–æ—è —Ü–µ–ª—å ‚Äî —Ä–∞–∑–±–∏–≤–∞—Ç—å —Å–µ—Ä–¥—Ü–∞ –∏ —Å—Ç–µ–Ω—ã.</p>
                </div>
            </div>

            <div class="flex items-start gap-4">
                <div class="w-12 h-12 bg-black text-white flex items-center justify-center font-bold text-2xl border-2 border-black flex-shrink-0">3</div>
                <div>
                    <h3 class="font-bold text-lg uppercase">–¢–û–õ–ü–ê</h3>
                    <p class="text-sm">–°–æ–±–∏—Ä–∞–π –∑–µ–ª–µ–Ω—ã–µ –≤–æ—Ä–æ—Ç–∞, –∏–∑–±–µ–≥–∞–π –∫—Ä–∞—Å–Ω—ã—Ö. –ï—Å–ª–∏ –≥–≤–æ–∑–¥–∏ –∫–æ–Ω—á–∞—Ç—Å—è ‚Äî —Ç—ã –ø—Ä–æ–∏–≥—Ä–∞–ª.</p>
                </div>
            </div>

            <button onclick="document.getElementById('rulesModal').style.display='none'" class="mt-4 w-full bg-blue-600 hover:bg-blue-700 text-white font-bold py-4 text-xl border-2 border-black shadow-[4px_4px_0_black] active:translate-y-1 active:shadow-none transition-all">
                –ü–û–ù–Ø–¢–ù–û!
            </button>
        </div>
        
        <!-- –°–∫–æ—Ç—á –¥–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ã–π -->
        <div class="absolute -top-4 left-1/2 w-32 h-10 bg-white/40 backdrop-blur-sm transform -translate-x-1/2 -rotate-2 shadow-sm"></div>
    </div>
</div>

<!-- –ú–ï–ù–Æ –ü–ê–£–ó–´ -->
<div id="pauseOverlay">
  <div id="pauseMenu">
    <div class="hotkey-hint">ESC</div>
    <h2 class="pause-title">–ü–ê–£–ó–ê</h2>
    
    <!-- –í—ã–±–æ—Ä —Ç—Ä–µ–∫–∞ -->
    <div class="pause-section">
      <label class="pause-label">–ú—É–∑—ã–∫–∞–ª—å–Ω–∞—è –¥–æ—Ä–æ–∂–∫–∞</label>
      <div class="track-select">
        <button class="track-btn active" data-track="original" id="trackOriginal">–ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–ª</button>
        <button class="track-btn" data-track="vocal" id="trackInstrumental">–û—Ä–∏–≥–∏–Ω–∞–ª</button>
      </div>
    </div>
    
    <!-- –ì—Ä–æ–º–∫–æ—Å—Ç—å –º—É–∑—ã–∫–∏ -->
    <div class="pause-section">
      <label class="pause-label">–ì—Ä–æ–º–∫–æ—Å—Ç—å –º—É–∑—ã–∫–∏</label>
      <div class="volume-control">
        <button class="mute-btn" id="muteMusicBtn">üîä</button>
        <input type="range" class="volume-slider" id="musicVolume" min="0" max="100" value="70">
        <span class="volume-value" id="musicVolumeValue">70%</span>
      </div>
    </div>
    
    <!-- –ì—Ä–æ–º–∫–æ—Å—Ç—å —ç—Ñ—Ñ–µ–∫—Ç–æ–≤ -->
    <div class="pause-section">
      <label class="pause-label">–ì—Ä–æ–º–∫–æ—Å—Ç—å —ç—Ñ—Ñ–µ–∫—Ç–æ–≤</label>
      <div class="volume-control">
        <button class="mute-btn" id="muteSfxBtn">üîä</button>
        <input type="range" class="volume-slider" id="sfxVolume" min="0" max="100" value="50">
        <span class="volume-value" id="sfxVolumeValue">50%</span>
      </div>
    </div>
    
    <!-- –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π -->
    <div class="pause-actions">
      <button class="pause-btn primary" id="resumeBtn">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å</button>
      <button class="pause-btn secondary" onclick="location.reload()">–†–µ—Å—Ç–∞—Ä—Ç</button>
    </div>
  </div>
</div>

<!-- –ö–ù–û–ü–ö–ê –ü–ê–£–ó–´ –í –ò–ì–†–ï -->
<button id="pauseGameBtn" title="–ü–∞—É–∑–∞ (ESC)">‚è∏</button>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ---------- AUDIO SYSTEM ---------- */
const audioSystem = {
  bgm: new Audio(),
  currentTrack: 'original',
  isMuted: false,
  musicVolume: 0.7,
  sfxVolume: 0.5,
  pausedAt: 0,
  isPlaying: false,
  
  tracks: {
  original: 'song_instrumental.mp3',    // –¢–µ–ø–µ—Ä—å –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–ª –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
  vocal: 'song.mp3'                      // –í–æ–∫–∞–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è (–±—ã–≤—à–∏–π "–æ—Ä–∏–≥–∏–Ω–∞–ª")
},
  
  init() {
  this.bgm.loop = false; // –û—Ç–∫–ª—é—á–∞–µ–º –ø–æ–≤—Ç–æ—Ä
  this.bgm.volume = this.musicVolume;
  this.loadTrack('original');
  
  // –°–ª—É—à–∞–µ–º –æ–∫–æ–Ω—á–∞–Ω–∏–µ —Ç—Ä–µ–∫–∞
  this.bgm.addEventListener('ended', () => {
    this.isPlaying = false;
    // –ï—Å–ª–∏ –∏–≥—Ä–∞ –µ—â—ë –∏–¥—ë—Ç –∏ –Ω–µ –Ω–∞ –ø–∞—É–∑–µ ‚Äî –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –ª–æ–≥–∏–∫—É
    // –ù–∞–ø—Ä–∏–º–µ—Ä, –∞–≤—Ç–æ–ø–µ—Ä–µ—Ö–æ–¥ –Ω–∞ –¥—Ä—É–≥–æ–π —Ç—Ä–µ–∫ –∏–ª–∏ –ø—Ä–æ—Å—Ç–æ —Ç–∏—à–∏–Ω–∞
  });
},
  
  loadTrack(trackName) {
    this.currentTrack = trackName;
    this.bgm.src = this.tracks[trackName];
    this.bgm.load();
    if (this.isPlaying && !gamePaused) {
      this.bgm.play().catch(() => {});
    }
  },
  
  play() {
  this.isPlaying = true;
  if (!gamePaused && this.bgm.paused && this.bgm.currentTime >= this.bgm.duration - 0.1) {
    // –ï—Å–ª–∏ —Ç—Ä–µ–∫ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è, –Ω–µ –Ω–∞—á–∏–Ω–∞–µ–º –∑–∞–Ω–æ–≤–æ –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏
    return;
  }
  if (!gamePaused) {
    this.bgm.play().catch(() => {});
  }
},
  
  pause() {
    this.pausedAt = this.bgm.currentTime;
    this.bgm.pause();
  },
  
  resume() {
  if (this.isPlaying && !gamePaused) {
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è –ª–∏ —Ç—Ä–µ–∫
    if (this.bgm.currentTime >= this.bgm.duration - 0.1) {
      // –¢—Ä–µ–∫ –∑–∞–∫–æ–Ω—á–∏–ª—Å—è ‚Äî –Ω–µ –≤–æ–∑–æ–±–Ω–æ–≤–ª—è–µ–º
      return;
    }
    this.bgm.play().catch(() => {});
  }
},
  
  setMusicVolume(val) {
    this.musicVolume = val;
    this.bgm.volume = this.isMuted ? 0 : val;
  },
  
  setSfxVolume(val) {
    this.sfxVolume = val;
    // –û–±–Ω–æ–≤–ª—è–µ–º –≥—Ä–æ–º–∫–æ—Å—Ç—å –≤—Å–µ—Ö —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
    Object.values(sounds).forEach(sound => {
      sound.volume = this.isMuted ? 0 : val;
    });
  },

  playSoundWithPitch(soundName, baseRate = 1.0, variation = 0.15) {
    if (this.isMuted) return;
    const sound = sounds[soundName];
    if (!sound) return;
    
    // –°–æ–∑–¥–∞—ë–º –∫–ª–æ–Ω –¥–ª—è –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ–≥–æ playbackRate
    // (—á—Ç–æ–±—ã –Ω–µ –ø—Ä–µ—Ä—ã–≤–∞—Ç—å —É–∂–µ –∏–≥—Ä–∞—é—â–∏–π –∑–≤—É–∫)
    const clone = sound.cloneNode();
    
    // –°–ª—É—á–∞–π–Ω—ã–π –ø–∏—Ç—á: baseRate ¬± variation
    // –ù–∞–ø—Ä–∏–º–µ—Ä: 0.85 ... 1.15 –¥–ª—è baseRate=1, variation=0.15
    const randomPitch = baseRate + (Math.random() * variation * 2 - variation);
    clone.playbackRate = Math.max(0.5, Math.min(2.0, randomPitch)); // –æ–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º —Ä–∞–∑—É–º–Ω—ã–º–∏ –ø—Ä–µ–¥–µ–ª–∞–º–∏
    
    clone.volume = this.isMuted ? 0 : this.sfxVolume;
    clone.play().catch(() => {});
    
    // –ê–≤—Ç–æ–æ—á–∏—Å—Ç–∫–∞ –ø–æ—Å–ª–µ –ø—Ä–æ–∏–≥—Ä—ã–≤–∞–Ω–∏—è
    clone.onended = () => clone.remove();
  },
  
  toggleMute() {
    this.isMuted = !this.isMuted;
    const vol = this.isMuted ? 0 : this.musicVolume;
    this.bgm.volume = vol;
    Object.values(sounds).forEach(sound => {
      sound.volume = this.isMuted ? 0 : this.sfxVolume;
    });
    return this.isMuted;
  }
};

// –ó–≤—É–∫–æ–≤—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã
const sounds = {
  shoot: new Audio('sounds/shoot.mp3'),
  wallBreak: new Audio('sounds/wall_break.mp3'),
  bossKill: new Audio('sounds/boss_kill.mp3'),
  damage: new Audio('sounds/damage.mp3')
};

// –ü—Ä–µ–¥–∑–∞–≥—Ä—É–∑–∫–∞ –∑–≤—É–∫–æ–≤
Object.values(sounds).forEach(sound => {
  sound.load();
  sound.volume = 0.5;
});

// –§—É–Ω–∫—Ü–∏—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è –∑–≤—É–∫–∞
function playSound(soundName, usePitch = false) {
  if (usePitch) {
    audioSystem.playSoundWithPitch(soundName, 1.0, 1);
  } else {
    const sound = sounds[soundName];
    if (sound) {
      sound.currentTime = 0;
      sound.volume = audioSystem.sfxVolume;
      sound.play().catch(() => {});
    }
  }
}

/* ---------- preloader with progress ---------- */
const preEl = document.getElementById('mainMenu');
const startBtn = document.getElementById('startBtn');
const btnTextEl = document.getElementById('btnText');
const statusEl = document.getElementById('menuLoadStatus');

let audioReady = false;

// –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –∞—É–¥–∏–æ—Å–∏—Å—Ç–µ–º—É
audioSystem.init();

// –ó–∞–≥—Ä—É–∂–∞–µ–º –æ—Ä–∏–≥–∏–Ω–∞–ª—å–Ω—ã–π —Ç—Ä–µ–∫
fetch(audioSystem.tracks.original)
  .then(r => {
    if (!r.ok) throw new Error('network');
    const total = +r.headers.get('content-length');
    let loaded = 0;
    const reader = r.body.getReader();
    const stream = new ReadableStream({
      start(controller) {
        function pump() {
          reader.read().then(({done, value}) => {
            if (done) {
              controller.close();
              return;
            }
            loaded += value.byteLength;
            const pct = total ? (loaded / total * 100) : 0;
            if (statusEl) statusEl.textContent = `–ó–∞–≥—Ä—É–∑–∫–∞: ${Math.round(pct)}%`;
            controller.enqueue(value);
            pump();
          });
        }
        pump();
      }
    });
    return new Response(stream).blob();
  })
  .then(blob => {
    audioSystem.bgm.src = URL.createObjectURL(blob);
    audioReady = true;
    if (statusEl) statusEl.textContent = '–ì–æ—Ç–æ–≤–æ!';
    startBtn.disabled = false;
    startBtn.classList.remove('cursor-not-allowed', 'opacity-70');
    if (btnTextEl) btnTextEl.textContent = '–ò–ì–†–ê–¢–¨';
    fetchAndRenderMenuTop();
  })
  .catch(() => {
    startBtn.disabled = false;
    startBtn.textContent = '–ò–≥—Ä–∞—Ç—å –±–µ–∑ –∑–≤—É–∫–∞';
  });

// –°—Ç–∞—Ä—Ç –∏–≥—Ä—ã
startBtn.addEventListener('click', () => {
  audioSystem.play();
  preEl.style.display = 'none';
  document.getElementById('scoreboard').style.display = 'block';
  started = true;
  songStartTime = performance.now();
  // –°–±—Ä–∞—Å—ã–≤–∞–µ–º –≤—Ä–µ–º—è —Ç—Ä–µ–∫–∞ –ø—Ä–∏ –Ω–æ–≤–æ–π –∏–≥—Ä–µ
  audioSystem.bgm.currentTime = 0;
});

/* ---------- basic scene ---------- */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0a1030, 15, 100);   // —Ç—É–º–∞–Ω

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x0a1030);
document.body.appendChild(renderer.domElement);

/* —Å–≤–µ—Ç */
const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); // —Å—Ä–∞–∑—É –Ω—É–∂–Ω–∞—è —è—Ä–∫–æ—Å—Ç—å
dirLight.position.set(0, 10, 5);
scene.add(dirLight);

scene.add(new THREE.AmbientLight(0xffffff, 0.8)); // —á—É—Ç—å —É—Å–∏–ª–∏–º –æ–±—â–∏–π —Å–≤–µ—Ç

/* ---------- PAUSE SYSTEM ---------- */
let gamePaused = false;
const pauseOverlay = document.getElementById('pauseOverlay');


// –≠–ª–µ–º–µ–Ω—Ç—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø–∞—É–∑–æ–π
const trackOriginalBtn = document.getElementById('trackOriginal');
const trackInstrumentalBtn = document.getElementById('trackInstrumental');
const musicVolumeSlider = document.getElementById('musicVolume');
const musicVolumeValue = document.getElementById('musicVolumeValue');
const sfxVolumeSlider = document.getElementById('sfxVolume');
const sfxVolumeValue = document.getElementById('sfxVolumeValue');
const muteMusicBtn = document.getElementById('muteMusicBtn');
const muteSfxBtn = document.getElementById('muteSfxBtn');
const resumeBtn = document.getElementById('resumeBtn');

const pauseGameBtn = document.getElementById('pauseGameBtn');

// –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫–Ω–æ–ø–∫—É –ø–∞—É–∑—ã –ø—Ä–∏ —Å—Ç–∞—Ä—Ç–µ –∏–≥—Ä—ã
const originalStartBtnClick = startBtn.onclick;
startBtn.addEventListener('click', () => {
  pauseGameBtn.classList.add('visible');
});

// –ö–ª–∏–∫ –ø–æ –∫–Ω–æ–ø–∫–µ –ø–∞—É–∑—ã –≤ –∏–≥—Ä–µ
pauseGameBtn.addEventListener('click', (e) => {
  e.stopPropagation(); // –ß—Ç–æ–±—ã –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª –¥—Ä—É–≥–æ–π –∫–ª–∏–∫
  togglePause();
});

// –û–±–Ω–æ–≤–ª—è–µ–º –∏–∫–æ–Ω–∫—É –∫–Ω–æ–ø–∫–∏ –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è
const originalTogglePause = togglePause;
togglePause = function() {
  const wasPaused = gamePaused;
  originalTogglePause();
  pauseGameBtn.textContent = gamePaused ? '‚ñ∂' : '‚è∏';
};

function togglePause() {
  if (!started || gameOver) return;
  
  gamePaused = !gamePaused;
  
  if (gamePaused) {
    // –ü–∞—É–∑–∞
    audioSystem.pause();
    pauseOverlay.classList.add('active');
    // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∫—É—Ä—Å–æ—Ä —Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ —ç—Ç–æ –Ω–µ –º–æ–±–∏–ª—å–Ω–æ–µ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ
    if (!isMobile) {
      document.body.style.cursor = 'default';
    }
  } else {
    // –í–æ–∑–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ
    audioSystem.resume();
    pauseOverlay.classList.remove('active');
    // –í—Å–µ–≥–¥–∞ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –∫—É—Ä—Å–æ—Ä –≤ default (–Ω–µ none), —á—Ç–æ–±—ã –Ω–µ —Ç–µ—Ä—è—Ç—å –µ–≥–æ
    document.body.style.cursor = 'default';
  }
}

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≤—ã–±–æ—Ä–∞ —Ç—Ä–µ–∫–∞
trackOriginalBtn.addEventListener('click', () => {
  trackOriginalBtn.classList.add('active');
  trackInstrumentalBtn.classList.remove('active');
  audioSystem.loadTrack('original'); // –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞–ª
});

trackInstrumentalBtn.addEventListener('click', () => {
  trackInstrumentalBtn.classList.add('active');
  trackOriginalBtn.classList.remove('active');
  audioSystem.loadTrack('vocal'); // –í–æ–∫–∞–ª
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≥—Ä–æ–º–∫–æ—Å—Ç–∏ –º—É–∑—ã–∫–∏
musicVolumeSlider.addEventListener('input', (e) => {
  const val = parseInt(e.target.value) / 100;
  audioSystem.setMusicVolume(val);
  musicVolumeValue.textContent = e.target.value + '%';
  updateMuteButton(muteMusicBtn, val === 0);
});

muteMusicBtn.addEventListener('click', () => {
  const isMuted = audioSystem.toggleMute();
  musicVolumeSlider.value = isMuted ? 0 : Math.round(audioSystem.musicVolume * 100);
  musicVolumeValue.textContent = (isMuted ? 0 : Math.round(audioSystem.musicVolume * 100)) + '%';
  updateMuteButton(muteMusicBtn, isMuted);
  // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É SFX —Ç–æ–∂–µ
  sfxVolumeSlider.value = isMuted ? 0 : Math.round(audioSystem.sfxVolume * 100);
  sfxVolumeValue.textContent = (isMuted ? 0 : Math.round(audioSystem.sfxVolume * 100)) + '%';
  updateMuteButton(muteSfxBtn, isMuted);
});

// –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏ –≥—Ä–æ–º–∫–æ—Å—Ç–∏ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤
sfxVolumeSlider.addEventListener('input', (e) => {
  const val = parseInt(e.target.value) / 100;
  audioSystem.setSfxVolume(val);
  sfxVolumeValue.textContent = e.target.value + '%';
  updateMuteButton(muteSfxBtn, val === 0);
});

muteSfxBtn.addEventListener('click', () => {
  const isMuted = audioSystem.toggleMute();
  sfxVolumeSlider.value = isMuted ? 0 : Math.round(audioSystem.sfxVolume * 100);
  sfxVolumeValue.textContent = (isMuted ? 0 : Math.round(audioSystem.sfxVolume * 100)) + '%';
  updateMuteButton(muteSfxBtn, isMuted);
  // –°–∏–Ω—Ö—Ä–æ–Ω–∏–∑–∏—Ä—É–µ–º –∫–Ω–æ–ø–∫—É –º—É–∑—ã–∫–∏ —Ç–æ–∂–µ
  musicVolumeSlider.value = isMuted ? 0 : Math.round(audioSystem.musicVolume * 100);
  musicVolumeValue.textContent = (isMuted ? 0 : Math.round(audioSystem.musicVolume * 100)) + '%';
  updateMuteButton(muteMusicBtn, isMuted);
});

function updateMuteButton(btn, isMuted) {
  btn.textContent = isMuted ? 'üîá' : 'üîä';
  btn.classList.toggle('muted', isMuted);
}

// –ö–Ω–æ–ø–∫–∞ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å
resumeBtn.addEventListener('click', togglePause);

// –ì–æ—Ä—è—á–∞—è –∫–ª–∞–≤–∏—à–∞ ESC
window.addEventListener('keydown', (e) => {
  if (e.code === 'Escape' && started && !gameOver) {
    togglePause();
  }
});

// –ö–ª–∏–∫ –ø–æ –æ–≤–µ—Ä–ª–µ—é –∑–∞–∫—Ä—ã–≤–∞–µ—Ç –º–µ–Ω—é (–∫—Ä–æ–º–µ —Å–∞–º–æ–≥–æ –º–µ–Ω—é)
pauseOverlay.addEventListener('click', (e) => {
  if (e.target === pauseOverlay) {
    togglePause();
  }
});

/* ---------- player ---------- */
// –ª–µ–≥–∫–∏–µ –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –∏ –º–∞—Ç–µ—Ä–∏–∞–ª –¥–ª—è –≥–≤–æ–∑–¥—è (–º–µ–Ω—å—à–µ –ø–æ–ª–∏–≥–æ–Ω–æ–≤ + –¥–µ—à–µ–≤—ã–π —à–µ–π–¥–µ—Ä)
const nailBody = new THREE.ConeGeometry(0.08, 1.0, 24); // 100 -> 24
const nailHead = new THREE.CylinderGeometry(0.18, 0.18, 0.15, 12); // 16 -> 12
const playerMat = new THREE.MeshLambertMaterial({
  color: 0xc0c0c0
});

const RUNWAY_WIDTH  = 6;            // —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º mouseX

/* –º–∞—Å—Å–∏–≤, –∫—É–¥–∞ –±—É–¥–µ–º —Å–∫–ª–∞–¥—ã–≤–∞—Ç—å –≥—Ä—É–ø–ø—ã-–≥–≤–æ–∑–¥–∏ */
const nailGroup = new THREE.Group();   // –Ω–∞ —Å—Ü–µ–Ω–µ —Ç–æ–ª—å–∫–æ —ç—Ç–∞ –≥—Ä—É–ø–ø–∞
scene.add(nailGroup);

/* ---------- CROWD-LEVEL BANNER (—Å—Ü–µ–Ω–∞, –Ω–µ –≥—Ä—É–ø–ø–∞) ---------- */
const bannerCanvas = document.createElement('canvas');
bannerCanvas.width = 256; bannerCanvas.height = 128;
const bannerCtx = bannerCanvas.getContext('2d');

const bannerTex = new THREE.CanvasTexture(bannerCanvas);
const bannerMat = new THREE.MeshBasicMaterial({ map: bannerTex, transparent: true });
const bannerGeo = new THREE.PlaneGeometry(0.8, 0.4);
const bannerMesh = new THREE.Mesh(bannerGeo, bannerMat);

// --- CanvasTexture cache & helpers ---
// reuse canvas textures for gates and create reusable canvases for dynamic labels
const canvasCache = new Map();

function makeTextCanvas(w, h){
  const canvas = document.createElement('canvas');
  canvas.width = w; canvas.height = h;
  const ctx = canvas.getContext('2d');
  return { canvas, ctx };
}

function makeCheckeredTexture(size = 256){
  const c = document.createElement('canvas');
  c.width = c.height = size;
  const ctx = c.getContext('2d');
  const step = size / 8;

  for (let y = 0; y < 8; y++){
    for (let x = 0; x < 8; x++){
      const even = (x + y) % 2 === 0;
      ctx.fillStyle = even ? 'rgba(255,255,255,0.9)' : 'rgba(255,255,255,0.15)';
      ctx.fillRect(x * step, y * step, step, step);
    }
  }

  const tex = new THREE.CanvasTexture(c);
  tex.wrapS = tex.wrapT = THREE.RepeatWrapping;
  tex.repeat.set(2, 1);
  return tex;
}

// --- Cached gate panel materials ---
const gatePanelMatPos = new THREE.MeshBasicMaterial({
  color: 0x00ff00, transparent: true, opacity: 0.3, depthWrite: false
});
const gatePanelMatNeg = new THREE.MeshBasicMaterial({
  color: 0xff0000, transparent: true, opacity: 0.3, depthWrite: false
});


function getGateTexture(label){
  const key = 'gate:' + label;
  if (canvasCache.has(key)) return canvasCache.get(key);

  const { canvas, ctx } = makeTextCanvas(384, 256);
  const [topText, bottomText] = label.includes(' ') ? label.split(' ', 2) : ['–ì–ï–ô–¢', label];

  // draw once
  ctx.fillStyle = '#000a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';

  ctx.font = 'bold 42px sans-serif';
  ctx.textBaseline = 'top';
  ctx.fillText(topText, canvas.width / 2, 25);

  ctx.font = 'bold 72px sans-serif';
  ctx.textBaseline = 'middle';
  ctx.fillText(bottomText, canvas.width / 2, canvas.height * 0.55);

  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;
  canvasCache.set(key, tex);
  return tex;
}

// helper for dynamic small labels (one-time create; ctx stored on mesh.userData)
function makeLabelMesh(text, spawnZ){
  const { canvas, ctx } = makeTextCanvas(128, 64);
  ctx.fillStyle = '#000a';
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#fff';
  ctx.font = 'bold 48px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(text, canvas.width/2, canvas.height/2);

  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
  const geo = new THREE.PlaneGeometry(1, 0.5);
  const mesh = new THREE.Mesh(geo, mat);
  mesh.position.set(0, 1.2, spawnZ);
  // keep canvas + ctx for updates
  mesh.userData.canvas = canvas;
  mesh.userData.ctx = ctx;
  mesh.userData.tex = tex;
  return mesh;
}

// --- LABEL POOL (re-use dynamic wave labels) ---
const LABEL_POOL_SIZE = 60;
const labelPool = [];

// –∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø—É–ª–∞ (–ª–µ–Ω–∏–≤–æ ‚Äî —Å–æ–∑–¥–∞—ë–º –ø—É–ª –∑–∞—Ä–∞–Ω–µ–µ)
for (let i = 0; i < LABEL_POOL_SIZE; i++){
  const m = makeLabelMesh('0', 0);
  m.userData.active = false;
  m.visible = false;
  labelPool.push(m);
  // —Å—Ä–∞–∑—É –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –≤ —Å—Ü–µ–Ω—É ‚Äî makeLabelMesh —É–∂–µ –¥–æ–±–∞–≤–ª—è–ª; —É–±–µ—Ä—ë–º –µ–≥–æ
  scene.remove(m);
}

function acquireLabelMesh(text, spawnZ){
  for (let i = 0; i < labelPool.length; i++){
    const m = labelPool[i];
    if (!m.userData.active){
      m.userData.active = true;
      m.visible = true;
      m.position.set(0, 1.2, spawnZ);
      // –æ–±–Ω–æ–≤–∏–º —Ç–µ–∫—Å—Ç
      const canvas = m.userData.canvas;
      const ctx = m.userData.ctx;
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#000a';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#fff';
      ctx.font = 'bold 48px sans-serif';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(text, canvas.width / 2, canvas.height / 2);
      if (m.userData.tex) m.userData.tex.needsUpdate = true;
      scene.add(m);
      return m;
    }
  }
  // fallback: –µ—Å–ª–∏ –ø—É–ª –∏—Å—á–µ—Ä–ø–∞–Ω ‚Äî —Å–æ–∑–¥–∞—ë–º –Ω–æ–≤—É—é –º–µ—Ç–∫—É (—Ä–µ–¥–∫–∏–π —Å–ª—É—á–∞–π)
  const newM = makeLabelMesh(text, spawnZ);
  newM.userData.active = true;
  return newM;
}

function releaseLabelMesh(m){
  // –ø—Ä—è—á–µ–º –∏ –ø–æ–º–µ—á–∞–µ–º –Ω–µ–∞–∫—Ç–∏–≤–Ω–æ–π (–Ω–µ dispose)
  m.userData.active = false;
  m.visible = false;
  scene.remove(m);
}

bannerMesh.position.set(0, 2.2, 0); // –≤—Ä–µ–º–µ–Ω–Ω–∞—è, –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –≤ animate
scene.add(bannerMesh);

/* ------------- –ø–µ—Ä–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π ------------- */
function redistributeLevels() {
  const total = nailLevels.reduce((a, b) => a + b, 0);
  const avg   = Math.ceil(total / nailCount);

  nailLevels = Array(nailCount).fill(avg);
}

// ---- INSERT after redistributeLevels() or near other helper functions ----
function redistributePlayerLevelsFromTotal(total){
  total = Math.max(0, Math.floor(total));
  if (total <= 0){
    // –µ—Å–ª–∏ –≤—Å–µ —É—Ä–æ–≤–Ω–∏ –∑–∞–∫–æ–Ω—á–∏–ª–∏—Å—å ‚Äî –æ—Å—Ç–∞–≤–∏–º 1 –≥–≤–æ–∑–¥—å —Å 1 —É—Ä–æ–≤–Ω–µ–º (–±–µ–∑ –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–π —Å–º–µ—Ä—Ç–∏)
    nailCount = 1;
    nailLevels = [1];
    return;
  }

  // –µ—Å–ª–∏ —Ç–µ–∫—É—â–∏–π count —Å–ª–∏—à–∫–æ–º –≤–µ–ª–∏–∫ –¥–ª—è total -> —É–º–µ–Ω—å—à–∏—Ç—å count
  if (total < nailCount){
    nailCount = Math.max(1, total);
  }

  const base = Math.floor(total / nailCount);
  let rem = total - base * nailCount;
  nailLevels = [];
  for (let i = 0; i < nailCount; i++){
    const add = (rem > 0) ? 1 : 0;
    nailLevels.push(Math.max(1, base + add));
    if (rem > 0) rem--;
  }
}

/* —Ñ—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ—Å–±–æ—Ä–∫–∏ —Ç–æ–ª–ø—ã */
function rebuildNailFormation(){
  // —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –º–µ—à–∏
  while (nailGroup.children.length){
    nailGroup.remove(nailGroup.children[0]);
  }

  // –≤—ã—á–∏—Å–ª—è–µ–º spacing –ø–æ —Ç–æ–π –∂–µ —Ñ–æ—Ä–º—É–ª–µ, —á—Ç–æ–±—ã –≤–∏–∑—É–∞–ª—å–Ω–æ –Ω–µ –±—ã–ª–æ ¬´—Å–∫–∞—á–∫–æ–≤¬ª
  const desiredGroupWidth = (RUNWAY_WIDTH / 3) * 0.96;
  const spacing = desiredGroupWidth / Math.max(1, (MAX_NAILS - 1));

  for (let i = 0; i < nailCount; i++){
    const body = new THREE.Mesh(nailBody, playerMat);
    const head = new THREE.Mesh(nailHead, playerMat);

    body.position.y = 0;
    head.position.y = 0.575;
    body.rotation.z = Math.PI;

    const single = new THREE.Group();
    const level = nailLevels[i] || 1;

    single.add(body);
    single.add(head);

    // —Ä–∞—Å—Å—Ç–∞–≤–ª—è–µ–º –≤ –æ–¥–Ω—É –ª–∏–Ω–∏—é –ø–æ X
    const offset = (i - (nailCount - 1) / 2) * spacing;
    single.position.x = offset;

    // —Ü–≤–µ—Ç–æ–º –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å (–ø–æ –∂–µ–ª–∞–Ω–∏—é)
    // —Ü–≤–µ—Ç –¥–ª—è –≤—Å–µ–≥–æ –≥–≤–æ–∑–¥—è (–∏ —Å—Ç–µ—Ä–∂–Ω—è, –∏ —à–ª—è–ø–∫–∏)
    const nailMat = playerMat.clone();
    const hue = 0.44 + (level - 1) * 0.8;  // 0 = —Å–µ—Ä—ã–π, –¥–∞–ª—å—à–µ –∏–¥—ë—Ç –≤ –∑–µ–ª—ë–Ω—ã–π / –æ—Ä–∞–Ω–∂–µ–≤—ã–π
    nailMat.color.setHSL(hue, 0.44, 0.44);
    body.material = nailMat;
    head.material = nailMat;

    nailGroup.add(single);
  }

  /* update banner text */
  const totalLevel = nailLevels.reduce((a, b) => a + b, 0);
  bannerCtx.clearRect(0, 0, 256, 128);
  bannerCtx.fillStyle = '#000a';
  bannerCtx.fillRect(0, 0, 256, 128);
  bannerCtx.fillStyle = '#fff';
  bannerCtx.textAlign = 'center';
  bannerCtx.textBaseline = 'middle';
  bannerCtx.font = 'bold 64px sans-serif';
  bannerCtx.fillText(totalLevel.toString(), 128, 64);
  bannerTex.needsUpdate = true;
}

/* ---------- shooting params ---------- */
let fireRate = 1;
let lastShot = 0;
let fireRange = 15; // –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –º–∞–ª–µ–Ω—å–∫–∞—è –¥–∞–ª—å–Ω–æ—Å—Ç—å (–º–æ–∂–Ω–æ –º–µ–Ω—è—Ç—å)

/*  NEW  */
const MAX_NAILS   = 5;
let nailCount   = 1;
let nailLevels  = [1];

// ---------- Max-params & damage calc helpers (–Ω–æ–≤–æ–µ) ----------
// –ù–∞—á–∞–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (–±–∞–∑–∞)
const baseStats = {
  count: 1,
  nailLevels: [1],
  rate: 1,
  range: 15
};

// –¢–µ–æ—Ä–µ—Ç–∏—á–µ—Å–∫–∏–π –º–∞–∫—Å–∏–º—É–º
let maxParams = { ...baseStats, nailLevels: [...baseStats.nailLevels] };

// –ò—Å—Ç–æ—Ä–∏—è –ª—É—á—à–∏—Ö –≥–µ–π—Ç–æ–≤: Map(–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ Z => –ª—É—á—à–∏–π –≥–µ–π—Ç –≤ —ç—Ç–æ–º —Ä—è–¥—É)
const bestGatesHistory = new Map();
// constants for damage calc
const CONTACT_DIST = 0.7; // –¥–∏—Å—Ç–∞–Ω—Ü–∏—è –∫–æ–Ω—Ç–∞–∫—Ç–∞ (–∫–∞–∫ –≤ –∏–≥—Ä–æ–≤–æ–º –∫–æ–¥–µ ~0.7)
const TIME_CAP = 60;      // safety cap –µ—Å–ª–∏ —Ü–µ–ª—å –Ω–µ –¥–≤–∏–∂–µ—Ç—Å—è (—Å–µ–∫)

// —É—Ç–∏–ª–∏—Ç—ã
function sumLevels(arr){ return arr.reduce((a,b)=>a+b,0); }
function cloneLevels(arr){ return arr.slice(); }

// —Å–∏–º—É–ª—è—Ü–∏—è –ø—Ä–∏–º–µ–Ω–µ–Ω–∏—è –≥–µ–π—Ç–∞ –∫ –∑–∞–¥–∞–Ω–Ω—ã–º –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º (–Ω–µ –≤–ª–∏—è–µ—Ç –Ω–∞ —Ä–µ–∞–ª—å–Ω—É—é –∏–≥—Ä—É)
function applyGateToParams(base, g){
  const res = {
    count: base.count,
    nailLevels: cloneLevels(base.nailLevels),
    rate: base.rate,
    range: base.range
  };

  // helper: ensure at least one nail level exists
  if (res.nailLevels.length === 0) res.nailLevels = [1];

  // COUNT change (–º–æ–∂–µ—Ç –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–µ –∏–ª–∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ)
  if (g.action === 'count'){
    const val = g.val | 0;
    if (val > 0){
      // special: if adding when already at MAX_NAILS -> increase levels
      if (res.count === MAX_NAILS){
        // –¥–æ–±–∞–≤–ª—è–µ–º +val –∫ —É—Ä–æ–≤–Ω—è–º –≤—Å–µ—Ö –≥–≤–æ–∑–¥–µ–π
        res.nailLevels = res.nailLevels.map(x => x + val);
      } else {
        // –æ–±—ã—á–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ, –Ω–æ –Ω–µ –ø—Ä–µ–≤—ã—à–∞–µ–º MAX_NAILS; –ø–µ—Ä–µ–ø–æ–ª–Ω–µ–Ω–∏—è –ø—Ä–∏–±–∞–≤–ª—è–µ–º –≤ —É—Ä–æ–≤–Ω—è—Ö
        const maxLevel = Math.max(1, ...res.nailLevels);
        let newCount = res.count + val;
        // —Å–∫–æ–ª—å–∫–æ —Ä–µ–∞–ª—å–Ω–æ –º–æ–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –±–µ–∑ –ø—Ä–µ–≤—ã—à–µ–Ω–∏—è
        const space = Math.max(0, MAX_NAILS - res.count);
        const toAdd = Math.min(space, val);
        for (let i = 0; i < toAdd; i++) res.nailLevels.push(maxLevel);
        res.count = res.count + toAdd;
        const overflow = val - toAdd;
        if (overflow > 0){
          // –µ—Å–ª–∏ –æ—Å—Ç–∞–ª—Å—è overflow, –ø—Ä–µ–≤—Ä–∞—â–∞–µ–º –µ–≥–æ –≤ –ø–æ–≤—ã—à–µ–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π –¥–ª—è –≤—Å–µ—Ö –≥–≤–æ–∑–¥–µ–π
          res.nailLevels = res.nailLevels.map(x => x + overflow);
        }

        // special legacy behaviour: case val===2 && original count===4 in original code
        // handled by above (if toAdd ==1 and overflow==1 then levels increased by 1 and one nail added)
      }
    } else if (val < 0){
      // —É–¥–∞–ª–µ–Ω–∏–µ –≥–≤–æ–∑–¥–µ–π ‚Äî –º–∞–∫—Å–∏–º—É–º –¥–æ 1
      const remove = Math.min(-val, Math.max(0, res.count - 1));
      for (let i = 0; i < remove; i++){
        res.nailLevels.pop();
      }
      res.count = Math.max(1, res.count - remove);
    }
  }

  // LEVEL change: applies to –∫–∞–∂–¥—ã–π –≥–≤–æ–∑–¥—å (–ø—Ä–∏–±–∞–≤–ª—è–µ—Ç val –∫ —É—Ä–æ–≤–Ω—è–º)
  if (g.action === 'level'){
    const val = g.val | 0;
    res.nailLevels = res.nailLevels.map(x => Math.max(1, x + val));
  }

  // RATE change
  if (g.action === 'rate'){
    if (g.mode === 'mul'){
      res.rate = Math.max(0.01, res.rate * g.val);
    } else {
      res.rate = Math.max(0.01, res.rate + g.val);
    }
  }

  // RANGE change
  if (g.action === 'range'){
    if (g.mode === 'mul'){
      res.range = Math.max(0.1, res.range * g.val);
    } else {
      res.range = Math.max(0.1, res.range + g.val);
    }
  }

  // adjust count if levels array length differs
  res.count = Math.max(1, res.nailLevels.length);
  return res;
}

// approach speed: —Å–∫–æ—Ä–æ—Å—Ç—å —Å–±–ª–∏–∂–µ–Ω–∏—è —Ü–µ–ª–∏ (—é–Ω–∏—Ç—ã/—Å–µ–∫)
function getApproachSpeed(){
  // ENEMY_SPEED, difficultyFactor, playerSpeed –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å –≤ –æ–∫—Ä—É–∂–µ–Ω–∏–∏ (–∫–∞–∫ –≤ –æ—Å–Ω–æ–≤–Ω–æ–º –∫–æ–¥–µ)
  return Math.max(0, ENEMY_SPEED * difficultyFactor + (typeof playerSpeed !== 'undefined' ? playerSpeed : 0));
}

// –≤—ã—á–∏—Å–ª—è–µ–º —á–∏—Å–ª–æ –≤—ã—Å—Ç—Ä–µ–ª–æ–≤, –∫–æ—Ç–æ—Ä—ã–µ —É—Å–ø–µ—é—Ç —Å–¥–µ–ª–∞—Ç—å, –ø–æ–∫–∞ —Ü–µ–ª—å –ø–æ–π–¥–µ—Ç –æ—Ç fireRange –¥–æ –∫–æ–Ω—Ç–∞–∫—Ç–∞
function calcShotsCount(fireRange, contactDist, approachSpeed, fireRate){
  if (approachSpeed <= 1e-6) {
    // —Ü–µ–ª—å –ø—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏ –Ω–µ –¥–≤–∏–∂–µ—Ç—Å—è ‚Äî –æ–≥—Ä–∞–Ω–∏—á–∏–º –ø–æ TIME_CAP
    return Math.floor(TIME_CAP * fireRate) + 1;
  }
  const t_contact = Math.max(0, (fireRange - contactDist) / approachSpeed);
  return Math.floor(t_contact * fireRate) + 1;
}

// –æ—Å–Ω–æ–≤–Ω–∞—è –º–µ—Ç—Ä–∏–∫–∞: –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —É—Ä–æ–Ω –ø–æ –æ–¥–Ω–æ–π —Ü–µ–ª–∏, —Å—Ç–∞—Ä—Ç—É—é—â–µ–π –Ω–∞ distance=fireRange,
// –ø—Ä–∏ –Ω–µ–ø—Ä–µ—Ä—ã–≤–Ω–æ–π —Å—Ç—Ä–µ–ª—å–±–µ –¥–æ –∫–æ–Ω—Ç–∞–∫—Ç–∞ (–∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è —Å—É–º–º–∞—Ä–Ω—ã–π —É—Ä–æ–≤–µ–Ω—å –≤—Å–µ—Ö –≥–≤–æ–∑–¥–µ–π –∫–∞–∫ –º–æ—â–Ω–æ—Å—Ç—å –≤—ã—Å—Ç—Ä–µ–ª–∞)
function calcMaxDamageForOneTarget(params){
  // params: { nailLevels: [...], rate, range }
  const approach = getApproachSpeed();
  const shots = calcShotsCount(params.range, CONTACT_DIST, approach, params.rate);
  const damagePerShot = sumLevels(params.nailLevels); // —Å—É–º–º–∞—Ä–Ω–∞—è —Å–∏–ª–∞ –æ–¥–Ω–æ–≥–æ –≤—ã—Å—Ç—Ä–µ–ª–∞
  return shots * damagePerShot;
}

// –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, —É–ª—É—á—à–∞–µ—Ç –ª–∏ –≥–µ–π—Ç –ø–∞—Ä–∞–º–µ—Ç—Ä—ã (true –µ—Å–ª–∏ —Ö–æ—Ç—å –æ–¥–∏–Ω –ø–∞—Ä–∞–º–µ—Ç—Ä –≤–æ–∑—Ä–∞—Å—Ç—ë—Ç)
function isGatePositiveForBase(base, g){
  const after = applyGateToParams(base, g);
  const baseSum = sumLevels(base.nailLevels);
  const afterSum = sumLevels(after.nailLevels);
  return (after.count > base.count) || (afterSum > baseSum) || (after.rate > base.rate) || (after.range > base.range);
}

// –≤—ã–±–æ—Ä –ª—É—á—à–µ–≥–æ –≥–µ–π—Ç–∞ –∏–∑ –ø–∞—Ä—ã –ø–æ ŒîDamage (—Å —Å–æ–±–ª—é–¥–µ–Ω–∏–µ–º –ø—Ä–∞–≤–∏–ª–∞: –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π –ø—Ä–µ–≤—ã—à–µ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–≥–æ)
function chooseBestGateFromPair(g1, g2){
  const base = { ...maxParams, nailLevels: cloneLevels(maxParams.nailLevels) };
  const a1 = applyGateToParams(base, g1);
  const a2 = applyGateToParams(base, g2);

  const p1 = isGatePositiveForBase(base, g1);
  const p2 = isGatePositiveForBase(base, g2);

  // –µ—Å–ª–∏ –æ–¥–∏–Ω –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π, –¥—Ä—É–≥–æ–π –Ω–µ—Ç ‚Äî –±–µ—Ä—ë–º –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π
  if (p1 && !p2) return { chosen: g1, applied: a1, info: 'g1 positive' };
  if (p2 && !p1) return { chosen: g2, applied: a2, info: 'g2 positive' };

  // –∏–Ω–∞—á–µ –æ—Ü–µ–Ω–∏–≤–∞–µ–º –ø–æ ŒîDamage
  const baseDamage = calcMaxDamageForOneTarget(base);
  const d1 = calcMaxDamageForOneTarget(a1) - baseDamage;
  const d2 = calcMaxDamageForOneTarget(a2) - baseDamage;

  if (d1 === d2){
    // tie-breaker: prefer larger increase in sumLevels, then count, then rate
    const sumBase = sumLevels(base.nailLevels);
    const sum1 = sumLevels(a1.nailLevels);
    const sum2 = sumLevels(a2.nailLevels);
    if (sum1 !== sum2) return sum1 > sum2 ? { chosen:g1, applied:a1, info:'tie by sumLevels' } : { chosen:g2, applied:a2, info:'tie by sumLevels' };
    if (a1.count !== a2.count) return a1.count > a2.count ? { chosen:g1, applied:a1, info:'tie by count' } : { chosen:g2, applied:a2, info:'tie by count' };
    if (a1.rate !== a2.rate) return a1.rate > a2.rate ? { chosen:g1, applied:a1, info:'tie by rate' } : { chosen:g2, applied:a2, info:'tie by rate' };
    return { chosen:g1, applied:a1, info:'tie fallback' };
  }

  return d1 > d2 ? { chosen:g1, applied:a1, info:'d1>d2' } : { chosen:g2, applied:a2, info:'d2>d1' };
}

function recalculateMaxParams() {
  // –ù–∞—á–∏–Ω–∞–µ–º —Å —á–∏—Å—Ç–æ–π –±–∞–∑—ã
  let temp = { 
    count: baseStats.count, 
    nailLevels: [...baseStats.nailLevels], 
    rate: baseStats.rate, 
    range: baseStats.range 
  };

  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –∏—Å—Ç–æ—Ä–∏—é: –≤ –Ω–∞—à–µ–π –∏–≥—Ä–µ –∏–≥—Ä–æ–∫ –µ–¥–µ—Ç –æ—Ç 0 –≤ —Å—Ç–æ—Ä–æ–Ω—É —É–º–µ–Ω—å—à–µ–Ω–∏—è (0, -10, -50)
  // –ü–æ—ç—Ç–æ–º—É "—Ä–∞–Ω–Ω–∏–µ" –≥–µ–π—Ç—ã –∏–º–µ—é—Ç –±–æ–ª—å—à–∏–π Z (–±–ª–∏–∂–µ –∫ 0)
  const sortedZ = Array.from(bestGatesHistory.keys()).sort((a, b) => b - a);

  for (let z of sortedZ) {
    const gate = bestGatesHistory.get(z);
    temp = applyGateToParams(temp, gate);
  }

  // –û–±–Ω–æ–≤–ª—è–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –º–∞–∫—Å–∏–º—É–º
  maxParams.count = temp.count;
  maxParams.nailLevels = [...temp.nailLevels];
  maxParams.rate = temp.rate;
  maxParams.range = temp.range;
}

function registerGateOpportunity(gate, z) {
  // –û–∫—Ä—É–≥–ª—è–µ–º Z –¥–æ 0.5, —á—Ç–æ–±—ã —Å—Ç–µ–Ω—ã –≤ –æ–¥–Ω–æ–º —Ä—è–¥—É —Ç–æ—á–Ω–æ —Å–∫–ª–µ–∏–ª–∏—Å—å –≤ –æ–¥–∏–Ω ID
  const rowId = Math.round(z * 2) / 2;
  
  if (!bestGatesHistory.has(rowId)) {
    // –ï—Å–ª–∏ –≤ —ç—Ç–æ–º —Ä—è–¥—É –µ—â–µ –Ω–∏—á–µ–≥–æ –Ω–µ –±—ã–ª–æ - –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–ª—è–µ–º, –µ—Å–ª–∏ –≥–µ–π—Ç –Ω–µ "–ø—É—Å—Ç–æ–π"
    bestGatesHistory.set(rowId, gate);
    recalculateMaxParams();
  } else {
    // –ï—Å–ª–∏ –≤ —Ä—è–¥—É —É–∂–µ –µ—Å—Ç—å –≥–µ–π—Ç, —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –∏—Ö –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª
    const currentBestInRow = bestGatesHistory.get(rowId);
    
    // –°—á–∏—Ç–∞–µ–º —Å—Ç–∞—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ –±—ã–ª–∏ —É –∏–≥—Ä–æ–∫–∞ –¢–û–ß–ù–û –î–û —ç—Ç–æ–≥–æ —Ä—è–¥–∞ Z
    let statsBefore = { ...baseStats, nailLevels: [...baseStats.nailLevels] };
    const sortedZ = Array.from(bestGatesHistory.keys()).sort((a, b) => b - a);
    for (let prevZ of sortedZ) {
      if (prevZ > rowId) { // –ï—Å–ª–∏ Z –±–æ–ª—å—à–µ, –∑–Ω–∞—á–∏—Ç —ç—Ç–æ—Ç —Ä—è–¥ –±—ã–ª –ø—Ä–æ–π–¥—ë–Ω —Ä–∞–Ω—å—à–µ
        statsBefore = applyGateToParams(statsBefore, bestGatesHistory.get(prevZ));
      }
    }

    // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º —É—Ä–æ–Ω: —á—Ç–æ –±—É–¥–µ—Ç, –µ—Å–ª–∏ –ø—Ä–∏–º–µ–Ω–∏—Ç—å —Å—Ç–∞—Ä—ã–π –≥–µ–π—Ç –∏ —á—Ç–æ –±—É–¥–µ—Ç, –µ—Å–ª–∏ –Ω–æ–≤—ã–π
    const dmgOld = calcMaxDamageForOneTarget(applyGateToParams(statsBefore, currentBestInRow));
    const dmgNew = calcMaxDamageForOneTarget(applyGateToParams(statsBefore, gate));

    if (dmgNew > dmgOld) {
      bestGatesHistory.set(rowId, gate);
      recalculateMaxParams();
    }
  }
}

/* ---------- RUNTIME FLAGS ---------- */
let started   = false;
let shakeTime = 0; // –ü–µ—Ä–µ–º–µ–Ω–Ω–∞—è –¥–ª—è —ç—Ñ—Ñ–µ–∫—Ç–∞ —Ç—Ä—è—Å–∫–∏
let gameOver  = false;
let songStartTime = 0;            // –º–æ–º–µ–Ω—Ç, –∫–æ–≥–¥–∞ –Ω–∞–∂–∞–ª–∏ ¬´–ù–∞—á–∞—Ç—å¬ª
const SONG_DURATION = 207;        // —Å–µ–∫—É–Ω–¥—ã

// new scoring: hearts (–ø–æ 1) –∏ —Å—Ç–µ–Ω—ã (–ø–æ 100)
let heartCount = 0;
let wallCount = 0;

/* ---------- FINISH GATE ---------- */
let finishGate = null;
let finishSpawned = false;
let finishPassed = false;
let finishZ = null;

// –∑–∞ —Å–∫–æ–ª—å–∫–æ —Å–µ–∫—É–Ω–¥ –¥–æ –∫–æ–Ω—Ü–∞ –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —Ñ–∏–Ω–∏—à
const FINISH_PREP_TIME = 24; // —Å–µ–∫

function computeScore(){
  return (Number(heartCount) || 0) + (Number(wallCount) || 0) * 100;
}
function updateScoreUI(){
  const scEl = document.getElementById('scoreCount');
  if (scEl) scEl.textContent = computeScore();
}
// initial render
updateScoreUI();

// --- expose tiny getters so non-module script can read current values ---
window.computeScore = () => computeScore();   // –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç –∞–∫—Ç—É–∞–ª—å–Ω—ã–π total
window.getHeartCount = () => heartCount;
window.getWallCount  = () => wallCount;

rebuildNailFormation();   // —Å–æ–∑–¥–∞—ë–º –ø–µ—Ä–≤–∏–π –≥–≤–æ–∑–¥—å

/* ---------- bullets ---------- */
const bulletGeo  = new THREE.SphereGeometry(0.08,8,8);
const bigBulletGeo = new THREE.SphereGeometry(0.25,16,16);
// ‚ö° 2. Shared bullet materials
// –ø—É–ª–∏ ‚Äî –ø—Ä–æ—Å—Ç–æ–π –º–∞—Ç–µ—Ä–∏–∞–ª –±–µ–∑ PBR (–±—ã—Å—Ç—Ä–µ–µ –Ω–∞ GPU)
const bulletMat = new THREE.MeshBasicMaterial({ color: 0xffff00 });
const bigBulletMat = new THREE.MeshBasicMaterial({ color: 0xff8800 });


const bullets = [];

// --- BULLET POOL ---
const BULLET_POOL_SMALL = 120;
const BULLET_POOL_BIG = 120;
const bulletPoolSmall = [];
const bulletPoolBig = [];

function createBulletMesh(isBig){
  const g = isBig ? bigBulletGeo : bulletGeo;
  const m = new THREE.Mesh(g, isBig ? bigBulletMat : bulletMat);
  m.visible = false;
  m.userData.active = false;
  scene.add(m);
  return m;
}
for (let i = 0; i < BULLET_POOL_SMALL; i++) bulletPoolSmall.push(createBulletMesh(false));
for (let i = 0; i < BULLET_POOL_BIG; i++) bulletPoolBig.push(createBulletMesh(true));

function acquireBulletMesh(isBig){
  const pool = isBig ? bulletPoolBig : bulletPoolSmall;
  for (let i = 0; i < pool.length; i++){
    const m = pool[i];
    if (!m.userData.active){
      m.userData.active = true;
      m.visible = true;
      m.rotation.set(0,0,0);
      m.scale.set(1,1,1);
      return m;
    }
  }
  return null;
}
function releaseBulletMesh(m){
  m.userData.active = false;
  m.visible = false;
}

// —Å–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª—å –≤ —é–Ω–∏—Ç–∞—Ö/—Å–µ–∫ (‚âà0.4 —é–Ω/–∫–∞–¥—Ä –ø—Ä–∏ 60fps ‚Üí ~24 —é–Ω/—Å–µ–∫)
const BULLET_SPEED = 24;
// —Ö—Ä–∞–Ω–∏–º –≤—Ä–µ–º—è –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ –∫–∞–¥—Ä–∞ –¥–ª—è —Ä–∞—Å—á—ë—Ç–∞ dt
let prevTime = 0;


/* ---------- enemies ---------- */
/* ---------- shared heart geometry ---------- */
const _heartShape = new THREE.Shape();
((s = _heartShape) => {
  s.moveTo(5, 5);
  s.bezierCurveTo(5, 5, 4, 0, 0, 0);
  s.bezierCurveTo(-6, 0, -6, 7, -6, 7);
  s.bezierCurveTo(-6, 11, -3, 15.4, 5, 19);
  s.bezierCurveTo(12, 15.4, 16, 11, 16, 7);
  s.bezierCurveTo(16, 7, 16, 0, 10, 0);
  s.bezierCurveTo(7, 0, 5, 5, 5, 5);
})();

const heartGeo = new THREE.ExtrudeGeometry(_heartShape, 8);
heartGeo.center();
heartGeo.scale(0.05, 0.05, 0.05); // 0.4 / 4 = 0.1, –Ω–æ –µ—â—ë √ó0.5 —á—Ç–æ–±—ã ‚âà0.2 —Ä–∞–∑–º–µ—Ä
heartGeo.rotateZ(Math.PI);

const enemyGeo = heartGeo;   // shared
const enemyMat = new THREE.MeshLambertMaterial({ color: 0xff0040 });

// --- ENEMY POOL ---
const ENEMY_POOL_SIZE = 600;
const enemyPool = [];
// --- –°–ò–°–¢–ï–ú–ê –í–´–õ–ï–¢–ê–Æ–©–ò–• –û–ß–ö–û–í ---
const floatTextPool = [];
const activeFloatTexts = [];

for (let i = 0; i < 30; i++) {
  const { canvas, ctx } = makeTextCanvas(256, 128);
  const tex = new THREE.CanvasTexture(canvas);
  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true, depthTest: false });
  const sprite = new THREE.Sprite(mat);
  sprite.visible = false;
  scene.add(sprite);
  floatTextPool.push({ sprite, canvas, ctx, tex, mat });
}

function spawnScoreText(x, y, z, text) {
  const item = floatTextPool.find(t => !t.sprite.visible);
  if (!item) return;

  const { sprite, ctx, tex, canvas } = item;
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#00ff88'; // –¢–æ—Ç —Å–∞–º—ã–π –∑–µ–ª–µ–Ω—ã–π
  ctx.font = 'bold 80px sans-serif';
  ctx.textAlign = 'center';
  ctx.strokeStyle = 'black';
  ctx.lineWidth = 8;
  ctx.strokeText(text, 128, 80);
  ctx.fillText(text, 128, 80);
  tex.needsUpdate = true;

  sprite.position.set(x, y + 1, z);
  sprite.scale.set(1.5, 0.75, 1);
  sprite.visible = true;
  activeFloatTexts.push({ sprite, startTime: performance.now(), startY: y + 1 });
}

// --- –°–ò–°–¢–ï–ú–ê "–ë–£–ú–ê–ñ–ù–´–•" –û–ë–†–´–í–ö–û–í (–í–ó–†–´–í) ---
const particlePool = [];
for (let i = 0; i < 150; i++) {
  // –î–µ–ª–∞–µ–º —á–∞—Å—Ç–∏—Ü—ã –≤—ã—Ç—è–Ω—É—Ç—ã–º–∏ –∏ –æ—Å—Ç—Ä—ã–º–∏, –∫–∞–∫ –æ—Å–∫–æ–ª–∫–∏
  const pGeo = new THREE.PlaneGeometry(0.25, 0.25, 0.2);
  const pMat = new THREE.MeshBasicMaterial({ color: 0xffffff, side: THREE.DoubleSide });
  const p = new THREE.Mesh(pGeo, pMat);
  p.visible = false;
  scene.add(p);
  particlePool.push({ 
    mesh: p, 
    vel: new THREE.Vector3(), 
    rot: new THREE.Vector3(),
    life: 0 
  });
}

function spawnBurst(x, y, z, color = 0xffffff, count = 8) {
  let spawned = 0;
  for (let p of particlePool) {
    if (spawned >= count) break;
    if (!p.mesh.visible) {
      p.mesh.visible = true;
      p.mesh.position.set(x, y, z);
      p.mesh.material.color.set(color);
      p.vel.set((Math.random()-0.5)*8, (Math.random())*6, (Math.random()-0.5)*8);
      p.rot.set(Math.random()*0.2, Math.random()*0.2, Math.random()*0.2);
      p.life = 1.0;
      spawned++;
    }
  }
}
function createEnemyMesh(){
  const m = new THREE.Mesh(enemyGeo, enemyMat);
  m.visible = false;
  m.userData.active = false;
  scene.add(m);
  return m;
}
for (let i = 0; i < ENEMY_POOL_SIZE; i++) enemyPool.push(createEnemyMesh());

function acquireEnemyMesh(){
  for (let i = 0; i < enemyPool.length; i++){
    const m = enemyPool[i];
    if (!m.userData.active){
      m.userData.active = true;
      m.userData.pooled = true;
      m.visible = true;
      m.rotation.set(0,0,0);
      m.scale.set(1,1,1);
      return m;
    }
  }
  return null;
}
function releaseEnemyMesh(m){
  m.userData.active = false;
  m.visible = false;
}

let enemies = [];
let enemyLabels = []; // { group, mesh, initial }


/* ---------- gates ---------- */
const gateGeo = new THREE.BoxGeometry(2,2,0.2);
const gates = [];

/* ---------- Gate registry (scalable) ---------- */
const gateRegistry = [
  { weight: 1,  factory: () => ({ label: '–£–†–û–í–ï–ù–¨ +1', action: 'level', val: 1 }) },
  { weight: 10, factory: () => ({ label: '–£–†–û–í–ï–ù–¨ -1', action: 'level', val: -1 }) },
  { weight: 15, factory: () => ({ label: '–ì–í–û–ó–î–ò +1', action: 'count', val: 1 }) },
  { weight: 1,  factory: () => ({ label: '–ì–í–û–ó–î–ò +2', action: 'count', val: 2 }) },
  { weight: 15, factory: () => ({ label: '–ì–í–û–ó–î–ò -1', action: 'count', val: -1 }) },

  { weight: 15, factory: () => {
      // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç 0.2 –¥–æ 0.8. –ë–æ–ª—å—à–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è (0.8) –≤—ã–ø–∞–¥–∞—é—Ç —Ä–µ–∂–µ.
      const val = +(0.1 + Math.pow(Math.random(), 1.9) * 0.6).toFixed(1);
      return { label: `–°–¢–†–ï–õ–¨–ë–ê +${val}`, action: 'rate', val: val };
    }
  },

  { weight: 10, factory: () => {
    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ –æ—Ç 0.3 –¥–æ 0.7. 
    // –ë–ª–∞–≥–æ–¥–∞—Ä—è Math.pow(..., 2) –±–æ–ª—å—à–∏–µ —à—Ç—Ä–∞—Ñ—ã (0.7) –±—É–¥—É—Ç –ø–∞–¥–∞—Ç—å —Ä–µ–∂–µ.
    const val = +(0.2 + Math.pow(Math.random(), 1.5) * 0.5).toFixed(1);
    return { label: `–°–¢–†–ï–õ–¨–ë–ê -${val}`, action: 'rate', val: -val };
  }
},

  { weight: 15, factory: () => {
      const val = 1 + Math.floor(Math.random() * 3); // 1‚Ä¶3
      return { label: `–î–ê–õ–¨–ù–û–°–¢–¨ +${val}`, action: 'range', val };
    }
  },
  { weight: 10, factory: () => ({ label: '–î–ê–õ–¨–ù–û–°–¢–¨ -2', action: 'range', val: -2 }) },
  { weight: 5,  factory: () => ({ label: '–î–ê–õ–¨–ù–û–°–¢–¨ /2', action: 'range', mode: 'mul', val: 0.5 }) },
  { weight: 5,  factory: () => ({ label: '–î–ê–õ–¨–ù–û–°–¢–¨ √ó1.2', action: 'range', mode: 'mul', val: 1.2 }) },
];

/* ---------- build cumulative distribution once ---------- */
let totalWeight = 0;
const cdf = [];
gateRegistry.forEach(({ weight, factory }) => {
  totalWeight += weight;
  cdf.push({ limit: totalWeight, factory });
});

/* ---------- universal picker ---------- */
function pickGate() {
  const roll = Math.random() * totalWeight;
  for (const { limit, factory } of cdf) {
    if (roll < limit) return factory();
  }
  return cdf[cdf.length - 1].factory(); // should never happen
}

/* ---------- dynamic spawning ---------- */
let lastSpawnZ = 0;
const SONG_LENGTH_SEC = 215;
const FPS = 60;
const levelLength = SONG_LENGTH_SEC * FPS;

// ---- spawn spacing config ----
// –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –ø—Ä–æ–º–µ–∂—É—Ç–æ–∫ —Å–ø–∞–≤–Ω–∞ –≤ –º–∏—Ä–æ–≤—ã—Ö —é–Ω–∏—Ç–∞—Ö.
// –ü–æ–¥–±–∏—Ä–∞–π –ø–æ–¥ –∏–≥—Ä—É; –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é –±–ª–∏–∑–∫–æ –∫ –ø—Ä–µ–¥—ã–¥—É—â–µ–º—É —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω–æ–º—É 20.
const MIN_SPAWN_GAP = 5;

// –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π –∏–Ω—Ç–µ—Ä–≤–∞–ª = [MIN_SPAWN_GAP, 1.5 * MIN_SPAWN_GAP]
function randSpawnGap(){
  return MIN_SPAWN_GAP * (1 + Math.random() * 1.5);
}

// –º–∞–ª–µ–Ω—å–∫–∞—è –≤—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è ‚Äî –≤—ã–±–æ—Ä —Å–º–µ—â–µ–Ω–∏—è –æ—Ç –±–∞–∑–æ–≤–æ–≥–æ Z
function randOffsetFromBase(){
  return randSpawnGap();
}

// —Å—á—ë—Ç—á–∏–∫ –ø–æ–¥—Ä—è–¥ –≤—ã–ø–∞–≤—à–∏—Ö –≤–æ–ª–Ω —Å –≤—Ä–∞–≥–∞–º–∏
let consecutiveEnemyWaves = 0;

let consecutiveWallWaves = 0;
let consecutiveGateWaves = 0;

let lastWallConfig = null;
let wallConfigRepeat = 0;

let lastGateConfig = null;
let gateConfigRepeat = 0;

// –µ—Å–ª–∏ —Ö–æ—á–µ—à—å —Å–¥–µ–ª–∞—Ç—å –ø—Ä–∞–≤–∏–ª–∞ –±–æ–ª–µ–µ –º—è–≥–∫–∏–º–∏ ‚Äî –º–µ–Ω—è–π —ç—Ç–∏ –∑–Ω–∞—á–µ–Ω–∏—è
const MAX_CONSECUTIVE_ENEMY_WAVES = 2; // –ø–æ—Å–ª–µ 2 –≤–æ–ª–Ω –ø–æ–¥—Ä—è–¥ —Ç—Ä–µ—Ç—å—è —Ä–∞–∑—Ä–µ—à–∞–µ—Ç—Å—è —Å –º–∞–ª–æ–π –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å—é
const ENEMY_REPEAT_SMALL_CHANCE = 0.05; // –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å —Ç—Ä–µ—Ç—å–µ–π –≤–æ–ª–Ω—ã (5%)

/* ---------- infinite runway ---------- */
const RUNWAY_LENGTH = 80;
const EDGE_HEIGHT   = 0.2;
const gateWidth = RUNWAY_WIDTH / 2;

// ---- WALL (–≤–∏—Ç—Ä–∏–Ω–∞) system ----
const WALL_WIDTH = RUNWAY_WIDTH / 3; // —à–∏—Ä–∏–Ω–∞ —Å—Ç–µ–Ω–∫–∏ (1/3 –¥–æ—Ä–æ–∂–∫–∏)
const WALL_HEIGHT = 2;

// –ø—É–ª —Å—Ç–µ–Ω
const WALL_POOL_SIZE = 30;
const wallPool = [];
const walls = []; // –∞–∫—Ç–∏–≤–Ω—ã–µ —Å—Ç–µ–Ω–∫–∏ –Ω–∞ —Å—Ü–µ–Ω–µ

// helper: create wall mesh with glass plane + big canvas text for health
// helper: create wall mesh with glass plane + big canvas text for health
function createWallMesh(){
  const group = new THREE.Group();

  // glass plane (–ø—Ä–æ—Å—Ç–æ–µ, –ª—ë–≥–∫–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ)
  const glassMat = new THREE.MeshBasicMaterial({
    color: 0x88ccee, transparent: true, opacity: 0.18, side: THREE.DoubleSide
  });
  const glass = new THREE.Mesh(new THREE.PlaneGeometry(WALL_WIDTH, WALL_HEIGHT), glassMat);
  glass.position.set(0, 0, 0);
  group.add(glass);

  // thin frame / edges
  const edgeGeo = new THREE.EdgesGeometry(new THREE.PlaneGeometry(WALL_WIDTH, WALL_HEIGHT));
  const edges = new THREE.LineSegments(edgeGeo, new THREE.LineBasicMaterial({ color: 0xffffff }));
  edges.position.z = 0.01;
  group.add(edges);

  // glow behind
  const glowMat = new THREE.MeshBasicMaterial({ color: 0x99d7ff, transparent: true, opacity: 0.08, side: THREE.DoubleSide });
  const glow = new THREE.Mesh(new THREE.PlaneGeometry(WALL_WIDTH + 0.2, WALL_HEIGHT + 0.2), glowMat);
  glow.position.z = -0.05;
  group.add(glow);

  // TEXT PLANE: create canvas with the same aspect ratio as the plane so texture doesn't stretch
  const planeW = WALL_WIDTH * 0.9;
  const planeH = WALL_HEIGHT * 0.9;
  const PIXELS_PER_UNIT = 200; // density, –º–æ–∂–Ω–æ —É–º–µ–Ω—å—à–∏—Ç—å –µ—Å–ª–∏ —Ö–æ—á–µ—Ç—Å—è –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–µ–µ (–Ω–∞–ø—Ä–∏–º–µ—Ä 150)
  const canvasW = Math.max(128, Math.round(planeW * PIXELS_PER_UNIT));
  const canvasH = Math.max(64, Math.round(planeH * PIXELS_PER_UNIT));

  const { canvas, ctx } = makeTextCanvas(canvasW, canvasH);
  // initial clear
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = 'rgba(0,0,0,0.0)';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#ffffff';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  // placeholder; actual text will be rendered on spawn
  ctx.font = `bold ${Math.floor(canvasH * 0.5)}px sans-serif`;
  ctx.fillText('100', canvas.width / 2, canvas.height / 2);

  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;
  const textMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
  const textPlane = new THREE.Mesh(new THREE.PlaneGeometry(planeW, planeH), textMat);
  textPlane.position.z = 0.02;
  group.add(textPlane);

  // store references
  group.userData = {
    glassMesh: glass,
    textPlane: textPlane,
    canvas, ctx, tex,
    health: 0,
    maxHealth: 0,
    side: 0,
    z: 0,
    unbreakable: false,
    active: false
  };

  // don't add to scene now
  return group;
}

// init pool
for (let i = 0; i < WALL_POOL_SIZE; i++){
  const w = createWallMesh();
  wallPool.push(w);
}

// acquire / release for walls
function acquireWallMesh(){
  for (let i = 0; i < wallPool.length; i++){
    const w = wallPool[i];
    if (!w.userData.active){
      w.userData.active = true;
      w.visible = true;
      return w;
    }
  }
  // fallback ‚Äî create extra (rare)
  const nw = createWallMesh();
  nw.userData.active = true;
  return nw;
}
function releaseWallMesh(w){
  w.userData.active = false;
  w.visible = false;
  // keep canvas/texture in pool (do not dispose)
  scene.remove(w);
}

// helper: update wall health text (optimized: only redraw when value changes)
// unified wall text updater ‚Äî –Ω–µ —Ä–∏—Å—É–µ—Ç 0, –≤—Å–µ–≥–¥–∞ –æ–∫—Ä—É–≥–ª—è–µ—Ç, –º–∏–Ω–∏–º–∞–ª—å–Ω–æ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞–µ—Ç
function updateWallText(w){
  if (!w || !w.userData) return;
  const canvas = w.userData.canvas || (w.userData.labelMesh && w.userData.labelMesh.userData && w.userData.labelMesh.userData.canvas);
  const ctx = w.userData.ctx || (w.userData.labelMesh && w.userData.labelMesh.userData && w.userData.labelMesh.userData.ctx);
  const tex = w.userData.tex || (w.userData.labelMesh && w.userData.labelMesh.userData && w.userData.labelMesh.userData.tex);
  if (!canvas || !ctx) return;

  // round health and handle zero: don't draw 0 (caller handles removal)
  const rawHp = w.userData.health || 0;
  if (rawHp <= 0) return;
  const hp = Math.round(rawHp);

  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = 'rgba(0,0,0,0.22)';
  ctx.fillRect(0,0,canvas.width,canvas.height);

  // fit large text to canvas
  const txt = String(hp);
  let fontSize = Math.floor(canvas.height * 0.6);
  ctx.font = `bold ${fontSize}px sans-serif`;
  while ((ctx.measureText(txt).width > canvas.width * 0.92 || fontSize > canvas.height * 0.9) && fontSize > 12){
    fontSize = Math.floor(fontSize * 0.85);
    ctx.font = `bold ${fontSize}px sans-serif`;
  }

  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.lineWidth = Math.max(2, Math.floor(fontSize / 20));
  ctx.strokeStyle = 'rgba(0,0,0,0.7)';
  ctx.fillStyle = '#ffffff';
  ctx.strokeText(txt, canvas.width/2, canvas.height/2);
  ctx.fillText(txt, canvas.width/2, canvas.height/2);

  if (tex) tex.needsUpdate = true;
}

const runwayMat = new THREE.MeshLambertMaterial({ color: 0xffffff });
const edgeMat   = new THREE.MeshLambertMaterial({ color: 0xeeeeee });

/* –≥–µ–æ–º–µ—Ç—Ä–∏–∏ –æ—Å—Ç–∞—é—Ç—Å—è —Ç–µ–º–∏ –∂–µ */
const stripGeo = new THREE.PlaneGeometry(RUNWAY_WIDTH, RUNWAY_LENGTH);
const edgeGeo  = new THREE.BoxGeometry(0.1, EDGE_HEIGHT, RUNWAY_LENGTH); // —Ç–æ–Ω–∫–∏–µ –±–æ—Ä—Ç–∏–∫–∏

// –ø—É–ª —Å–µ–≥–º–µ–Ω—Ç–æ–≤
const runwaySegments = [];
function createSegment(z){
  // –ø–æ–ª–æ—Å–∞
  const strip = new THREE.Mesh(stripGeo, runwayMat);
  strip.rotation.x = -Math.PI / 2;
  strip.position.set(0, -0.5, z);
  scene.add(strip);

  // –ª–µ–≤—ã–π –±–æ—Ä—Ç–∏–∫
  const leftEdge = new THREE.Mesh(edgeGeo, edgeMat);
  leftEdge.position.set(-RUNWAY_WIDTH/2, -0.5 + EDGE_HEIGHT/2, z);
  scene.add(leftEdge);

  // –ø—Ä–∞–≤—ã–π –±–æ—Ä—Ç–∏–∫
  const rightEdge = new THREE.Mesh(edgeGeo, edgeMat);
  rightEdge.position.set( RUNWAY_WIDTH/2, -0.5 + EDGE_HEIGHT/2, z);
  scene.add(rightEdge);

  runwaySegments.push({ strip, leftEdge, rightEdge, centerZ: z });
}

// —Å–æ–∑–¥–∞—ë–º –ø–µ—Ä–≤—ã–µ –¥–≤–∞ —Å–µ–≥–º–µ–Ω—Ç–∞
createSegment(0);
createSegment(-RUNWAY_LENGTH);

// –≤ main-loop (–≤ –∫–æ–Ω—Ü–µ animate(), –ø–µ—Ä–µ–¥ renderer.render) –¥–æ–±–∞–≤—å—Ç–µ:
function updateRunway(){
  const ahead = nailGroup.position.z - 2 * RUNWAY_LENGTH; // —Ç–æ—á–∫–∞ ¬´–Ω–∞ 2 —Å–µ–≥–º–µ–Ω—Ç–∞¬ª –≤–ø–µ—Ä–µ–¥–∏ –∏–≥—Ä–æ–∫–∞
  const last  = runwaySegments[runwaySegments.length - 1];

  // –µ—Å–ª–∏ –ø–æ—Å–ª–µ–¥–Ω–∏–π —Å–µ–≥–º–µ–Ω—Ç –µ—â—ë –Ω–µ –Ω–∞—Å—Ç–æ–ª—å–∫–æ –¥–∞–ª–µ–∫–æ, –¥–æ–±–∞–≤–ª—è–µ–º –Ω–æ–≤—ã–π
  if (last.centerZ > ahead){
    createSegment(last.centerZ - RUNWAY_LENGTH);
  }

  // —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã, –∫–æ—Ç–æ—Ä—ã–µ —É–∂–µ –ø–æ–∑–∞–¥–∏ –∫–∞–º–µ—Ä—ã
  for (let i = runwaySegments.length - 1; i >= 0; i--){
    const seg = runwaySegments[i];
    if (seg.centerZ > nailGroup.position.z + 60){
      scene.remove(seg.strip);
      scene.remove(seg.leftEdge);
      scene.remove(seg.rightEdge);
      runwaySegments.splice(i, 1);
    }
  }
}

function spawnGate(side, z, data, widthOverride){
  if (finishZ !== null && z <= finishZ) return;
  // unified spawnGate: supports optional widthOverride (for walls -> gate)
  const gateGroup = new THREE.Group();
  gateGroup.userData = data || {};

  const isPositive = (data && data.mode === 'mul') ? data.val > 1 : (data && data.val > 0);

  // gate width (world units)
  const gw = (typeof widthOverride === 'number') ? widthOverride : gateWidth;

  // panel
  const panelMat = (isPositive ? gatePanelMatPos : gatePanelMatNeg) || new THREE.MeshBasicMaterial({
    color: isPositive ? 0x00ff00 : 0xff0000, transparent: true, opacity: 0.3, depthWrite: false
  });
  const panel = new THREE.Mesh(new THREE.PlaneGeometry(gw, 2), panelMat);
  panel.position.z = 0.01;
  gateGroup.add(panel);

  // frame
  const edges = new THREE.LineSegments(
    new THREE.EdgesGeometry(new THREE.PlaneGeometry(gw, 2)),
    new THREE.LineBasicMaterial({ color: 0xffffff })
  );
  edges.position.z = 0.02;
  gateGroup.add(edges);

  // TEXT: use cached CanvasTexture
  const tex = getGateTexture((data && data.label) ? data.label : '');
  let texAspect = 384 / 256;
  if (tex && tex.image && tex.image.width && tex.image.height) texAspect = tex.image.width / tex.image.height;

  // compute text plane size preserving texture aspect; max height 2
  const baseHeight = 1.6; // slightly smaller than panel to leave margins
  let textH = baseHeight;
  let textW = textH * texAspect;
  if (textW > gw * 0.95) { // if too wide, shrink height
    textW = gw * 0.95;
    textH = textW / texAspect;
  }

  const textMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
  const textPlane = new THREE.Mesh(new THREE.PlaneGeometry(textW, textH), textMat);
  textPlane.position.z = 0.03;
  textPlane.position.y = 0; // centered vertically
  gateGroup.add(textPlane);

  // glow (cheap)
  const glowMat = new THREE.MeshBasicMaterial({
    color: isPositive ? 0x00ff00 : 0xff0000, transparent: true, opacity: 0.18, side: THREE.DoubleSide
  });
  const glowPlane = new THREE.Mesh(new THREE.PlaneGeometry(gw + 0.2, Math.max(2.2, textH + 0.2)), glowMat);
  glowPlane.position.z = -0.05;
  gateGroup.add(glowPlane);

  // position: align edge to runway edge for side -1/+1, center for 0.
  let gateX = 0;
  if (side === 0) gateX = 0;
  else if (side < 0) gateX = - (RUNWAY_WIDTH / 2) + (gw / 2);
  else gateX = (RUNWAY_WIDTH / 2) - (gw / 2);

  gateGroup.position.set(gateX, 0, z);
  scene.add(gateGroup);
  gates.push(gateGroup);

  return gateGroup;
}

function spawnFinishGate(z){
  const group = new THREE.Group();

  const tex = makeCheckeredTexture();
  const mat = new THREE.MeshBasicMaterial({
    map: tex,
    transparent: true,
    opacity: 0.65,
    depthWrite: false
  });

  const glowMat = new THREE.MeshBasicMaterial({
    color: 0x88ffcc,
    transparent: true,
    opacity: 0.25,
    depthWrite: false
  });

  const width = RUNWAY_WIDTH + 1.2;
  const height = 3;

  // –ø–∞–Ω–µ–ª—å
  const panel = new THREE.Mesh(
    new THREE.PlaneGeometry(width, height),
    mat
  );
  panel.position.y = 1.2;
  group.add(panel);

  // —Å–≤–µ—á–µ–Ω–∏–µ
  const glow = new THREE.Mesh(
    new THREE.PlaneGeometry(width + 0.6, height + 0.6),
    glowMat
  );
  glow.position.y = 1.2;
  glow.position.z = -0.05;
  group.add(glow);

  // —Ä–∞–º–∫–∞
  const frame = new THREE.LineSegments(
    new THREE.EdgesGeometry(new THREE.PlaneGeometry(width, height)),
    new THREE.LineBasicMaterial({ color: 0xffffff })
  );
  frame.position.y = 1.2;
  frame.position.z = 0.01;
  group.add(frame);

  group.position.set(0, 0, z);
  group.userData.isFinish = true;

  scene.add(group);
  finishGate = group;
  finishZ = z;

  // === –ó–ê–ß–ò–°–¢–ö–ê: –£–¥–∞–ª—è–µ–º –≤—Å—ë, —á—Ç–æ —É–∂–µ —É—Å–ø–µ–ª–æ –ø–æ—è–≤–∏—Ç—å—Å—è –ó–ê —Ñ–∏–Ω–∏—à–µ–º ===
  // 1. –£–¥–∞–ª—è–µ–º –≤—Ä–∞–≥–æ–≤
  for(let i = enemies.length - 1; i >= 0; i--){
    if(enemies[i].position.z < z){
       if(enemies[i].userData.pooled) releaseEnemyMesh(enemies[i]);
       else scene.remove(enemies[i]);
       enemies.splice(i, 1);
    }
  }
  // 2. –£–¥–∞–ª—è–µ–º —Å—Ç–µ–Ω—ã
  for(let i = walls.length - 1; i >= 0; i--){
    if(walls[i].position.z < z){
       releaseWallMesh(walls[i]);
       walls.splice(i, 1);
    }
  }
  // 3. –£–¥–∞–ª—è–µ–º –æ–±—ã—á–Ω—ã–µ –≤–æ—Ä–æ—Ç–∞
  for(let i = gates.length - 1; i >= 0; i--){
    if(gates[i].position.z < z){
       scene.remove(gates[i]);
       gates.splice(i, 1);
    }
  }
}

function spawnEnemyGroup(baseSpawnZ) {
  if (finishZ !== null && baseSpawnZ <= finishZ) return;
  const freshIds = [];
  const bulletCount = nailLevels.reduce((a, b) => a + b, 0);
  const power = Math.min(1, (fireRate - 0.9) / 10 + (bulletCount) / 20 + (fireRange - 14) / 50);

  // —Å–≥–ª–∞–∂–µ–Ω–Ω–∞—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è: –æ—Ç min –¥–æ max –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç power^2
  const CROWD_MIN = 1;
  const CROWD_MAX = 55; // –ø–æ–¥–±–µ—Ä–∏: –Ω–∞–ø—Ä–∏–º–µ—Ä 24 ‚Äî –º–∞–∫—Å–∏–º—É–º –¥–æ–ø—É—Å—Ç–∏–º—ã—Ö –≤—Ä–∞–≥–æ–≤ –≤ –≤–æ–ª–Ω–µ
  const crowdSize = Math.max(CROWD_MIN, Math.round(CROWD_MIN + (CROWD_MAX - CROWD_MIN) * (power * power)));

  const side = Math.random() < 0.5 ? -1 : 1;
  const clusterX = side * (1 + Math.random() * 2);
  const clampedClusterX = THREE.MathUtils.clamp(clusterX, -2.5, 2.5);

  if (crowdSize > 5) {
    const labelMesh = acquireLabelMesh(crowdSize.toString(), baseSpawnZ);
    labelMesh.position.z = baseSpawnZ;
    enemyLabels.push({ ids: freshIds, mesh: labelMesh, initial: crowdSize });
  }

  for (let i = 0; i < crowdSize; i++) {
    let e = acquireEnemyMesh();
    if (!e) {
      e = new THREE.Mesh(enemyGeo, enemyMat);
      e.userData.pooled = false;
      scene.add(e);
    }
    // –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û: –°—Ç–∏—Ä–∞–µ–º –ø–∞–º—è—Ç—å –æ —Ç–æ–º, —á—Ç–æ —ç—Ç–æ –º–æ–≥ –±—ã—Ç—å –±–æ—Å—Å
    e.userData.isBigHeart = false;
    
    e.position.set(
      clampedClusterX + (Math.random() - 0.5) * 1.5,
      0.3,
      baseSpawnZ + (Math.random() - 0.5) * 4
    );
    e.uuid = THREE.MathUtils.generateUUID();
    enemies.push(e);
    if (crowdSize > 5) freshIds.push(e.uuid);
    e.lookAt(nailGroup.position.x, 0.3, nailGroup.position.z);
  }
}

function spawnBigHeart(zPos) {
  if (finishZ !== null && zPos <= finishZ) return;
  const e = acquireEnemyMesh();
  if (!e) return;

  const curDamage = Math.max(0, Math.round(calcMaxDamageForOneTarget({ nailLevels: nailLevels.slice(), rate: fireRate, range: fireRange })));
  const bestDamage = Math.max(1, Math.round(calcMaxDamageForOneTarget(maxParams)));
  const mean = (curDamage + bestDamage) / 2;
  const health = Math.max(10, Math.round(mean * (0.3 + Math.random() * 0.7)));

  e.scale.set(1.6, 1.6, 1.6); // –£–º–µ–Ω—å—à–∏–ª–∏ —Å 2.0 –¥–æ 1.6
  e.position.set((Math.random() - 0.5) * 3, 1.2, zPos);
  
  e.userData.isBigHeart = true;
  e.userData.hp = health;
  e.userData.initialHp = health;
  e.userData.speedMult = 1.3; 
  
  e.uuid = THREE.MathUtils.generateUUID();
  enemies.push(e);

  // –°–æ–∑–¥–∞–µ–º —Ç–∞–±–ª–∏—á–∫—É –∏ —Å—Ä–∞–∑—É —Å—Ç–∞–≤–∏–º –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π 'initial', —á—Ç–æ–±—ã –ª–æ–≥–∏–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –Ω–µ –ª–æ–º–∞–ª–∞—Å—å
  const lbl = acquireLabelMesh(health.toString(), zPos);
  e.userData.labelMesh = lbl;
  enemyLabels.push({ ids: [e.uuid], mesh: lbl, initial: health, isBigHeart: true });
}

function spawnWallAt(sideWall, zPos) {
  if (finishZ !== null && zPos <= finishZ) return;
  const w = acquireWallMesh();
  let xCenter = 0;

  if (sideWall === 0) {
    xCenter = 0;
  } else if (sideWall < 0) {
    xCenter = -(RUNWAY_WIDTH / 2) + (WALL_WIDTH / 2);
  } else {
    xCenter = (RUNWAY_WIDTH / 2) - (WALL_WIDTH / 2);
  }

  w.position.set(xCenter, 0, zPos);
  w.userData.side = sideWall;
  w.userData.z = zPos;

  // --- —Ä–∞—Å—á—ë—Ç –∑–¥–æ—Ä–æ–≤—å—è ---
  const curDamage = Math.max(0, Math.round(
    calcMaxDamageForOneTarget({ nailLevels: nailLevels.slice(), rate: fireRate, range: fireRange })
  ));
  const bestDamage = Math.max(1, Math.round(calcMaxDamageForOneTarget(maxParams)));
  const mean = (curDamage + bestDamage) / 2;

  let health;
  let unbreak = false;
  if (Math.random() < 0.25 && !walls.some(wall => wall.userData.unbreakable && Math.abs(wall.position.z - zPos) < 10)) {
    // –æ–¥–Ω–∞ –Ω–µ–ø—Ä–æ–±–∏–≤–∞–µ–º–∞—è —Ä—è–¥–æ–º
    const mul = 2 + Math.random() * (3);
    health = Math.max(5 + Math.random() * 4, mean * mul);
    unbreak = true;
  } else {
    const mul = 0.4 + Math.random() * (0.5);
    health = Math.max(5 + Math.random() * 4, mean * mul);
  }

  w.userData.health = health;
  w.userData.maxHealth = health;
  w.userData.unbreakable = !!unbreak;

  updateWallText(w);
  scene.add(w);
  walls.push(w);

  return w;
}


function spawnWave() {
  const gap = (typeof randSpawnGap === 'function') ? randSpawnGap() : (MIN_SPAWN_GAP * (1 + Math.random() * 0.5));
  const baseSpawnZ = lastSpawnZ - gap;
  if (finishZ !== null && baseSpawnZ <= finishZ) return;
  if (baseSpawnZ > nailGroup.position.z + 20) return;

  let waveType;
  const roll = Math.random();

const elapsedSec = (performance.now() - songStartTime) / 1000;
  const isSecondQuarter = elapsedSec > SONG_DURATION / 4;
  //const isSecondThird = 1

  if (consecutiveEnemyWaves >= MAX_CONSECUTIVE_ENEMY_WAVES) {
    if (roll < 0.5) waveType = "gate";
    else waveType = "wall";
  } else {
    // –ï—Å–ª–∏ —Ö–æ—Ç—è –±—ã –≤—Ç–æ—Ä–∞—è —Ç—Ä–µ—Ç—å –∏–≥—Ä—ã, –¥–∞–µ–º 20% —à–∞–Ω—Å –Ω–∞ –ë–æ–ª—å—à–æ–µ –°–µ—Ä–¥—Ü–µ –≤–º–µ—Å—Ç–æ –æ–±—ã—á–Ω—ã—Ö –≤—Ä–∞–≥–æ–≤
    if (roll < 0.2 && isSecondQuarter) {
       waveType = "big_heart";
    } else if (roll < 0.5) {
       waveType = "enemy";
    } else if (roll < 0.8) {
       waveType = "gate";
    } else {
       waveType = "wall";
    }
  }

  // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∞ –ø–æ–¥—Ä—è–¥ —Å—Ç–µ–Ω—ã
  if (waveType === "wall") {
    consecutiveEnemyWaves = 0;
    consecutiveGateWaves = 0;
    consecutiveWallWaves++;
    if (consecutiveWallWaves > 1) {
      const chance = (consecutiveWallWaves === 2 ? 0.3 : 0.1);
      if (Math.random() > chance) waveType = "enemy"; // –ø–µ—Ä–µ–±—Ä–æ—Å –≤ –≤—Ä–∞–≥–æ–≤
    }
  }

  // –û–≥—Ä–∞–Ω–∏—á–µ–Ω–∏—è –Ω–∞ –ø–æ–¥—Ä—è–¥ –≥–µ–π—Ç—ã
  if (waveType === "gate") {
    consecutiveEnemyWaves = 0;
    consecutiveWallWaves = 0;
    consecutiveGateWaves++;
    if (consecutiveGateWaves > 1) {
      const chance = (consecutiveGateWaves === 2 ? 0.3 : 0.1);
      if (Math.random() > chance) waveType = "enemy"; // –ø–µ—Ä–µ–±—Ä–æ—Å –≤ –≤—Ä–∞–≥–æ–≤
    }
  }

  // ---- –°–ü–ê–í–ù –í–†–ê–ì–û–í ----
  if (waveType === "enemy") {
    spawnEnemyGroup(baseSpawnZ);
    consecutiveEnemyWaves++;
    consecutiveGateWaves = 0;
    consecutiveWallWaves = 0;
  }

  else if (waveType === "big_heart") {
    spawnBigHeart(baseSpawnZ);
    consecutiveEnemyWaves++; 
    consecutiveGateWaves = 0;
    consecutiveWallWaves = 0;
  }

  // ---- –°–ü–ê–í–ù –ì–ï–ô–¢–û–í ----
  else if (waveType === "gate") {
    let sides = Math.random() < 0.6 ? [Math.random() < 0.5 ? -1 : 1] : [-1, 1];
    const configKey = "gate-" + sides.join(",");
    if (configKey === lastGateConfig) {
      gateConfigRepeat++;
      if (gateConfigRepeat >= 2) {
        // –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –º–µ–Ω—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        sides = (sides.length === 1) ? [-1, 1] : [Math.random() < 0.5 ? -1 : 1];
        gateConfigRepeat = 0;
      }
    } else {
      lastGateConfig = configKey;
      gateConfigRepeat = 0;
    }

    if (sides.length === 1) {
      const g = pickGate();
      // –ï—Å–ª–∏ –≥–µ–π—Ç –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π, —É—á–∏—Ç—ã–≤–∞–µ–º –µ–≥–æ –≤ MaxDamage
      if (isGatePositiveForBase(maxParams, g)) registerGateOpportunity(g, baseSpawnZ);
      spawnGate(sides[0], baseSpawnZ, g);
    } else {
      let g1 = pickGate();
      let g2;
      do { g2 = pickGate(); } while (g2.label === g1.label);
      
      // –ò–∑ –ø–∞—Ä—ã –≤–æ—Ä–æ—Ç "–∏–¥–µ–∞–ª—å–Ω—ã–π –∏–≥—Ä–æ–∫" –≤—Å–µ–≥–¥–∞ –≤—ã–±–µ—Ä–µ—Ç –ª—É—á—à–∏–µ
      const bestG = chooseBestGateFromPair(g1, g2).chosen;
      if (isGatePositiveForBase(maxParams, bestG)) registerGateOpportunity(bestG, baseSpawnZ);
      
      spawnGate(sides[0], baseSpawnZ, g1);
      spawnGate(sides[1], baseSpawnZ, g2);
    }

    // —à–∞–Ω—Å –≤—Ä–∞–≥–æ–≤ –≤–º–µ—Å—Ç–µ
    if (Math.random() < 0.2) {
      spawnEnemyGroup(baseSpawnZ - 4);
    }
  }

  // ---- –°–ü–ê–í–ù –°–¢–ï–ù ----
  else if (waveType === "wall") {
    let sidesWalls;
    if (Math.random() < 0.6) {
      sidesWalls = [ [-1, 0, 1][Math.floor(Math.random() * 3)] ];
    } else {
      const pairs = [[-1, 0], [0, 1], [-1, 1]];
      sidesWalls = pairs[Math.floor(Math.random() * pairs.length)];
    }
    const configKey = "wall-" + sidesWalls.join(",");
    if (configKey === lastWallConfig) {
      wallConfigRepeat++;
      if (wallConfigRepeat >= 2) {
        // –ø—Ä–∏–Ω—É–¥–∏—Ç–µ–ª—å–Ω–æ –º–µ–Ω—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
        sidesWalls = [ [-1,0,1][Math.floor(Math.random() * 3)] ];
        wallConfigRepeat = 0;
      }
    } else {
      lastWallConfig = configKey;
      wallConfigRepeat = 0;
    }

    for (let s = 0; s < sidesWalls.length; s++) {
      spawnWallAt(sidesWalls[s], baseSpawnZ);
    }

    // —à–∞–Ω—Å –≤—Ä–∞–≥–æ–≤ –≤–º–µ—Å—Ç–µ
    if (Math.random() < 0.2) {
      spawnEnemyGroup(baseSpawnZ - 4);
    }
  }
  lastSpawnZ = baseSpawnZ;
}

/* ---------- controls ---------- */
let mouseX = 0;
// –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —É—Å—Ç—Ä–æ–π—Å—Ç–≤–æ –º–æ–±–∏–ª—å–Ω—ã–º
const isMobile = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
// –î–ª—è –º–æ–±–∏–ª–æ–∫ –æ—Å—Ç–∞–≤–ª—è–µ–º 1.3, –¥–ª—è –ü–ö —Å—Ç–∞–≤–∏–º 2.2, —á—Ç–æ–±—ã –Ω–µ —Ç—è–Ω—É—Ç—å—Å—è –º—ã—à–∫–æ–π –∫ –∫—Ä–∞—è–º
const INPUT_SCALE = isMobile ? 1.7 : 2.2;

window.addEventListener('mousemove', e => {
  const norm = (e.clientX / innerWidth - 0.5); // –æ—Ç -0.5 –¥–æ +0.5
  mouseX = norm * (RUNWAY_WIDTH * INPUT_SCALE);
});

window.addEventListener('touchmove', e => {
  const touch = e.touches[0];
  const norm = (touch.clientX / innerWidth - 0.5);
  mouseX = norm * (RUNWAY_WIDTH * INPUT_SCALE);
}, { passive: true });

/* ---------- camera ---------- */
camera.position.set(0,5,4);                       // <-- –±–ª–∏–∂–µ
camera.lookAt(0,-1,nailGroup.position.z - 3);        // <-- –Ω–∏–∂–µ –∏ —Ç–æ—á–Ω–µ–µ

// —Å–∫–æ—Ä–æ—Å—Ç—å –∏–≥—Ä–æ–∫–∞ –≤ —é–Ω–∏—Ç–∞—Ö/—Å–µ–∫
let playerSpeed = 6;

// document.addEventListener('click', () => {
//   if (!started){ document.getElementById('bgm').play(); started = true; }
// });

/* ---------- shooting ---------- */
function shoot(time){
  if (!started || gameOver) return;
  if (time - lastShot < 1000 / fireRate) return;
  lastShot = time;

  nailGroup.children.forEach((nail, i) => {
    const level = nailLevels[i];
    const geo = level >= 3 ? bigBulletGeo : bulletGeo;
    const mat = level >= 3 ? bigBulletMat : bulletMat;

    const isBig = level >= 3;
    let bMesh = acquireBulletMesh(isBig);

    // fallback ‚Äî –µ—Å–ª–∏ –ø—É–ª –∏—Å—á–µ—Ä–ø–∞–Ω, —Å–æ–∑–¥–∞—ë–º –≤—Ä–µ–º–µ–Ω–Ω–æ (—Ä–µ–¥–∫–∏–π —Å–ª—É—á–∞–π)
    if (!bMesh){
      bMesh = new THREE.Mesh(geo, mat);
      bMesh.userData.pooled = false;
      scene.add(bMesh);
    } else {
      bMesh.userData.pooled = true;
    }

        const nailPos = nail.position;

    // –±–µ–∑–æ–ø–∞—Å–Ω—ã–π —Å–ø–∞–≤–Ω –ø—É–ª–∏: –≤—ã—á–∏—Å–ª—è–µ–º –º–∏—Ä–æ–≤—É—é X –∏ clamp'–∏–º –µ—ë –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö –¥–æ—Ä–æ–∂–∫–∏,
    // —á—Ç–æ–±—ã –ø—É–ª—è –Ω–µ –ø–æ—è–≤–ª—è–ª–∞—Å—å –∑–∞ –ø—Ä–µ–¥–µ–ª–∞–º–∏ runway –∏ –Ω–µ –æ–±—Ö–æ–¥–∏–ª–∞ —Å—Ç–µ–Ω–∫–∏.
    const spawnMargin = 0.05; // –Ω–µ–±–æ–ª—å—à–∞—è —Å—Ç—Ä–∞—Ö–æ–≤–∫–∞ –æ—Ç ¬´—Ä–æ–≤–Ω–æ –Ω–∞ –∫—Ä–∞—é¬ª
    const halfRoadSpawn = (RUNWAY_WIDTH / 2) - spawnMargin;
    // –º–∏—Ä–æ–≤–∞—è –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞, –æ—Ç –∫–æ—Ç–æ—Ä–æ–π –±—É–¥–µ–º –æ—Ç—Ç–∞–ª–∫–∏–≤–∞—Ç—å—Å—è
    let spawnX = nailGroup.position.x + nailPos.x;
    spawnX = THREE.MathUtils.clamp(spawnX, -halfRoadSpawn, halfRoadSpawn);

    bMesh.position.set(
      spawnX,
      0,
      nailGroup.position.z - 0.5
    );
    bMesh.userData.pierce = level;

    bullets.push({mesh: bMesh, vx:0, vz:-BULLET_SPEED, pierce: level});
    
    // –ó–≤—É–∫ –≤—ã—Å—Ç—Ä–µ–ª–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è –ø–µ—Ä–≤–æ–≥–æ –≥–≤–æ–∑–¥—è –≤ –∑–∞–ª–ø–µ, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ –∫–∞—à–∏)
    if (i === 0) playSound('shoot', true,); // true = —Å –≤–∞—Ä–∏–∞—Ü–∏–µ–π –ø–∏—Ç—á–∞
  });
}


// –ó–∞–º–µ–Ω–∏—Ç—å —Ç–µ–∫—É—â—É—é —Ñ—É–Ω–∫—Ü–∏—é showMsg –Ω–∞ —ç—Ç—É
function showMsg(text){
  const hearts = Number(heartCount || 0);
  const walls  = Number(wallCount || 0);
  const total  = computeScore();
  const el = document.getElementById('msgText');
  if (el) {
    // –¢–æ—á–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç, –∫–æ—Ç–æ—Ä—ã–π –≤—ã –ø—Ä–æ—Å–∏–ª–∏:
    el.innerText = `${text}\n\n–í—ã —Ä–∞–∑–±–∏–ª–∏ ${hearts} —Å–µ—Ä–¥–µ—Ü –∏ ${walls} –≤–∏—Ç—Ä–∏–Ω! –í–∞—à —Å—á—ë—Ç: ${total}`;
  }
  const msg = document.getElementById('msg');
  if (msg) msg.style.display = 'block';
}




/* ---------- enemy AI ---------- */
const DETECT_DISTANCE = 20;   // –Ω–∞ –∫–∞–∫–æ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ –≤—Ä–∞–≥ –∑–∞–º–µ—á–∞–µ—Ç –∏–≥—Ä–æ–∫–∞
// –±–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞–≥–∞ (—é–Ω–∏—Ç–æ–≤/—Å–µ–∫)
const ENEMY_SPEED = 4;
const difficultyFactor = 0.5;   // <-- –∫—Ä—É—Ç–∏—Ç–µ —ç—Ç–∏–º –¥–ª—è —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ (0.5‚Äì2.0)

function updateEnemiesAI(dt){
  enemies.forEach(e=>{
    const dist = e.position.distanceTo(nailGroup.position);
    if (dist < DETECT_DISTANCE){
      // –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫ –∏–≥—Ä–æ–∫—É
      const dir = new THREE.Vector3().subVectors(
      new THREE.Vector3(nailGroup.position.x, 0, nailGroup.position.z),
      e.position
    ).normalize();
      dir.y = 0; // –Ω–µ –ª–µ—Ç–∏–º –≤–≤–µ—Ä—Ö
      dir.z *= 0.2; // –Ω–µ –ª–µ—Ç–∏–º –≤–ø–µ—Ä—ë–¥
      // —É—Å–∫–æ—Ä–µ–Ω–∏–µ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ difficultyFactor
      const speed = ENEMY_SPEED * difficultyFactor * (e.userData.speedMult || 1);
      e.position.addScaledVector(dir, speed * dt);
    }
  });
}

function fadeOutGate(gateGroup){
  gateGroup.userData.fade = { start: performance.now(), dur: 300 };
}


/* ---------- main loop ---------- */
function animate(time){
  requestAnimationFrame(animate);
  // –ù–µ –æ–±–Ω–æ–≤–ª—è–µ–º –∏–≥—Ä—É –≤–æ –≤—Ä–µ–º—è –ø–∞—É–∑—ã, –Ω–æ –ø—Ä–æ–¥–æ–ª–∂–∞–µ–º —Ä–µ–Ω–¥–µ—Ä–∏—Ç—å
  if (gamePaused) {
    renderer.render(scene, camera);
    return;
  }

  // —Å—á–∏—Ç–∞–µ–º dt –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (–∫—ç–ø–∏–º, —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —Å–∫–∞—á–∫–æ–≤)
  if (!prevTime) prevTime = time;
  const dt = Math.min(0.05, (time - prevTime) / 1000);
  prevTime = time;

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—ã–ª–µ—Ç–∞—é—â–∏—Ö –æ—á–∫–æ–≤
  for (let i = activeFloatTexts.length - 1; i >= 0; i--) {
    const t = activeFloatTexts[i];
    const age = (time - t.startTime) / 1000;
    if (age > 1.2) {
      t.sprite.visible = false;
      activeFloatTexts.splice(i, 1);
      continue;
    }
    t.sprite.position.y = t.startY + age * 1.5; // –°–∫–æ—Ä–æ—Å—Ç—å –≤—Å–ø–ª—ã—Ç–∏—è
    t.sprite.material.opacity = 1 - age; // –ü–ª–∞–≤–Ω–æ–µ –∏—Å—á–µ–∑–Ω–æ–≤–µ–Ω–∏–µ
  }

  // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —á–∞—Å—Ç–∏—Ü –≤–∑—Ä—ã–≤–∞
  for (let p of particlePool) {
    if (p.mesh.visible) {
      p.life -= dt * 1.5;
      if (p.life <= 0) {
        p.mesh.visible = false;
      } else {
        p.mesh.position.addScaledVector(p.vel, dt);
        p.vel.y -= 15 * dt; // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
        p.mesh.rotation.x += p.rot.x;
        p.mesh.rotation.y += p.rot.y;
        p.mesh.material.opacity = p.life;
        // –î–æ–±–∞–≤–∏–º –ª–µ–≥–∫–æ–µ –≤—Ä–∞—â–µ–Ω–∏–µ –ø–æ –æ—Å–∏ Z, —á—Ç–æ–±—ã –æ—Å–∫–æ–ª–∫–∏ –ø–æ–±–ª–µ—Å–∫–∏–≤–∞–ª–∏
        p.mesh.rotation.z += 0.1;
      }
    }
  }

  if (!started || gameOver) return;

  // ---------- FINISH LOGIC ----------
const elapsed = (time - songStartTime) / 1000;
const timeLeft = SONG_DURATION - elapsed;

if (!finishSpawned && timeLeft <= FINISH_PREP_TIME){
  // –†–∞—Å—Å—á–∏—Ç—ã–≤–∞–µ–º —Ç–æ—á–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ, –∫–æ—Ç–æ—Ä–æ–µ –∏–≥—Ä–æ–∫ –ø—Ä–æ–µ–¥–µ—Ç –¥–æ –∫–æ–Ω—Ü–∞ –ø–µ—Å–Ω–∏
  const distanceToFinish = timeLeft * playerSpeed;
  spawnFinishGate(nailGroup.position.z - distanceToFinish);
  finishSpawned = true;
}

if (finishGate && !finishPassed){
  if (nailGroup.position.z <= finishGate.position.z){
    finishPassed = true;
    gameOver = true;
    enemies.length = 0;
    gates.length = 0;
    showLeaderboardSubmit(computeScore(), '–§–∏–Ω–∏—à!');
    return;
  }
}

if (finishGate){
  const glow = finishGate.children[1];
  glow.material.opacity = 0.2 + Math.sin(time * 0.004) * 0.1;
}


  // –æ—á–∏—Å—Ç–∏—Ç—å —Å—Ç–∞—Ä—ã—Ö –≤—Ä–∞–≥–æ–≤ –±–µ–∑ uuid (–∑–∞—â–∏—Ç–∞ –æ—Ç —Å—Ç–∞—Ä—ã—Ö —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–π/–∫—ç—à–∞)
  enemies = enemies.filter(e => e.uuid);

  /*  ‚úî  –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 1: –≤—Å–µ–≥–¥–∞ –≤—ã–∑—ã–≤–∞–µ–º shoot  */
  shoot(time);

  /* player movement (dt-based) */
  nailGroup.position.x += (mouseX - nailGroup.position.x) * 5 * dt; // 5 ‚Äî ¬´–∏–Ω–µ—Ä—Ü–∏—è¬ª –±–æ–∫–æ–≤–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
    // clamp –ø–æ–∑–∏—Ü–∏–∏ –≥—Ä—É–ø–ø—ã –≥–≤–æ–∑–¥–µ–π –ø–æ —Ä–µ–∞–ª—å–Ω–æ–π —à–∏—Ä–∏–Ω–µ –¥–æ—Ä–æ–∂–∫–∏ (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏)
  // margin ‚Äî –Ω–µ–±–æ–ª—å—à–æ–π –æ—Ç—Å—Ç—É–ø, —á—Ç–æ–±—ã –≥–≤–æ–∑–¥–∏ –Ω–µ —É–ø–∏—Ä–∞–ª–∏—Å—å –≤ –∫—Ä–∞–π –≤–∏–∑—É–∞–ª—å–Ω–æ
  const margin = 0.15;
  const halfRoadClamp = (RUNWAY_WIDTH / 2) - margin;
  nailGroup.position.x = THREE.MathUtils.clamp(nailGroup.position.x, -halfRoadClamp, halfRoadClamp);

  nailGroup.position.z -= playerSpeed * dt;

  /* —Å–∂–∞—Ç–∏–µ —É –∫—Ä–∞—ë–≤ + –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ */
  const halfRoad = RUNWAY_WIDTH / 2 - 0.15; // –±–æ–ª–µ–µ —è–≤–Ω–∞—è —Å–≤—è–∑—å —Å RUNWAY_WIDTH
  // –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π gap (–Ω–µ –æ–ø—É—Å–∫–∞–µ–º —Å–ª–∏—à–∫–æ–º –Ω–∏–∑–∫–æ)
  const minGap = 0.12;
  // –∂–µ–ª–∞–µ–º–∞—è —à–∏—Ä–∏–Ω–∞ –≥—Ä—É–ø–ø—ã –≥–≤–æ–∑–¥–µ–π: —á—É—Ç—å –º–µ–Ω—å—à–µ 1/3 –¥–æ—Ä–æ–∂–∫–∏
  const desiredGroupWidth = (RUNWAY_WIDTH / 3) * 0.9; // 0.96 = ¬´—á—É—Ç—å –º–µ–Ω—å—à–µ¬ª, –ø–æ–¥–±–µ—Ä–∏—Ç–µ 0.95..0.98 –ø–æ –≤–∫—É—Å—É
  // –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π —à–∞–≥ –º–µ–∂–¥—É –≥–≤–æ–∑–¥—è–º–∏ –ø—Ä–∏ –Ω–æ—Ä–º–∞–ª—å–Ω–æ–º –ø–æ–ª–æ–∂–µ–Ω–∏–∏ (—Ü–µ–Ω—Ç—Ä)
  const maxGap = desiredGroupWidth / Math.max(1, (MAX_NAILS - 1));

  const fadeZone = halfRoad * 0.3;

  const totalLen   = (nailCount - 1) * maxGap;
  let gap          = totalLen > halfRoad * 2
    ? Math.max(minGap, (halfRoad * 2) / Math.max(1, nailCount - 1))
    : Math.max(minGap, maxGap - Math.max(0, 1 - (halfRoad - Math.abs(nailGroup.position.x)) / fadeZone) * (maxGap - minGap));

  // –ø–æ–∑–∏—Ü–∏–∏ –≥–≤–æ–∑–¥–µ–π
  nailGroup.children.forEach((nail, i) => {
    const pos = (i - (nailCount - 1) / 2) * gap;
    nail.position.x = THREE.MathUtils.clamp(pos, -halfRoad, halfRoad);
  });

  /* –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–π –Ω–∞–∫–ª–æ–Ω */
  const tiltBase = (mouseX - nailGroup.position.x) * 0.15;
  nailGroup.children.forEach(nail => {
    const edgeDist = halfRoad - Math.abs(nail.position.x + nailGroup.position.x);
    const factor   = Math.max(0, Math.min(1, edgeDist / halfRoad));
    nail.rotation.z = THREE.MathUtils.clamp(tiltBase * factor, -0.4, 0.4);
  });

  updateEnemiesAI(dt);
  // ‚ö° 4. Clean stale labels
  // enemyLabels = enemyLabels.filter(l => enemies.some(e => l.ids.includes(e.uuid)));

/* ---------- —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π label –Ω–∞–¥ –≥—Ä—É–ø–ø–æ–π ---------- */
for (let k = enemyLabels.length - 1; k >= 0; k--) {
  const { ids, mesh, initial } = enemyLabels[k];

  // ‚ö° –ø—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ö–æ—Ç—å –æ–¥–∏–Ω –∂–∏–≤–æ–π –∏–∑ —ç—Ç–æ–π –≤–æ–ª–Ω—ã
  const alive = enemies.filter(e =>
    ids.includes(e.uuid) && e.position.z < nailGroup.position.z + 10
  );

  if (alive.length === 0) {
    // –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –º–µ—Ç–∫—É –≤ –ø—É–ª (–µ—Å–ª–∏ –æ–Ω–∞ –∏–∑ –ø—É–ª–∞)
    if (mesh.userData && mesh.userData.tex) {
      releaseLabelMesh(mesh);
    } else {
      // –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π ‚Äî –µ—Å–ª–∏ –±—ã–ª–∞ —Å–æ–∑–¥–∞–Ω–∞ –∫–∞–∫ fallback
      scene.remove(mesh);
      if (mesh.userData && mesh.userData.tex) mesh.userData.tex.dispose?.();
      if (mesh.material && mesh.material.map) mesh.material.map.dispose?.();
      mesh.material?.dispose?.();
      mesh.geometry?.dispose?.();
    }
    enemyLabels.splice(k, 1);
    continue;
  }


  const center = new THREE.Vector3();
  alive.forEach(e => center.add(e.position));
  center.divideScalar(alive.length);
  center.y += 1.2;
  mesh.position.lerp(center, 0.1);

  // console.log(
  // `label #${k} ids.length=${ids.length} alive=${alive.length}`,
  // alive.map(e => e.uuid.slice(-4))
// );

  // –û–ø—Ä–µ–¥–µ–ª—è–µ–º, –∫–∞–∫–æ–µ —á–∏—Å–ª–æ –º—ã –¥–æ–ª–∂–Ω—ã –≤–∏–¥–µ—Ç—å —Å–µ–π—á–∞—Å
  const currentVal = enemyLabels[k].isBigHeart ? Math.round(alive[0].userData.hp) : alive.length;

  // –ï—Å–ª–∏ —Ç–µ–∫—É—â–µ–µ —á–∏—Å–ª–æ –æ—Ç–ª–∏—á–∞–µ—Ç—Å—è –æ—Ç —Ç–æ–≥–æ, —á—Ç–æ –º—ã –∑–∞–ø–∏—Å–∞–ª–∏ –≤ 'initial', –æ–±–Ω–æ–≤–ª—è–µ–º –∫–∞—Ä—Ç–∏–Ω–∫—É
  if (currentVal !== initial) {
    const lblCanvas = mesh.userData.canvas;
    const lblCtx = mesh.userData.ctx;
    if (lblCtx && lblCanvas) {
      lblCtx.clearRect(0, 0, lblCanvas.width, lblCanvas.height);
      lblCtx.fillStyle = '#000a';
      lblCtx.fillRect(0, 0, lblCanvas.width, lblCanvas.height);
      lblCtx.fillStyle = '#fff';
      lblCtx.font = 'bold 48px sans-serif';
      lblCtx.textAlign = 'center';
      lblCtx.textBaseline = 'middle';
      
      lblCtx.fillText(currentVal.toString(), lblCanvas.width / 2, lblCanvas.height / 2);
      
      if (mesh.userData.tex) mesh.userData.tex.needsUpdate = true;
      else if (mesh.material && mesh.material.map) mesh.material.map.needsUpdate = true;
      
      // –ó–∞–ø–æ–º–∏–Ω–∞–µ–º –Ω–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ, —á—Ç–æ–±—ã –Ω–µ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤—ã–≤–∞—Ç—å –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä –±–µ–∑ –Ω—É–∂–¥—ã
      enemyLabels[k].initial = currentVal;
    }
  }

}

  /* continuous spawning */
  if (nailGroup.position.z - 80 < lastSpawnZ){
    spawnWave();
  }

  /* bullets (dt-based) */
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.mesh.position.x += b.vx * dt;
    b.mesh.position.z += b.vz * dt;
    if (b.mesh.position.z < nailGroup.position.z - fireRange){
      if (b.mesh.userData.pooled) {
        releaseBulletMesh(b.mesh);
      } else {
        scene.remove(b.mesh);
      }
      bullets.splice(i,1);
    }
  }

 /* bullet ‚Äî collision: walls first, then enemies
   ‚Äî now: accumulate wall damage per-frame to avoid ordering issues
   ‚Äî only count front-facing bullet hits (bullet must be before wall on Z)
*/
if (bullets.length) {
  // ensure pendingDamage exists for all active walls
  for (let wi = 0; wi < walls.length; wi++){
    const w = walls[wi];
    if (!w || !w.userData) continue;
    w.userData.pendingDamage = 0;
  }

  // iterate bullets; when a bullet hits a wall we accumulate damage and remove bullet immediately
  for (let i = bullets.length - 1; i >= 0; i--){
    const bData = bullets[i];
    const bMesh = bData.mesh;
    let bulletConsumed = false;

    // 1) walls collision (axis-aligned cheap check) ‚Äî front-only
    for (let wi = walls.length - 1; wi >= 0; wi--){
      const w = walls[wi];
      if (!w || !w.userData || !w.userData.active) continue;

      const dx = Math.abs(bMesh.position.x - w.position.x);
      // SIGNED dz: positive => bullet is on the player's side (in front of wall)
      const dz = bMesh.position.z - w.position.z;

      // require bullet to be on front side and close in Z; tolerance ~0.6 kept
      if (dx <= (WALL_WIDTH / 2) && dz >= -0.6 && dz <= 0.6){
        // accumulate *all* current pierce as damage (consistent with previous behavior)
        const damage = bData.pierce || 0;
        w.userData.pendingDamage = (w.userData.pendingDamage || 0) + damage;

        // consume bullet
        if (bMesh.userData && bMesh.userData.pooled) releaseBulletMesh(bMesh);
        else scene.remove(bMesh);
        bullets.splice(i,1);
        bulletConsumed = true;
        break;
      }
    } // end walls loop

    if (bulletConsumed) continue;

    // 2) enemy collision (–ø–æ–ª–Ω–∞—è –∏ —Å—Ç–∞–±–∏–ª—å–Ω–∞—è –≤–µ—Ä—Å–∏—è)
    for (let j = enemies.length - 1; j >= 0; j--){
      const e = enemies[j];
      if (!e || !e.userData.active) continue;

      // –°—á–∏—Ç–∞–µ–º –¥–∏—Å—Ç–∞–Ω—Ü–∏—é –ø–æ –ø–ª–æ—Å–∫–æ—Å—Ç–∏ –∑–µ–º–ª–∏
      const dx = bMesh.position.x - e.position.x;
      const dz = bMesh.position.z - e.position.z;
      const distXZ = Math.sqrt(dx*dx + dz*dz);
      
      const hitRadius = e.userData.isBigHeart ? 0.9 : 0.5;

      if (distXZ < hitRadius) {
        if (e.userData.isBigHeart) {
          // –õ–û–ì–ò–ö–ê –ë–û–°–°–ê:
          // –ë–æ—Å—Å –ø–æ–ª—É—á–∞–µ—Ç —É—Ä–æ–Ω —Ä–∞–≤–Ω—ã–π —É—Ä–æ–≤–Ω—é –ø—É–ª–∏
          e.userData.hp -= bData.pierce;
          
          // –ü—É–ª—è –≤—Å–µ–≥–¥–∞ –ª–æ–º–∞–µ—Ç—Å—è –æ –ë–æ—Å—Å–∞
          if (bMesh.userData.pooled) releaseBulletMesh(bMesh);
          else scene.remove(bMesh);
          bullets.splice(i, 1);
          bulletConsumed = true;

          // –ï—Å–ª–∏ –∂–∏–∑–Ω–∏ –ë–æ—Å—Å–∞ –∫–æ–Ω—á–∏–ª–∏—Å—å ‚Äî —É–¥–∞–ª—è–µ–º –µ–≥–æ
          if (e.userData.hp <= 0) {
            heartCount += Math.round(e.userData.initialHp || 10);
            spawnScoreText(e.position.x, 0.1, e.position.z, "+" + Math.round(e.userData.initialHp));
            playSound('bossKill'); // –ó–≤—É–∫ —Å–º–µ—Ä—Ç–∏ –±–æ—Å—Å–∞
            // spawnBurst(e.position.x, 1, e.position.z, 0xff0040, 20); // –ú–Ω–æ–≥–æ –æ—à–º–µ—Ç–∫–æ–≤
            updateScoreUI();
            releaseEnemyMesh(e);
            enemies.splice(j, 1);
          }
          break; // –ü—É–ª—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∞, –≤—ã—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –ø—É–ª–µ
        } else {
          // –õ–û–ì–ò–ö–ê –û–ë–´–ß–ù–û–ì–û –°–ï–†–î–¶–ê:
          // –û–Ω–æ –≤—Å–µ–≥–¥–∞ —É–º–∏—Ä–∞–µ—Ç —Å –æ–¥–Ω–æ–≥–æ –ø–æ–ø–∞–¥–∞–Ω–∏—è
          heartCount++;
          updateScoreUI();
          releaseEnemyMesh(e);
          enemies.splice(j, 1);

          // –ü—É–ª—è —Ç–µ—Ä—è–µ—Ç 1 –∑–∞—Ä—è–¥ –ø—Ä–æ–±–∏—Ç–∏—è
          bData.pierce--;

          // –ï—Å–ª–∏ –ø—Ä–æ–±–∏—Ç–∏–µ –∫–æ–Ω—á–∏–ª–æ—Å—å ‚Äî —É–¥–∞–ª—è–µ–º –ø—É–ª—é
          if (bData.pierce <= 0) {
            if (bMesh.userData.pooled) releaseBulletMesh(bMesh);
            else scene.remove(bMesh);
            bullets.splice(i, 1);
            bulletConsumed = true;
            break; // –ü—É–ª—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∞, –≤—ã—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –ø—É–ª–µ
          }
          // –ï—Å–ª–∏ pierce > 0, –ø—É–ª—è –ª–µ—Ç–∏—Ç –¥–∞–ª—å—à–µ –∏ –º–æ–∂–µ—Ç —É–±–∏—Ç—å –∫–æ–≥–æ-—Ç–æ –µ—â–µ –≤ —ç—Ç–æ–º –∂–µ –∫–∞–¥—Ä–µ
        }
      }
    }
    if (bulletConsumed) continue;
  } // end bullets loop

  // --- apply accumulated damage to walls once per frame ---
  for (let wi = walls.length - 1; wi >= 0; wi--){
    const w = walls[wi];
    if (!w || !w.userData || !w.userData.active) continue;
    const pd = w.userData.pendingDamage || 0;
    if (pd <= 0) continue;

    // apply all accumulated damage atomically
    w.userData.health -= pd;
    w.userData.pendingDamage = 0;

    if (w.userData.health < 0.5){
      // spawn gate with width equal WALL_WIDTH at exact wall center
      const r = Math.random();
      let gateData;
      if (r < 0.40) gateData = { label: '–£–†–û–í–ï–ù–¨ +1', action: 'level', val: 1 };
      else if (r < 0.65) gateData = { label: '–ì–í–û–ó–î–ò +1', action: 'count', val: 1 };
      else if (r < 0.80) gateData = { label: '–î–ê–õ–¨–ù–û–°–¢–¨ +1', action: 'range', val: 1 };
      else if (r < 0.95) gateData = { label: '–°–¢–†–ï–õ–¨–ë–ê +0.4', action: 'rate', val: 0.4 };
      else gateData = { label: '–ì–í–û–ó–î–ò +2', action: 'count', val: 2 };

      spawnGate(w.userData.side, w.userData.z, gateData, WALL_WIDTH);

      // update internal best params for this newly spawned gate (safe-guard)
      // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –≤—ã–ø–∞–≤—à–∏–π –∏–∑ —Å—Ç–µ–Ω—ã –≥–µ–π—Ç –≤ —Å–∏—Å—Ç–µ–º–µ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
      registerGateOpportunity(gateData, w.userData.z);

      // remove wall (return to pool)
      wallCount++;
      // –ü–æ—è–≤–ª—è–µ—Ç—Å—è –Ω–∏–∂–µ (0.8) –∏ —á–∞—Å—Ç–∏—Ü—ã –±–æ–ª–µ–µ "—Ö–æ–ª–æ–¥–Ω–æ–≥–æ" —Ü–≤–µ—Ç–∞
      spawnScoreText(w.position.x, 0, w.position.z, "+100");
      playSound('wallBreak'); // –ó–≤—É–∫ —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è –≤–∏—Ç—Ä–∏–Ω—ã
      // spawnBurst(w.position.x, w.position.y-0.2, w.position.z, 0xffffff, 15); // –ë–µ–ª—ã–µ –æ—Å–∫–æ–ª–∫–∏
      // spawnBurst(w.position.x, w.position.y-0.2, w.position.z, 0x00ffff, 10); // –Ø—Ä–∫–æ-–≥–æ–ª—É–±—ã–µ –∏—Å–∫—Ä—ã
      updateScoreUI();
      releaseWallMesh(w);
      walls.splice(wi, 1);
    } else {
      // still alive ‚Äî update its text (rounded display)
      updateWallText(w);
    }
  }
} // end if bullets.length

/* player‚Äìenemy collision */
  for (let j = enemies.length - 1; j >= 0; j--){
    const e = enemies[j];
    let hit = false;

    for (let i = nailGroup.children.length - 1; i >= 0; i--){
      const nail = nailGroup.children[i];
      const nailWorldX = nailGroup.position.x + nail.position.x;
      const nailWorldZ = nailGroup.position.z + nail.position.z;
      
      const dx = nailWorldX - e.position.x;
      const dz = nailWorldZ - e.position.z;
      const dist = Math.sqrt(dx*dx + dz*dz);

      // –†–∞–¥–∏—É—Å —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—è: –¥–ª—è –±–æ–ª—å—à–∏—Ö —Å–µ—Ä–¥–µ—Ü —á—É—Ç—å –±–æ–ª—å—à–µ
      const collisionRadius = e.userData.isBigHeart ? 0.9 : 0.7;

      if (dist < collisionRadius){
        hit = true;
        shakeTime = 0.4; // –¢—Ä—è—Å–µ–º —ç–∫—Ä–∞–Ω –ø—Ä–∏ —É–¥–∞—Ä–µ
        playSound('damage'); // –ó–≤—É–∫ –ø–æ–ª—É—á–µ–Ω–∏—è —É—Ä–æ–Ω–∞ –æ—Ç –≤—Ä–∞–≥–∞

        if (e.userData.isBigHeart) {
           // –õ–æ–≥–∏–∫–∞ –ë–æ–ª—å—à–æ–≥–æ –°–µ—Ä–¥—Ü–∞: –≤—ã—á–∏—Ç–∞–µ–º –µ–≥–æ –∂–∏–∑–Ω–∏ –∏–∑ —É—Ä–æ–≤–Ω—è –≥–≤–æ–∑–¥—è
           const damageToHeart = Math.min(e.userData.hp, nailLevels[i]);
           e.userData.hp -= damageToHeart;
           nailLevels[i] -= damageToHeart;

           // –ï—Å–ª–∏ —É—Ä–æ–≤–µ–Ω—å –≥–≤–æ–∑–¥—è –æ–±–Ω—É–ª–∏–ª—Å—è ‚Äî —É–¥–∞–ª—è–µ–º –≥–≤–æ–∑–¥—å
           if (nailLevels[i] <= 0) {
              nailLevels.splice(i, 1);
              nailCount = nailLevels.length;
           }
           
           // –ï—Å–ª–∏ —ç—Ç–æ –±—ã–ª–æ –ø–æ—Å–ª–µ–¥–Ω–µ–µ –∑–¥–æ—Ä–æ–≤—å–µ —Å–µ—Ä–¥—Ü–∞ ‚Äî —É–¥–∞–ª—è–µ–º —Å–µ—Ä–¥—Ü–µ
           if (e.userData.hp <= 0) {
              if (e.userData.pooled) releaseEnemyMesh(e);
              else scene.remove(e);
              enemies.splice(j, 1);
           }
        } else {
           // –õ–æ–≥–∏–∫–∞ –æ–±—ã—á–Ω–æ–≥–æ —Å–µ—Ä–¥—Ü–∞
           if (nailLevels[i] > 1) {
             nailLevels[i]--;
           } else {
             nailLevels.splice(i, 1);
             nailCount = nailLevels.length;
           }
           if (e.userData.pooled) releaseEnemyMesh(e);
           else scene.remove(e);
           enemies.splice(j, 1);
        }

        // –ü–µ—Ä–µ—Å–æ–±–∏—Ä–∞–µ–º –º–æ–¥–µ–ª—å –∏–≥—Ä–æ–∫–∞ –ø–æ—Å–ª–µ –ø–æ—Ç–µ—Ä–∏ —É—Ä–æ–≤–Ω—è/–≥–≤–æ–∑–¥—è
        rebuildNailFormation();

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –ø—Ä–æ–∏–≥—Ä—ã—à
        if (nailCount <= 0) {
          gameOver = true;
          showLeaderboardSubmit(computeScore(), 'Game over!');
          return; // –¢–µ–ø–µ—Ä—å –æ–Ω –≤–Ω—É—Ç—Ä–∏ —Ñ—É–Ω–∫—Ü–∏–∏ animate –∏ —Å—Ä–∞–±–æ—Ç–∞–µ—Ç –≤–µ—Ä–Ω–æ
        }
        
        break; // –ü—Ä–µ—Ä—ã–≤–∞–µ–º –ø—Ä–æ–≤–µ—Ä–∫—É –≥–≤–æ–∑–¥–µ–π –¥–ª—è —ç—Ç–æ–≥–æ –≤—Ä–∞–≥–∞
      }
    }
  }

  /* player‚Äìgate collision */
  gates.forEach((g, idx) => {
    let touched = false;

    // –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞—Å–∞–Ω–∏–µ –ª—é–±—ã–º –≥–≤–æ–∑–¥—ë–º
    for (const nail of nailGroup.children){
      const dx = nailGroup.position.x + nail.position.x - g.position.x;
      const dz = nailGroup.position.z                - g.position.z;
      if (Math.sqrt(dx*dx + dz*dz) < 1.5){
        touched = true;
        break;
      }
    }

    if (!touched) return;

    const d = g.userData;

    if (d.action === 'rate'){
      fireRate = Math.max(0.2, fireRate + d.val);
    }

    if (d.action === 'range'){
      if (d.mode === 'mul'){
        fireRange = Math.max(1, fireRange * d.val);
      } else {
        fireRange = Math.max(1, fireRange + d.val); // –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ —Å–Ω–∏–∑—É
      }
      rebuildNailFormation();
    }


    if (d.action === 'count'){
      // –µ—Å–ª–∏ –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π gate ¬´-1 –≥–≤–æ–∑–¥—å¬ª –∏ –æ—Å—Ç–∞–ª—Å—è –≤—Å–µ–≥–æ –æ–¥–∏–Ω
      if (d.val === -1 && nailCount === 1){
        gameOver = true;
        showLeaderboardSubmit(computeScore(), 'Game over!');
        return;
      }
      if (d.val > 0) {
        // ---------- –µ–¥–∏–Ω–æ–µ –º–µ—Å—Ç–æ –ª–æ–≥–∏–∫–∏ ----------
        if (d.val === 2 && nailCount === 4) {
          // —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π –ì–í–û–ó–î–ò +2 –ø—Ä–∏ 4 –≥–≤–æ–∑–¥—è—Ö
          nailCount = 5;                        // –æ–¥–∏–Ω –Ω–æ–≤—ã–π –≥–≤–æ–∑–¥—å
          nailLevels.push(1);                   // —É—Ä–æ–≤–µ–Ω—å 1
          nailLevels.forEach((_, i) => nailLevels[i]++); // +1 –≤—Å–µ–º
        } else if (nailCount === MAX_NAILS) {
          // –ª—é–±–æ–π –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π –≥–µ–π—Ç –ø—Ä–∏ 5
          nailLevels.forEach((_, i) => nailLevels[i]++);
        } else {
          // –æ–±—ã—á–Ω–æ–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ
          const maxLevel = Math.max(...nailLevels, 1);
          for (let i = 0; i < d.val; i++) nailLevels.push(maxLevel);
          nailCount += d.val;
        }
        redistributeLevels();
      } else {
        // –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–µ (—É–¥–∞–ª–µ–Ω–∏–µ)
        nailCount = Math.max(1, nailCount + d.val); // d.val –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω–æ–µ
        for (let i = 0; i < -d.val; i++) nailLevels.pop();
        redistributeLevels();
        shakeTime = 0.4; // –¢—Ä—è—Å–µ–º —ç–∫—Ä–∞–Ω –ø—Ä–∏ —É–¥–∞—Ä–µ
        playSound('damage'); // –ó–≤—É–∫ –ø–æ–ª—É—á–µ–Ω–∏—è —É—Ä–æ–Ω–∞ –æ—Ç –≤—Ä–∞–≥–∞
      }

      rebuildNailFormation();
    }

    if (d.action === 'level'){
      for (let i = 0; i < nailCount; i++){
        nailLevels[i] = Math.max(1, nailLevels[i] + d.val);
      }
      rebuildNailFormation();
    }

    // –æ–±–Ω–æ–≤–ª—è–µ–º UI
    document.getElementById('count').textContent  = nailCount;
    document.getElementById('levels').textContent = nailLevels.reduce((a,b)=>a+b,0);
    document.getElementById('rate').textContent   = fireRate.toFixed(1);
    document.getElementById('range').textContent = fireRange.toFixed(1);

    scene.remove(g); gates.splice(idx,1);

    // –Ω–∞–π—Ç–∏ ¬´–ø–∞—Ä–Ω–æ–≥–æ¬ª –≥–µ–π—Ç –Ω–∞ —Ç–æ–π –∂–µ Z
    const twin = gates.find(g2 => g2 !== g && Math.abs(g2.position.z - g.position.z) < 0.5);
    if (twin) {
      gates.splice(gates.indexOf(twin), 1);
      fadeOutGate(twin);
    }
  });

/* ---------- player‚Äìwall collision (FRONT-ONLY, –∞—Ç–æ–º–∞—Ä–Ω–æ) ---------- */
const COLLIDE_DISTANCE = 1.5; // –ø–æ—Ä–æ–≥ –ø–æ Z (–≥–ª—É–±–∏–Ω–∞ –∫–æ–Ω—Ç–∞–∫—Ç–∞)

if (Array.isArray(walls) && walls.length) {
  for (let wi = walls.length - 1; wi >= 0; wi--) {
    const w = walls[wi];
    if (!w || !w.userData || !w.userData.active) continue;

    // —Ç–µ–∫—É—â–µ–µ HP —Å—Ç–µ–Ω—ã (float)
    const wHP = (typeof w.userData.health === 'number') ? w.userData.health : 0;
    // if (wHP < 0.5) {
    //   wallCount++;
    //   updateScoreUI();
    //   releaseWallMesh(w);
    //   walls.splice(wi,1);
    //   continue;
    // } –ì–ï–ú–ò–ù–ò –°–ö–ê–ó–ê–õ –£–î–ê–õ–ò–¢–¨, –Ω–µ –∑–Ω–∞—é

    // —Å–æ–±–∏—Ä–∞–µ–º –∏–Ω–¥–µ–∫—Å—ã –≥–≤–æ–∑–¥–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –ü–ï–†–ï–î —Å—Ç–µ–Ω–∫–æ–π (front) –∏ –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö X
    const collidingIndices = [];
    for (let ni = 0; ni < nailGroup.children.length; ni++){
      const nailMesh = nailGroup.children[ni];
      const nailWorldX = nailGroup.position.x + (nailMesh.position.x || 0);
      const nailWorldZ = nailGroup.position.z + (nailMesh.position.z || 0);
      const dx = Math.abs(nailWorldX - w.position.x);
      const dzFront = nailWorldZ - w.position.z; // >0 => nail is on player's side (in front of wall)

      // –¢–æ–ª—å–∫–æ –ü–ï–†–ï–î —Å—Ç–µ–Ω–∫–æ–π –∏ –≤–Ω—É—Ç—Ä–∏ —à–∏—Ä–∏–Ω—ã –∏ –Ω–µ –¥–∞–ª—å—à–µ –ø–æ Z, —á–µ–º –¥–æ–ø—É—Å—Ç–∏–º–æ
      if (dx <= (WALL_WIDTH / 2) && dzFront >= 0 && dzFront <= COLLIDE_DISTANCE) {
        collidingIndices.push(ni);
      }
    }

    if (collidingIndices.length === 0) continue;

    // –î–ª—è —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏ –±–µ—Ä—ë–º H0 (–æ–∫—Ä—É–≥–ª—ë–Ω–Ω–æ–µ –æ—Ç–æ–±—Ä–∞–∂–∞–µ–º–æ–µ HP) –∫–∞–∫ –æ—Å–Ω–æ–≤—É —Ä–∞—Å—á—ë—Ç–∞ dmg
    const H0 = Math.ceil(wHP);

    // –í—ã—á–∏—Å–ª—è–µ–º dmg –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –≥–≤–æ–∑–¥—è: –Ω–µ –±–æ–ª—å—à–µ —É—Ä–æ–≤–Ω—è –≥–≤–æ–∑–¥—è –∏ –Ω–µ –±–æ–ª—å—à–µ —Ç–µ–∫—É—â–µ–≥–æ HP —Å—Ç–µ–Ω—ã.
    const dmgEntries = collidingIndices.map(idx => {
      const lvl = (nailLevels[idx] !== undefined) ? nailLevels[idx] : 1;
      const dmg = Math.min(Math.max(0, Math.round(H0)), Math.max(0, Math.round(lvl)));
      return { index: idx, level: lvl, dmg };
    });

    // –°—É–º–º–∞—Ä–Ω—ã–π —É—Ä–æ–Ω —Å—Ç–µ–Ω–∫–µ
    const totalWallDamage = dmgEntries.reduce((s,e)=>s+e.dmg, 0);
    if (totalWallDamage > 0) {
      shakeTime = 0.4; // –¢—Ä—è—Å–∫–∞, –µ—Å–ª–∏ –∏–≥—Ä–æ–∫ –ø–æ—Ç–µ—Ä—è–ª —É—Ä–æ–≤–Ω–∏ –æ–± —Å—Ç–µ–Ω—É
      playSound('damage'); // –ó–≤—É–∫ –ø–æ–ª—É—á–µ–Ω–∏—è —É—Ä–æ–Ω–∞ –æ—Ç —Å—Ç–µ–Ω—ã
    }

    // –ü—Ä–∏–º–µ–Ω—è–µ–º —É—Ä–æ–Ω –∫ —Å—Ç–µ–Ω–∫–µ –∞—Ç–æ–º–∞—Ä–Ω–æ
    w.userData.health = (w.userData.health || 0) - totalWallDamage;

    // –ì–æ—Ç–æ–≤–∏–º –∏–∑–º–µ–Ω–µ–Ω–∏—è —É—Ä–æ–≤–Ω–µ–π –≥–≤–æ–∑–¥–µ–π (–∫–æ–ø–∏—è)
    let newLevels = nailLevels.slice();
    const toRemove = [];

    dmgEntries.forEach(entry => {
      const i = entry.index;
      const lvl = entry.level;
      const dmg = entry.dmg;
      if (dmg >= lvl) {
        toRemove.push(i);
      } else if (dmg > 0) {
        newLevels[i] = Math.max(0, lvl - dmg);
      }
      // –µ—Å–ª–∏ dmg == 0 ‚Äî –Ω–∏—á–µ–≥–æ –Ω–µ –¥–µ–ª–∞–µ–º
    });

    // –£–¥–∞–ª—è–µ–º –ø–æ–º–µ—á–µ–Ω–Ω—ã–µ –≤ –ø–æ—Ä—è–¥–∫–µ —É–±—ã–≤–∞–Ω–∏—è –∏–Ω–¥–µ–∫—Å–æ–≤
    if (toRemove.length > 0){
      toRemove.sort((a,b)=>b-a);
      for (const rem of toRemove){
        if (rem >= 0 && rem < newLevels.length) newLevels.splice(rem,1);
      }
    }

    // –ß–∏—Å—Ç–∏–º –Ω—É–ª–µ–≤—ã–µ —É—Ä–æ–≤–Ω–∏
    for (let i = newLevels.length - 1; i >= 0; i--){
      if (!newLevels[i] || newLevels[i] <= 0) newLevels.splice(i,1);
    }

    // –ï—Å–ª–∏ –ø–æ—Å–ª–µ –≤—Å–µ—Ö —É–¥–∞—Ä–æ–≤ –Ω–µ –æ—Å—Ç–∞–ª–æ—Å—å –≥–≤–æ–∑–¥–µ–π -> Game Over
    if (newLevels.length === 0){
      nailLevels = [];
      nailCount = 0;
      rebuildNailFormation();
      document.getElementById('count').textContent = 0;
      document.getElementById('levels').textContent = 0;
      document.getElementById('rate').textContent = fireRate.toFixed(1);
      document.getElementById('range').textContent = fireRange.toFixed(1);
      gameOver = true;
      showLeaderboardSubmit(computeScore(), 'Game over!');
      return;
    }

    // –ü—Ä–∏–º–µ–Ω—è–µ–º –æ–±–Ω–æ–≤–ª—ë–Ω–Ω—ã–µ —É—Ä–æ–≤–Ω–∏
    nailLevels = newLevels.slice();
    nailCount = Math.max(1, nailLevels.length);
    rebuildNailFormation();

    // –ï—Å–ª–∏ —Å—Ç–µ–Ω–∫–∞ —Ä–∞–∑—Ä—É—à–∏–ª–∞—Å—å ‚Äî –ø–æ—Ä–æ–∂–¥–∞–µ–º –≥–µ–π—Ç –∏ —É–¥–∞–ª—è–µ–º —Å—Ç–µ–Ω–∫—É
    if (w.userData.health < 0.5){
      const r = Math.random();
      let gateData;
      if (r < 0.40) gateData = { label: '–£–†–û–í–ï–ù–¨ +1', action: 'level', val: 1 };
      else if (r < 0.65) gateData = { label: '–ì–í–û–ó–î–ò +1', action: 'count', val: 1 };
      else if (r < 0.80) gateData = { label: '–î–ê–õ–¨–ù–û–°–¢–¨ +1', action: 'range', val: 1 };
      else if (r < 0.95) gateData = { label: '–°–¢–†–ï–õ–¨–ë–ê +0.4', action: 'rate', val: 0.4 };
      else gateData = { label: '–ì–í–û–ó–î–ò +2', action: 'count', val: 2 };

      spawnGate(w.userData.side || 0, w.userData.z || nailGroup.position.z, gateData, WALL_WIDTH);
      // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –≤—ã–ø–∞–≤—à–∏–π –∏–∑ —Å—Ç–µ–Ω—ã –≥–µ–π—Ç –≤ —Å–∏—Å—Ç–µ–º–µ —Å–ª–æ–∂–Ω–æ—Å—Ç–∏
      registerGateOpportunity(gateData, w.userData.z);
      
      wallCount++;
      spawnScoreText(w.position.x, 2, w.position.z, "+100");
      playSound('wallBreak'); // –ó–≤—É–∫ —Ä–∞–∑—Ä—É—à–µ–Ω–∏—è –≤–∏—Ç—Ä–∏–Ω—ã
      // spawnBurst(w.position.x, 1, w.position.z, 0x88ccee, 15); // –ì–æ–ª—É–±—ã–µ –æ—Å–∫–æ–ª–∫–∏ —Å—Ç–µ–∫–ª–∞
      updateScoreUI();
      releaseWallMesh(w);
      walls.splice(wi,1);
    } else {
      // –û–±–Ω–æ–≤–ª—è–µ–º —Ç–µ–∫—Å—Ç —Å—Ç–µ–Ω–∫–∏
      updateWallText(w);
    }
  } // for walls
} // if walls

/* ---------- end of player‚Äìwall collision ---------- */

  /* win condition –ø–æ —Ä–µ–∞–ª—å–Ω–æ–º—É –≤—Ä–µ–º–µ–Ω–∏ */
  const elapsedSec = (performance.now() - songStartTime) / 1000;
  const progress = Math.min(1, elapsedSec / SONG_DURATION);
  document.getElementById('progressFill').style.width = (progress * 100) + '%';

// –î–∞–µ–º +3 —Å–µ–∫—É–Ω–¥—ã –∑–∞–ø–∞—Å–∞, —á—Ç–æ–±—ã –∏–≥—Ä–æ–∫ —Ç–æ—á–Ω–æ —É—Å–ø–µ–ª –ø–µ—Ä–µ—Å–µ—á—å —Ñ–∏–Ω–∏—à–Ω—É—é —á–µ—Ä—Ç—É —Ñ–∏–∑–∏—á–µ—Å–∫–∏
  if (elapsedSec >= SONG_DURATION + 0.2){
    gameOver = true;
    showLeaderboardSubmit(computeScore(), '–ü–æ–±–µ–¥–∞!');
    return;
  }

  // --- –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ debug-UI: max –∏ —Ç–µ–∫—É—â–∏–π —É—Ä–æ–Ω ---
  function calcCurrentDamage(){
    const params = {
      nailLevels: nailLevels.slice(),
      rate: fireRate,
      range: fireRange
    };
    return calcMaxDamageForOneTarget(params);
  }

  // –æ–∫—Ä—É–≥–ª—è–µ–º –¥–ª—è —á–∏—Ç–∞–µ–º–æ—Å—Ç–∏
  const curD = Math.round(calcCurrentDamage());
  let maxD = Math.round(calcMaxDamageForOneTarget(maxParams));

  // –ê–í–¢–û-–°–ò–ù–•–†–û–ù–ò–ó–ê–¶–ò–Ø: –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ –ø—Ä–µ–≤–∑–æ—à–µ–ª –∏–¥–µ–∞–ª, –æ–±–Ω–æ–≤–ª—è–µ–º –∏–¥–µ–∞–ª
  // if (curD > maxD) {
  //   maxParams.count = nailCount;
  //   maxParams.nailLevels = [...nailLevels];
  //   maxParams.rate = fireRate;
  //   maxParams.range = fireRange;
  //   maxD = curD; // –¢–µ–ø–µ—Ä—å –æ–Ω–∏ —Ä–∞–≤–Ω—ã
  // }
  
  const maxEl = document.getElementById('maxd');
  const curEl = document.getElementById('curd');
  if (maxEl) maxEl.textContent = maxD;
  if (curEl) curEl.textContent = curD;

/* camera follow */
  // 1. –°–Ω–∞—á–∞–ª–∞ –∂–µ—Å—Ç–∫–æ —Å—Ç–∞–≤–∏–º –±–∞–∑—É –∫–∞–º–µ—Ä—ã
  camera.position.x = nailGroup.position.x;
  camera.position.y = 5; 
  camera.position.z = nailGroup.position.z + 9;

  // 2. –î–æ–±–∞–≤–ª—è–µ–º —Ç—Ä—è—Å–∫—É –∫ —É–∂–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏
  if (typeof shakeTime !== 'undefined' && shakeTime > 0) {
    camera.position.x += (Math.random() - 0.5) * shakeTime;
    camera.position.y += (Math.random() - 0.5) * shakeTime;
    shakeTime -= dt * 2; // –ü–æ—Å—Ç–µ–ø–µ–Ω–Ω–æ —É–º–µ–Ω—å—à–∞–µ–º —Å–∏–ª—É —Ç—Ä—è—Å–∫–∏
  }

  // 3. –ò —Ç–æ–ª—å–∫–æ –≤ —Å–∞–º–æ–º –∫–æ–Ω—Ü–µ –∑–∞—Å—Ç–∞–≤–ª—è–µ–º –∫–∞–º–µ—Ä—É —Å–º–æ—Ç—Ä–µ—Ç—å –≤ –Ω—É–∂–Ω—É—é —Ç–æ—á–∫—É
  camera.lookAt(nailGroup.position.x, 0, nailGroup.position.z - 3);

  /* —É–¥–∞–ª—è–µ–º –≤—Ä–∞–≥–æ–≤ –∏ –≥–µ–π—Ç—ã –∑–∞ —Å–ø–∏–Ω–æ–π */
  const behind = nailGroup.position.z + 10;  // –ø–æ—Ä–æ–≥ —É–¥–∞–ª–µ–Ω–∏—è
  for (let i = enemies.length - 1; i >= 0; i--) {
    if (enemies[i].position.z > behind) {
      const en = enemies[i];
      if (en.userData.pooled) {
        releaseEnemyMesh(en);
      } else {
        scene.remove(en);
      }
      enemies.splice(i, 1);
    }
  }
  for (let i = gates.length - 1; i >= 0; i--) {
    if (gates[i].position.z > behind) {
      scene.remove(gates[i]);
      gates.splice(i, 1);
    }
  }

  // remove walls that are behind
  for (let i = walls.length - 1; i >= 0; i--) {
    if (walls[i].position.z > behind) {
      // return to pool (do not dispose canvas)
      releaseWallMesh(walls[i]);
      walls.splice(i, 1);
    }
  }

  updateRunway();
  
  
  /* –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –±–∞–Ω–Ω–µ—Ä —Å—Ç—Ä–æ–≥–æ –Ω–∞–¥ —Ü–µ–Ω—Ç—Ä–æ–º —Ç–æ–ª–ø—ã –±–µ–∑ –Ω–∞–∫–ª–æ–Ω–∞ */
bannerMesh.position.set(
  nailGroup.position.x,
  nailGroup.position.y + 1.2,
  nailGroup.position.z
);
bannerMesh.rotation.copy(camera.rotation); // –≤—Å–µ–≥–¥–∞ —Å–º–æ—Ç—Ä–∏—Ç –≤ –∫–∞–º–µ—Ä—É (–Ω–µ –Ω–∞–∫–ª–æ–Ω—è–µ—Ç—Å—è)

  /* FPS counter */
  if (!animate.lastFpsUpdate) animate.lastFpsUpdate = time;
  if (!animate.frameCount) animate.frameCount = 0;
  animate.frameCount++;

  if (time - animate.lastFpsUpdate >= 1000) {
    const fps = (animate.frameCount * 1000) / (time - animate.lastFpsUpdate);
    document.getElementById('fps').textContent = fps.toFixed(0);
    animate.frameCount = 0;
    animate.lastFpsUpdate = time;
  }

    // --- handle gate fading (safer: collect first, then process) ---
    try {
      const fading = [];
      scene.traverse(o => {
        if (o && o.userData && o.userData.fade) fading.push(o);
      });

      for (let k = 0; k < fading.length; k++) {
        const obj = fading[k];
        // defensive checks
        if (!obj) continue;
        if (!obj.userData) continue;
        const f = obj.userData.fade;
        if (!f) continue;
        const start = f.start || 0;
        const dur = f.dur || 1;
        const t = (time - start) / dur;

        if (t >= 1) {
          // remove object safely (it may already be removed)
          if (obj.parent) obj.parent.remove(obj);
          else scene.remove(obj);
          // tidy up userData
          try { delete obj.userData.fade; } catch(e){}
          continue;
        }

        // update opacity on all child meshes that have transparent materials
        if (typeof obj.traverse === 'function') {
          obj.traverse(child => {
            if (!child) return;
            const mat = child.material;
            if (!mat) return;
            // material can be array or single
            if (Array.isArray(mat)) {
              for (const m of mat) if (m && m.transparent) m.opacity = (1 - t) * 0.3;
            } else {
              if (mat.transparent) mat.opacity = (1 - t) * 0.3;
            }
          });
        }
      }
    } catch (err) {
      // fail-safe: log once without breaking the loop
      console.warn('Fade handler error:', err);
    }

  renderer.render(scene,camera);
}
animate();
</script>
</body>
<script>
// ========== –ù–∞—Å—Ç—Ä–æ–π–∫–∞: –∞–¥—Ä–µ—Å Worker ==========
const API_BASE = 'https://mimo-api-kitonbass.amvera.io'; // –∏–ª–∏ '/api' if redirect

// –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –≤—ã–≤–æ–¥–∞
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c])); }

// –û—Ç—Ä–∏—Å–æ–≤–∫–∞ —Ç–æ–ø–∞ (–≤—Å—Ç–∞–≤–∏—Ç –≤ #msg –∏–ª–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω—ã–π –±–ª–æ–∫)
async function fetchAndRenderTop(limit = 10) {
  try {
    const res = await fetch(`${API_BASE}/top?limit=${limit}`);
    if (!res.ok) throw new Error('fetch top failed');
    const list = await res.json();
    const container = document.getElementById('lb_top');
    if (!container) return;
    
    if (!list || list.length === 0) {
      container.innerHTML = '<i class="text-gray-500">–¢–æ–ø –ø—É—Å—Ç</i>';
      return;
    }

    const saved = loadPlayer();
    const playerName = saved ? saved.name : null;

    container.innerHTML = '<div class="font-bold border-b-2 border-black mb-2 pb-1">–¢–û–ü –ò–ì–†–û–ö–û–í:</div>' + 
      list.map((x, i) => {
        const name = escapeHtml(x.name || 'anon');
        const score = Number(x.score || 0);
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —è–≤–ª—è–µ—Ç—Å—è –ª–∏ —ç—Ç–∞ —Å—Ç—Ä–æ–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–º —Ç–µ–∫—É—â–µ–≥–æ –∏–≥—Ä–æ–∫–∞
        const isPlayer = playerName && x.name === playerName;
        
        const style = isPlayer 
            ? 'background: #0077FF; color: #fff; padding: 2px 6px; border-radius: 4px; font-weight: 900;' 
            : 'padding: 2px 6px;';

        return `<div style="display:flex; justify-content:between; ${style} font-family:sans-serif; margin-bottom:2px;">
            <span style="flex:1">${i + 1}. ${name}</span>
            <span style="font-weight:bold">${score}</span>
        </div>`;
      }).join('');
  } catch (e) {
    const container = document.getElementById('lb_top');
    if (container) container.innerHTML = '<i>–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Ç–æ–ø</i>';
  }
}

function createTopContainer(){
  const wrapper = document.createElement('div');
  wrapper.id = 'lb_top';
  wrapper.style.marginTop = '12px';
  const msg = document.getElementById('msg') || document.body;
  msg.appendChild(wrapper);
  return wrapper;
}

// –§–æ—Ä–º–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ (–≤—ã–∑–≤–∞—Ç—å –ø—Ä–∏ gameOver)
// -------------------- LocalStorage helpers --------------------
function loadPlayer(){
  try {
    const raw = localStorage.getItem('mimo_player');
    return raw ? JSON.parse(raw) : null;
  } catch(e){
    return null;
  }
}
function savePlayer(name, email){
  try {
    localStorage.setItem('mimo_player', JSON.stringify({ name: String(name || '').trim(), email: String(email || '').trim() || null }));
  } catch(e){}
}

// -------------------- submit helper --------------------
async function submitScore({ name, email, score, meta }){
  const payload = { name: String(name || 'anon').slice(0,64), score: Number(score||0), contact_email: email || null, meta: meta || { source: 'web' } };
  const res = await fetch(`${API_BASE}/submit`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload)
  });
  const j = await res.json().catch(()=>({ error: 'invalid_json' }));
  return { ok: res.ok, status: res.status, json: j };
}

// -------------------- showLeaderboardSubmit (–Ω–æ–≤–∞—è –≤–µ—Ä—Å–∏—è) --------------------
/*
  showLeaderboardSubmit(finalScore, title)
  - finalScore: —á–∏—Å–ª–æ (–æ–±—ã—á–Ω–æ computeScore())
  - title: –Ω–µ–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–∞ ("Game over!" / "–ü–æ–±–µ–¥–∞!")
*/
async function showLeaderboardSubmit(finalScore, title){
  const el = document.getElementById('msg');
  if (!el) return;
  
  const hearts = (typeof getHeartCount === 'function') ? Number(getHeartCount()) : (typeof heartCount !== 'undefined' ? Number(heartCount) : 0);
  const walls  = (typeof getWallCount === 'function') ? Number(getWallCount()) : (typeof wallCount !== 'undefined' ? Number(wallCount) : 0);
  const total  = Number(finalScore || (typeof computeScore === 'function' ? computeScore() : (hearts + walls * 100)) || 0);
  const saved = loadPlayer();

  const header = title ? `<h2 class="uppercase text-2xl font-black">${escapeHtml(title)}</h2>` : '';
  const lead = `<p class="text-lg font-bold mb-4">–í—ã —Ä–∞–∑–±–∏–ª–∏ ${hearts} —Å–µ—Ä–¥–µ—Ü –∏ ${walls} –≤–∏—Ç—Ä–∏–Ω!<br>–í–∞—à —Å—á—ë—Ç: <span class="text-blue-700 text-2xl">${total}</span></p>`;

  // –ë–∞–∑–æ–≤–∞—è —Å—Ç—Ä—É–∫—Ç—É—Ä–∞ –º–æ–¥–∞–ª–∫–∏ –≤ —Å—Ç–∏–ª–µ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é
  el.innerHTML = `
    <div class="paper-modal max-w-lg w-full paper-font">
      <div class="absolute -top-6 left-1/2 -translate-x-1/2 w-32 h-10 bg-white/40 backdrop-blur-sm rotate-2 shadow-sm pointer-events-none"></div>
      ${header}
      ${lead}
      <div id="lb_form_container" class="flex flex-col gap-4">
          <!-- –°—é–¥–∞ –≤—Å—Ç–∞–≤–∏—Ç—Å—è –ª–∏–±–æ —Ñ–æ—Ä–º–∞, –ª–∏–±–æ –∏–Ω—Ñ–æ –æ–± –∏–≥—Ä–æ–∫–µ -->
      </div>
      <div id="lb_status" class="text-xs font-bold my-2 text-blue-600 min-h-[1.5em]"></div>
      <div id="lb_top" class="bg-white/50 border-2 border-dashed border-black p-4 mt-4 text-sm max-h-48 overflow-y-auto">
          <div class="animate-pulse text-center">–ó–∞–≥—Ä—É–∑–∫–∞ —Ç–æ–ø–∞...</div>
      </div>
    </div>
  `;
  el.style.display = 'flex';

  const container = document.getElementById('lb_form_container');

  if (saved && saved.name) {
    // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ —É–∂–µ —Å–æ—Ö—Ä–∞–Ω—è–ª—Å—è
    container.innerHTML = `
      <p class="text-sm italic">–í—ã –≤–æ—à–ª–∏ –∫–∞–∫: <b>${escapeHtml(saved.name)}</b></p>
      <div class="flex flex-col gap-2">
        <button id="lb_resend" class="bg-blue-600 text-white font-bold py-3 border-2 border-black shadow-[4px_4px_0_black] hover:translate-y-1 hover:shadow-none transition-all">–û–¢–ü–†–ê–í–ò–¢–¨ –†–ï–ó–£–õ–¨–¢–ê–¢</button>
        <div class="flex gap-2">
            <button id="lb_edit" class="flex-1 bg-gray-200 text-black text-xs font-bold py-2 border-2 border-black">–ò–ó–ú–ï–ù–ò–¢–¨ –î–ê–ù–ù–´–ï</button>
            <button onclick="location.reload()" class="flex-1 bg-black text-white text-xs font-bold py-2 border-2 border-black">–†–ï–°–¢–ê–†–¢</button>
        </div>
      </div>
    `;
    
    // –ê–≤—Ç–æ-–æ—Ç–ø—Ä–∞–≤–∫–∞
    (async () => {
        const st = document.getElementById('lb_status');
        st.innerText = '–û—Ç–ø—Ä–∞–≤–∫–∞ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞...';
        const {ok} = await submitScore({ name: saved.name, email: saved.email, score: total, meta: { source: 'auto' } }).catch(()=>({ok:false}));
        st.innerText = ok ? '–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω!' : '–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏';
        await fetchAndRenderTop();
    })();

    document.getElementById('lb_resend').onclick = async () => {
        document.getElementById('lb_status').innerText = '–û—Ç–ø—Ä–∞–≤–∫–∞...';
        await submitScore({ name: saved.name, email: saved.email, score: total });
        await fetchAndRenderTop();
    };
    document.getElementById('lb_edit').onclick = () => {
        savePlayer('', ''); // –°–±—Ä–æ—Å
        showLeaderboardSubmit(total, title); // –ü–µ—Ä–µ—Ä–∏—Å–æ–≤–∞—Ç—å
    };

  } else {
    // –ï—Å–ª–∏ –¥–∞–Ω–Ω—ã—Ö –Ω–µ—Ç ‚Äî —Ä–∏—Å—É–µ–º —Ñ–æ—Ä–º—É
    container.innerHTML = `
      <input id="lb_name" class="paper-input w-full" placeholder="–í–ê–® –ù–ò–ö" maxlength="20" />
      <input id="lb_email" class="paper-input w-full" placeholder="EMAIL (–î–õ–Ø –ö–û–ù–ö–£–†–°–ê)" maxlength="40" />
      <div class="flex flex-col gap-2 mt-2">
        <button id="lb_send" class="bg-blue-600 text-white font-bold py-4 border-2 border-black shadow-[4px_4px_0_black] active:translate-y-1 active:shadow-none transition-all uppercase tracking-widest">–°–û–•–†–ê–ù–ò–¢–¨ –ò –û–ü–£–ë–õ–ò–ö–û–í–ê–¢–¨</button>
        <button onclick="location.reload()" class="text-xs font-bold uppercase underline">–ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å –±–µ–∑ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è</button>
      </div>
    `;

    document.getElementById('lb_send').onclick = async () => {
      const name = (document.getElementById('lb_name').value || '').trim();
      const email = (document.getElementById('lb_email').value || '').trim();
      const status = document.getElementById('lb_status');
      
      if (!name) { status.innerText = '–í–≤–µ–¥–∏—Ç–µ –∏–º—è!'; return; }
      
      status.innerText = '–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ...';
      const { ok } = await submitScore({ name, email, score: total }).catch(()=>({ok:false}));
      if (ok) {
        savePlayer(name, email);
        status.innerText = '–£—Å–ø–µ—à–Ω–æ!';
        showLeaderboardSubmit(total, title); // –û–±–Ω–æ–≤–∏—Ç—å –≤–∏–¥ –Ω–∞ "—Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã–π"
      } else {
        status.innerText = '–û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è';
      }
    };
  }

  fetchAndRenderTop();
}

// –î–ª—è –±—ã—Å—Ç—Ä–æ–≥–æ —Ç–µ—Å—Ç–∞ (–≤ –∫–æ–Ω—Å–æ–ª–∏) –º–æ–∂–Ω–æ –≤—ã–∑–≤–∞—Ç—å:
// showLeaderboardSubmit(1234);

// –ê–≤—Ç–æ-–ø–æ–¥–≥—Ä—É–∑–∫–∞ —Ç–æ–ø–∞ –∫–∞–∂–¥—ã–µ 30 —Å (–µ—Å–ª–∏ —Ö–æ—Ç–∏—Ç–µ –ø–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ø –ø–æ—Å—Ç–æ—è–Ω–Ω–æ)
setInterval(()=>fetchAndRenderTop(10), 30000);
fetchAndRenderTop(10); // –Ω–∞—á–∞–ª—å–Ω–∞—è –∑–∞–≥—Ä—É–∑–∫–∞

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –æ—Ç—Ä–∏—Å–æ–≤–∫–∏ –∫—Ä–∞—Å–∏–≤–æ–≥–æ —Ç–æ–ø–∞ –≤ –ì–õ–ê–í–ù–û–ú –ú–ï–ù–Æ
async function fetchAndRenderMenuTop() {
  const container = document.getElementById('menu-leaderboard-list');
  if (!container) return;

  try {
    const res = await fetch(`${API_BASE}/top?limit=5`); // –ë–µ—Ä–µ–º —Ç–æ–ø-5
    if (!res.ok) throw new Error('fail');
    const list = await res.json();

    if (!list || list.length === 0) {
      container.innerHTML = '<div class="text-center text-gray-500">–ü–æ–∫–∞ –ø—É—Å—Ç–æ...</div>';
      return;
    }

    // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º HTML –¥–ª—è —Ç–æ–ø–∞
    container.innerHTML = list.map((x, i) => {
      const name = escapeHtml(x.name || 'anon').slice(0, 12); 
      const score = Number(x.score || 0).toLocaleString(); 
      
      let rankColor = 'text-gray-600';
      if(i === 0) rankColor = 'text-red-600 font-bold';
      if(i === 1) rankColor = 'text-blue-600 font-bold';
      if(i === 2) rankColor = 'text-green-600 font-bold';

      return `
        <div class="flex items-center justify-between border-b border-gray-300 pb-1">
            <div class="flex items-center gap-2">
                <span class="${rankColor} text-lg w-4">${i + 1}</span>
                <span class="text-black font-bold uppercase">${name}</span>
            </div>
            <span class="text-blue-800 font-bold">${score}</span>
        </div>
      `;
    }).join('');

  } catch (e) {
    container.innerHTML = '<div class="text-center text-red-400 text-xs">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</div>';
  }
}
</script>

</html>