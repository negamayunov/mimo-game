<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<meta charset="UTF-8"/>
<title>YA SNOVA MIMO – Good View & Crowds</title>
<style>
body{margin:0;overflow:hidden;background:#111;font-family:sans-serif;color:#fff}
canvas{display:block}
#ui{position:absolute;top:10px;left:10px;font-size:18px}
#msg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
     background:#0008;padding:30px 50px;font-size:28px;text-align:center;display:none}
#msg button{padding:10px 20px;font-size:20px;margin-top:15px;cursor:pointer}

#preloader{
  position:fixed; inset:0;
  background:#0a1030;
  color:#fff;
  font-family:sans-serif;
  display:flex; flex-direction:column;
  align-items:center; justify-content:center;
  gap:25px;
  z-index:10;
}
#preloader h1{ font-size:48px; margin:0 0 20px; }
#social{ display:flex; gap:20px; }
#social a{
  color:#fff; background:#ffffff20;
  padding:8px 16px; border-radius:6px;
  text-decoration:none; font-size:18px;
  transition:background .2s;
}
#social a:hover{ background:#ffffff40; }
#startBtn{
  font-size:24px; padding:12px 32px;
  border:none; border-radius:8px; cursor:pointer;
  background:#00ff88; color:#000;
}
#startBtn:disabled{ background:#666; cursor:not-allowed; }

#loadProgress{ appearance:none; }
#loadProgress::-webkit-progress-bar{ background:#222; }
#loadProgress::-webkit-progress-value{ background:#00ff88; }

.gateLabel{
  font-family:sans-serif;
  font-size:26px;
  font-weight:bold;
  color:#fff;
  text-align:center;
  width:100%;
  position:absolute;
  top:4px;
}
.gateValue{
  font-family:sans-serif;
  font-size:42px;
  font-weight:bold;
  color:#fff;
  text-align:center;
  width:100%;
  position:absolute;
  top:50%;
  transform:translateY(-50%);
}
</style>
</head>
<body>
<div id="ui">
  Fire rate: <span id="rate">1.0</span>/sec<br>
  Bullets / shot: <span id="count">1</span>
</div>
<div id="msg">
  <div id="msgText"></div>
  <button onclick="location.reload()">Restart</button>
</div>

<!-- preloader + menu -->
<div id="preloader">
  <h1>MIMO!</h1>

  <div id="social">
    <a href="https://t.me/gvozdi_band"  target="_blank">Telegram</a>
    <a href="https://vk.com/gvozdi_band" target="_blank">VK</a>
    <a href="https://www.youtube.com/channel/UCzNrI47UMc8ie3cnITUW-Dg" target="_blank">YouTube</a>
  </div>

  <button id="startBtn" disabled>Загрузка…</button>
  <progress id="loadProgress" value="0" max="100" style="width:200px;height:10px;"></progress>
  <span id="loadText">0 %</span>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ---------- preloader with progress ---------- */
const preEl      = document.getElementById('preloader');
const startBtn   = document.getElementById('startBtn');
const progressEl = document.getElementById('loadProgress');
const textEl     = document.getElementById('loadText');

let audioReady = false;
const audioSrc = 'song.mp3';            // ваш файл
const bgmEl    = new Audio();           // создаём динамически
bgmEl.loop = true;

// грузим fetch -> blob
fetch(audioSrc)
  .then(r => {
    if (!r.ok) throw new Error('network');
    const total = +r.headers.get('content-length');
    let loaded = 0;
    const reader = r.body.getReader();
    const stream = new ReadableStream({
      start(controller){
        function pump(){
          reader.read().then(({done, value}) => {
            if (done){
              controller.close();
              return;
            }
            loaded += value.byteLength;
            const pct = total ? (loaded / total * 100) : 0;
            progressEl.value = pct;
            textEl.textContent = `${Math.round(pct)} %`;
            controller.enqueue(value);
            pump();
          });
        }
        pump();
      }
    });
    return new Response(stream).blob();
  })
  .then(blob => {
    bgmEl.src = URL.createObjectURL(blob);
    audioReady = true;
    progressEl.value = 100;
    textEl.textContent = '100 %';
    startBtn.disabled = false;
    startBtn.textContent = 'Начать игру';
  })
  .catch(() => {
    // если файл недоступен – всё равно позволяем играть без звука
    startBtn.disabled = false;
    startBtn.textContent = 'Играть без звука';
  });

// старт
startBtn.addEventListener('click', () => {
  if (audioReady) bgmEl.play().catch(() => {});
  preEl.style.display = 'none';
  started = true;
});

/* ---------- basic scene ---------- */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0a1030, 15, 100);   // туман

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x0a1030);
document.body.appendChild(renderer.domElement);

/* свет */
const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); // сразу нужная яркость
dirLight.position.set(0, 10, 5);
scene.add(dirLight);

scene.add(new THREE.AmbientLight(0xffffff, 0.8)); // чуть усилим общий свет

/* ---------- player ---------- */
/* ---------- nail-hero ---------- */
const nailBody = new THREE.ConeGeometry(0.08, 1.0, 100);   // острый конус
const nailHead = new THREE.CylinderGeometry(0.18, 0.18, 0.15, 16);      // шляпка
const nailBodyMesh = new THREE.Mesh(nailBody);
const nailHeadMesh = new THREE.Mesh(nailHead);
const playerMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, metalness: 0.8, roughness: 0.2 });
nailBodyMesh.material = nailHeadMesh.material = playerMat;

nailBodyMesh.position.y = -0.5;   // острие внизу
nailHeadMesh.position.y = 0.075;   // поднимаем шляпку над стержнем (0.5 + 0.15/2)
nailBodyMesh.rotation.z = Math.PI;   // острие вниз

const player = new THREE.Group();  // теперь используем Group
player.add(nailBodyMesh);
player.add(nailHeadMesh);
scene.add(player);

player.rotation.x = 0;   // стоит вертикально вдоль оси Y
player.position.y = 0.8;           // центр модели на 0.8 — гвоздь над дорожкой



/* ---------- shooting params ---------- */
let fireRate = 1, bulletCount = 1, lastShot = 0;

/* ---------- bullets ---------- */
const bulletGeo  = new THREE.SphereGeometry(0.08,8,8);
const bigBulletGeo = new THREE.SphereGeometry(0.25,16,16);
const bullets = [];

/* ---------- enemies ---------- */
/* ---------- simple heart geometry ---------- */
function createHeartGeometry(size = 0.4){
  const shape = new THREE.Shape();
  const s = size;
  shape.moveTo(0, 0);
  shape.bezierCurveTo( s,  s,  2*s,  s,  2*s, -s);
  shape.bezierCurveTo( 2*s, -2*s,  s, -2.5*s, 0, -3*s);
  shape.bezierCurveTo(-s, -2.5*s, -2*s, -2*s, -2*s, -s);
  shape.bezierCurveTo(-2*s,  s, -s,  s, 0, 0);

  const extrudeSettings = { depth: 0.1, bevelEnabled: true, bevelThickness: 0.02, bevelSize: 0.02 };
  return new THREE.ExtrudeGeometry(shape, extrudeSettings);
}
const enemyGeo = createHeartGeometry(0.2);   // 0.2 ≈ прежний размер
const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff0040, roughness: 0.3, metalness: 0.2 });
const enemies = [];

/* ---------- gates ---------- */
const gateGeo = new THREE.BoxGeometry(2,2,0.2);
const gates = [];

const gateTypes = {
  ratePlus:   {label:'СКОРОСТЬ +0.5', action:'rate',  mode:'add',  val: 0.5},
  rateMinus:  {label:'СКОРОСТЬ -0.5', action:'rate',  mode:'add',  val:-0.5},
  rateMul2:   {label:'СКОРОСТЬ x2',    action:'rate',  mode:'mul',  val: 2},
  rateDiv2:   {label:'СКОРОСТЬ /2',    action:'rate',  mode:'mul',  val: 0.5},
  countPlus1: {label:'ПУЛИ +1',        action:'count', mode:'add',  val: 1},
  countMinus1:{label:'ПУЛИ -1',        action:'count', mode:'add',  val:-1},
  countMul2:  {label:'ПУЛИ x2',        action:'count', mode:'mul',  val: 2},
  countMul3:  {label:'ПУЛИ x3',        action:'count', mode:'mul',  val: 3}
};

/* ---------- dynamic spawning ---------- */
let lastSpawnZ = 0;
const SONG_LENGTH_SEC = 215;
const FPS = 60;
const levelLength = SONG_LENGTH_SEC * FPS;

/* ---------- infinite runway ---------- */
const RUNWAY_WIDTH  = 6;            // совпадает с диапазоном mouseX
const RUNWAY_LENGTH = 80;
const EDGE_HEIGHT   = 0.2;

const runwayMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
const edgeMat   = new THREE.MeshStandardMaterial({ color: 0xeeeeee });

/* геометрии остаются теми же */
const stripGeo = new THREE.PlaneGeometry(RUNWAY_WIDTH, RUNWAY_LENGTH);
const edgeGeo  = new THREE.BoxGeometry(0.1, EDGE_HEIGHT, RUNWAY_LENGTH); // тонкие бортики

// пул сегментов
const runwaySegments = [];
function createSegment(z){
  // полоса
  const strip = new THREE.Mesh(stripGeo, runwayMat);
  strip.rotation.x = -Math.PI / 2;
  strip.position.set(0, -0.5, z);
  scene.add(strip);

  // левый бортик
  const leftEdge = new THREE.Mesh(edgeGeo, edgeMat);
  leftEdge.position.set(-RUNWAY_WIDTH/2, -0.5 + EDGE_HEIGHT/2, z);
  scene.add(leftEdge);

  // правый бортик
  const rightEdge = new THREE.Mesh(edgeGeo, edgeMat);
  rightEdge.position.set( RUNWAY_WIDTH/2, -0.5 + EDGE_HEIGHT/2, z);
  scene.add(rightEdge);

  runwaySegments.push({ strip, leftEdge, rightEdge, centerZ: z });
}

// создаём первые два сегмента
createSegment(0);
createSegment(-RUNWAY_LENGTH);

// в main-loop (в конце animate(), перед renderer.render) добавьте:
function updateRunway(){
  const ahead = player.position.z - 2 * RUNWAY_LENGTH; // точка «на 2 сегмента» впереди игрока
  const last  = runwaySegments[runwaySegments.length - 1];

  // если последний сегмент ещё не настолько далеко, добавляем новый
  if (last.centerZ > ahead){
    createSegment(last.centerZ - RUNWAY_LENGTH);
  }

  // удаляем старые сегменты, которые уже позади камеры
  for (let i = runwaySegments.length - 1; i >= 0; i--){
    const seg = runwaySegments[i];
    if (seg.centerZ > player.position.z + 60){
      scene.remove(seg.strip);
      scene.remove(seg.leftEdge);
      scene.remove(seg.rightEdge);
      runwaySegments.splice(i, 1);
    }
  }
}

function spawnWave(){
  /* 1. мощность и кол-во */
  const power     = Math.min(1, (fireRate - 0.5)/4 + (bulletCount - 1)/10);
  const crowdSize = 3 + Math.floor(power * power * 100 * difficultyFactor);

  /* 2. выбираем сторону кластера */
  const side     = Math.random() < 0.5 ? -1 : 1; // -1 = лево, +1 = право
  const clusterX = side * (1 + Math.random() * 2);
  const clampedClusterX = THREE.MathUtils.clamp(clusterX, -2.5, 2.5); // не выходит за бортики
  const spawnZ   = lastSpawnZ - 20;

  lastSpawnZ = spawnZ;

  /* 3. спавним кучно */
  for (let i = 0; i < crowdSize; i++){
    const e = new THREE.Mesh(enemyGeo, enemyMat);
    e.position.set(
      clampedClusterX + (Math.random()-0.5)*1.5,
      0,
      spawnZ + (Math.random()-0.5)*8
    );
    scene.add(e); enemies.push(e);
    e.position.y = 0.3;          // приподнять над дорожкой
    e.lookAt(player.position.x, 0.3, player.position.z); // «смотрит» на игрока
  }

/* ---------- gates (strict lane, same Z) ---------- */
if (Math.random() < 0.7) {
  const keys = Object.keys(gateTypes);

  const gateWidth = RUNWAY_WIDTH / 2;   // 3
  const countGates = Math.random() < 0.6 ? 1 : 2; // 1 или 2
  const spawnZGate = spawnZ + Math.random() * 10;   // общая Z для пары

  [-1, 1].slice(0, countGates).forEach(side => {
    const k    = keys[Math.floor(Math.random()*keys.length)];
    const data = gateTypes[k];

    const gateGroup = new THREE.Group();
    gateGroup.userData = data;

    /* полупрозрачная панель новой ширины */
    const panelMat = new THREE.MeshStandardMaterial({
      color      : data.action === 'rate' ? 0x00ffff : 0xff00ff,
      transparent: true,
      opacity    : 0.35
    });
    const panel = new THREE.Mesh(new THREE.PlaneGeometry(gateWidth, 2), panelMat);
    panel.position.z = 0.01;
    gateGroup.add(panel);

    /* белая рамка */
    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.PlaneGeometry(gateWidth, 2)),
      new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    edges.position.z = 0.02;
    gateGroup.add(edges);

    /* текст-Canvas */
    const canvas = document.createElement('canvas');
    canvas.width  = 384;   // 3 * 128
    canvas.height = 256;   // 2 * 128  → 3:2 пропорция
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#0008';
    ctx.fillRect(0, 0, 384, 256);

    /* первая строка */
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 36px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.fillText(data.label.split(' ')[0], 192, 20);

    /* вторая строка */
    ctx.font = 'bold 60px sans-serif';
    ctx.textBaseline = 'middle';
    ctx.fillText(data.label.replace(/^.*?\s/, ''), 192, 128);

    const tex = new THREE.CanvasTexture(canvas);
    const textPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(gateWidth, 2),  // та же 3×2
      new THREE.MeshBasicMaterial({ map: tex, transparent: true })
    );
    textPlane.position.z = 0.03;
    gateGroup.add(textPlane);

    /* свечение */
    const isPositive = (data.mode === 'add' && data.val > 0) ||
                       (data.mode === 'mul' && data.val > 1) ||
                       (data.val === 3);
    const color = isPositive ? 0x00ff00 : 0xff0000;
    const light = new THREE.PointLight(color, 1.2, 6);
    light.position.set(0, 0.5, 0);
    gateGroup.add(light);

    const glowMat = new THREE.MeshBasicMaterial({
      color, transparent: true, opacity: 0.25, side: THREE.DoubleSide
    });
    const glowPlane = new THREE.Mesh(new THREE.PlaneGeometry(gateWidth + 0.2, 2.2), glowMat);
    glowPlane.position.z = -0.05;
    gateGroup.add(glowPlane);

    /* позиция: ровно по краю полосы */
    gateGroup.position.set(side * (RUNWAY_WIDTH / 4), 0, spawnZGate);
    scene.add(gateGroup);
    gates.push(gateGroup);
  });
}
}

/* ---------- controls ---------- */
let mouseX = 0;
window.addEventListener('mousemove', e => mouseX = (e.clientX/innerWidth - 0.5) * 6);

window.addEventListener('touchmove', e => {
  const touch = e.touches[0];
  mouseX = (touch.clientX / innerWidth - 0.5) * 6;
}, { passive: true });

/* ---------- camera ---------- */
camera.position.set(0,5,6);                       // <-- ближе
camera.lookAt(0,-1,player.position.z - 3);        // <-- ниже и точнее

let speed = 0.1, started = false, gameOver = false;
// document.addEventListener('click', () => {
//   if (!started){ document.getElementById('bgm').play(); started = true; }
// });

/* ---------- shooting ---------- */
function shoot(time){
  if (!started || gameOver) return;
  if (time - lastShot < 1000 / fireRate) return;
  lastShot = time;

  const useBig = bulletCount >= 10;
  const geo = useBig ? bigBulletGeo : bulletGeo;
  const mat = useBig
    ? new THREE.MeshStandardMaterial({color:0xff8800})
    : new THREE.MeshStandardMaterial({color:0xffff00});
  const count = useBig ? 1 : bulletCount;

  for (let i = 0; i < count; i++){
    const b = new THREE.Mesh(geo, mat);
    const angle = 0;                                   // <-- ровно вперёд
    const spd = 0.4;
    b.position.set(
      player.position.x + (i - (count - 1) / 2) * 0.4, // горизонтальный разброс
      0,
      player.position.z - 0.5
    );
    scene.add(b);
    bullets.push({mesh:b, vx:0, vz:-spd});              // летят строго вперёд
  }
}

/* ---------- game-over screen ---------- */
function showMsg(text){
  document.getElementById('msgText').innerText = text;
  document.getElementById('msg').style.display = 'block';
}

/* ---------- enemy AI ---------- */
const DETECT_DISTANCE = 20;   // на каком расстоянии враг замечает игрока
const ENEMY_SPEED     = 0.1; // базовая скорость врага
const difficultyFactor = 0.5;   // <-- крутите этим для сложности (0.5–2.0)

function updateEnemiesAI(){
  enemies.forEach(e=>{
    const dist = e.position.distanceTo(player.position);
    if (dist < DETECT_DISTANCE){
      // направление к игроку
      const dir = new THREE.Vector3().subVectors(player.position, e.position).normalize();
      dir.y = 0; // не летим вверх
      dir.z *= 0.2; // не летим вперёд
      // ускорение пропорционально difficultyFactor
      e.position.addScaledVector(dir, ENEMY_SPEED * difficultyFactor);
    }
  });
}

/* ---------- main loop ---------- */
function animate(time){
  requestAnimationFrame(animate);
  if (!started || gameOver) return;

  /*  ✔  ИСПРАВЛЕНИЕ 1: всегда вызываем shoot  */
  shoot(time);

  /* player movement */
  player.position.x += (mouseX - player.position.x) * 0.1;
  player.position.x = THREE.MathUtils.clamp(player.position.x, -3, 3); // <-- новая строка
  player.position.z -= speed;

  /* наклон гвоздя в сторону движения */
  const tilt = (mouseX - player.position.x) * 0.15; // чем больше разница, тем сильнее наклон
  player.rotation.z = THREE.MathUtils.clamp(tilt, -0.4, 0.4);

  updateEnemiesAI();

  /* continuous spawning */
  if (player.position.z - 20 < lastSpawnZ){
    spawnWave();
  }

  /* bullets */
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.mesh.position.x += b.vx;
    b.mesh.position.z += b.vz;
    if (b.mesh.position.length() > levelLength + 50){
      scene.remove(b.mesh); bullets.splice(i,1);
    }
  }

  /* bullet–enemy collision */
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i].mesh;
    for (let j = enemies.length - 1; j >= 0; j--){
      const e = enemies[j];
      const hitDist = bulletCount >= 10 ? 1 : 0.5;
      if (b.position.distanceTo(e.position) < hitDist){
        scene.remove(b); bullets.splice(i,1);
        scene.remove(e); enemies.splice(j,1);
        break;
      }
    }
  }

  /* player–enemy collision */
  for (const e of enemies){
    if (e.position.distanceTo(player.position) < 0.7){
      gameOver = true; showMsg('Game Over!'); return;
    }
  }

  /* player–gate collision */
  gates.forEach((g, idx) => {
    if (g.position.distanceTo(player.position) < 1.5){
      const d = g.userData;
      if (d.action === 'rate'){
        if (d.mode === 'add') fireRate  = Math.max(0.2, fireRate  + d.val);
        else                  fireRate  = Math.max(0.2, fireRate  * d.val);
      }
      if (d.action === 'count'){
        let newVal = bulletCount;
        if (d.mode === 'add') newVal += d.val;
        else                  newVal *= d.val;
        if (d.max) newVal = Math.min(newVal, d.max);
        bulletCount = Math.max(1, Math.floor(newVal));
      }
      document.getElementById('rate').textContent  = fireRate.toFixed(1);
      document.getElementById('count').textContent = bulletCount;
      scene.remove(g); gates.splice(idx,1);
    }
  });

  /* win condition */
  if (player.position.z < -levelLength){
    gameOver = true; showMsg('You Win!'); return;
  }

  /* camera follow */
  camera.position.x = player.position.x;
  camera.position.z = player.position.z + 9;
  camera.lookAt(player.position.x, player.position.y, player.position.z - 3);
  updateRunway();
  
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>