<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<meta charset="UTF-8"/>
<title>YA SNOVA MIMO – Good View & Crowds</title>
<style>
body{margin:0;overflow:hidden;background:#111;font-family:sans-serif;color:#fff}
canvas{display:block}
#ui{position:absolute;top:10px;left:10px;font-size:18px}
#msg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
     background:#0008;padding:30px 50px;font-size:28px;text-align:center;display:none}
#msg button{padding:10px 20px;font-size:20px;margin-top:15px;cursor:pointer}

#preloader{
  position:fixed; inset:0;
  background:#0a1030;
  color:#fff;
  font-family:sans-serif;
  display:flex; flex-direction:column;
  align-items:center; justify-content:center;
  gap:25px;
  z-index:10;
}
#preloader h1{ font-size:48px; margin:0 0 20px; }
#social{ display:flex; gap:20px; }
#social a{
  color:#fff; background:#ffffff20;
  padding:8px 16px; border-radius:6px;
  text-decoration:none; font-size:18px;
  transition:background .2s;
}
#social a:hover{ background:#ffffff40; }
#startBtn{
  font-size:24px; padding:12px 32px;
  border:none; border-radius:8px; cursor:pointer;
  background:#00ff88; color:#000;
}
#startBtn:disabled{ background:#666; cursor:not-allowed; }

#loadProgress{ appearance:none; }
#loadProgress::-webkit-progress-bar{ background:#222; }
#loadProgress::-webkit-progress-value{ background:#00ff88; }

#progressBar{
  position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
  width:60%; height:6px; background:#222; border-radius:3px;
  overflow:hidden; z-index:5;
}
#progressFill{
  height:100%; width:0%; background:#00ff88; transition:width 0.1s;
}

.gateLabel{
  font-family:sans-serif;
  font-size:26px;
  font-weight:bold;
  color:#fff;
  text-align:center;
  width:100%;
  position:absolute;
  top:4px;
}
.gateValue{
  font-family:sans-serif;
  font-size:42px;
  font-weight:bold;
  color:#fff;
  text-align:center;
  width:100%;
  position:absolute;
  top:50%;
  transform:translateY(-50%);
}

</style>
</head>
<body>
<div id="ui">
  Гвоздей: <span id="count">1</span> |
  Уровней: <span id="levels">1</span><br>
  Скорость стрельбы: <span id="rate">1.0</span>/сек
  <!-- Пробив.: <span id="pierce">1</span><br> -->
  Дальность: <span id="range">15</span>
</div>

<!-- <div id="best-stats" style="position:absolute; top:10px; right:10px; font-size:18px;">
  Лучшие параметры:<br>
  Гвоздей: <span id="best-count">1</span><br>
  Уровней: <span id="best-levels">1</span><br>
  Скорость стрельбы: <span id="best-rate">1.0</span>/сек<br>
  Дальность: <span id="best-range">15</span><br>
  Текущий урон: <span id="cur-dmg">0</span><br>
  Лучший урон: <span id="best-dmg">0</span>
</div> -->

<div id="msg">
  <div id="msgText"></div>
  <button onclick="location.reload()">Restart</button>
</div>
<div id="progressBar">
  <div id="progressFill"></div>
</div>

<!-- preloader + menu -->
<div id="preloader">
  <h1>MIMO!</h1>

  <div id="social">
    <a href="https://t.me/gvozdi_band"  target="_blank">Telegram</a>
    <a href="https://vk.com/gvozdi_band" target="_blank">VK</a>
    <a href="https://www.youtube.com/channel/UCzNrI47UMc8ie3cnITUW-Dg" target="_blank">YouTube</a>
  </div>

  <button id="startBtn" disabled>Загрузка…</button>
  <progress id="loadProgress" value="0" max="100" style="width:200px;height:10px;"></progress>
  <span id="loadText">0 %</span>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ---------- TEXTURE CACHE ---------- */
const textureCache = new Map();   // key → CanvasTexture
function getTexture(key, drawFn) {
  if (!textureCache.has(key)) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    drawFn(ctx);                 // ← вот тут ctx передаётся в твою функцию
    textureCache.set(key, new THREE.CanvasTexture(canvas));
  }
  return textureCache.get(key);
}

/* ---------- preloader with progress ---------- */
const preEl      = document.getElementById('preloader');
const startBtn   = document.getElementById('startBtn');
const progressEl = document.getElementById('loadProgress');
const textEl     = document.getElementById('loadText');

let audioReady = false;
const audioSrc = 'song.mp3';            // ваш файл
const bgmEl    = new Audio();           // создаём динамически
bgmEl.loop = true;

// грузим fetch -> blob
fetch(audioSrc)
  .then(r => {
    if (!r.ok) throw new Error('network');
    const total = +r.headers.get('content-length');
    let loaded = 0;
    const reader = r.body.getReader();
    const stream = new ReadableStream({
      start(controller){
        function pump(){
          reader.read().then(({done, value}) => {
            if (done){
              controller.close();
              return;
            }
            loaded += value.byteLength;
            const pct = total ? (loaded / total * 100) : 0;
            progressEl.value = pct;
            textEl.textContent = `${Math.round(pct)} %`;
            controller.enqueue(value);
            pump();
          });
        }
        pump();
      }
    });
    return new Response(stream).blob();
  })
  .then(blob => {
    bgmEl.src = URL.createObjectURL(blob);
    audioReady = true;
    progressEl.value = 100;
    textEl.textContent = '100 %';
    startBtn.disabled = false;
    startBtn.textContent = 'Начать игру';
  })
  .catch(() => {
    // если файл недоступен – всё равно позволяем играть без звука
    startBtn.disabled = false;
    startBtn.textContent = 'Играть без звука';
  });

// старт
startBtn.addEventListener('click', () => {
  if (audioReady) bgmEl.play().catch(() => {});
  preEl.style.display = 'none';
  started = true;
  songStartTime = performance.now(); // фиксируем старт
});

/* ---------- basic scene ---------- */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0a1030, 15, 100);   // туман

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x0a1030);
document.body.appendChild(renderer.domElement);

/* свет */
const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); // сразу нужная яркость
dirLight.position.set(0, 10, 5);
scene.add(dirLight);

scene.add(new THREE.AmbientLight(0xffffff, 0.8)); // чуть усилим общий свет

/* ---------- player ---------- */
/*  NEW  */
const nailBody = new THREE.ConeGeometry(0.08, 1.0, 100);
const nailHead = new THREE.CylinderGeometry(0.18, 0.18, 0.15, 16);
const playerMat = new THREE.MeshStandardMaterial({
  color: 0xc0c0c0, metalness: 0.8, roughness: 0.2
});

/* массив, куда будем складывать группы-гвозди */
const nailGroup = new THREE.Group();   // на сцене только эта группа
scene.add(nailGroup);

/* ---------- CROWD-LEVEL BANNER (сцена, не группа) ---------- */
const bannerCanvas = document.createElement('canvas');
bannerCanvas.width = 256; bannerCanvas.height = 128;
const bannerCtx = bannerCanvas.getContext('2d');

const bannerTex = new THREE.CanvasTexture(bannerCanvas);
const bannerMat = new THREE.MeshBasicMaterial({ map: bannerTex, transparent: true });
const bannerGeo = new THREE.PlaneGeometry(0.8, 0.4);
const bannerMesh = new THREE.Mesh(bannerGeo, bannerMat);

bannerMesh.position.set(0, 2.2, 0); // временная, будет обновляться в animate
scene.add(bannerMesh);

/* ------------- перераспределение уровней ------------- */
function redistributeLevels() {
  const total = nailLevels.reduce((a, b) => a + b, 0);
  const avg   = Math.ceil(total / nailCount);

  nailLevels = Array(nailCount).fill(avg);
  bestNailCount = Math.max(bestNailCount, nailCount);
  bestNailLevelSum = Math.max(bestNailLevelSum, nailLevels.reduce((a,b)=>a+b,0));
}

/* функция пересборки толпы */
function rebuildNailFormation(){
  // удаляем старые меши
  while (nailGroup.children.length){
    nailGroup.remove(nailGroup.children[0]);
  }

  const spacing = 0.5;   // расстояние между центрами

  for (let i = 0; i < nailCount; i++){
    const body = new THREE.Mesh(nailBody, playerMat);
    const head = new THREE.Mesh(nailHead, playerMat);

    body.position.y = 0;
    head.position.y = 0.575;
    body.rotation.z = Math.PI;

    const single = new THREE.Group();
    const level = nailLevels[i] || 1;

    single.add(body);
    single.add(head);

    // расставляем в одну линию по X
    const offset = (i - (nailCount - 1) / 2) * spacing;
    single.position.x = offset;

    // цветом показываем уровень (по желанию)
    // цвет для всего гвоздя (и стержня, и шляпки)
    const nailMat = playerMat.clone();
    const hue = 0.44 + (level - 1) * 0.8;  // 0 = серый, дальше идёт в зелёный / оранжевый
    nailMat.color.setHSL(hue, 0.9, 0.8);
    body.material = nailMat;
    head.material = nailMat;

    nailGroup.add(single);
  }

  /* update banner text */
  const totalLevel = nailLevels.reduce((a, b) => a + b, 0);
  bannerMat.map = getTexture(`level_${totalLevel}`, (ctx) => {
    ctx.canvas.width = 256; ctx.canvas.height = 128;
    ctx.fillStyle = '#000a';
    ctx.fillRect(0, 0, 256, 128);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = 'bold 64px sans-serif';
    ctx.textBaseline = 'middle';
    ctx.fillText(totalLevel.toString(), 128, 64);
  });
  bannerMat.map.needsUpdate = true;
}

/* ---------- shooting params ---------- */
let fireRate = 1;
let lastShot = 0;
let fireRange = 15; // изначально маленькая дальность (можно менять)

/*  NEW  */
const MAX_NAILS   = 5;
let nailCount   = 1;
let nailLevels  = [1];
// ---------- лучший возможный набор игрока ----------
let bestFireRate = 1;
let bestFireRange = 15;
let bestNailCount = 1;
let bestNailLevelSum = 1;   // сумма уровней

const RUNWAY_WIDTH  = 6;            // совпадает с диапазоном mouseX
const RUNWAY_LENGTH = 80;
const EDGE_HEIGHT   = 0.2;
const gateWidth = RUNWAY_WIDTH / 2;
const narrowGateWidth = RUNWAY_WIDTH / 3;

// ---------- utility-функция по новому правилу ----------
function utility(gate, current, twin) {
  // 1. если action совпадает — выигрывает тот, кто добавит больше к текущему параметру
  if (gate.action === twin.action) {
    switch (gate.action) {
      case 'rate':  return current.rate * gate.val;
      case 'range': return current.range * gate.val;
      case 'count': return current.count * gate.val;
      case 'level': return current.count * gate.val; // аналогично
      default:      return gate.val;
    }
  }

  // 2. action разные — старая приоритетная шкала
  const prio = {
    level: 900,
    count: (gate.val === 2 ? 950 : 800),
    rate:  gate.val * 300,
    range: (gate.mode === 'mul' ? 450 : gate.val * 200)
  };
  return prio[gate.action] || 0;
}

function calcWallHP(delta) {
  /* 1. Суммарный урон за ОДИН залп */
  const totalPierce = nailLevels.reduce((a, b) => a + b, 0);

  /* 2. Сколько залпов успеет выпустить игрок, пока цель в досягаемости
       = дальность / скорость пули  (пули летят 0.4 ед/кадр @ 60 fps ≈ 24 ед/сек) */
  const bulletSpeed = 0.4 / delta;          // единиц в секунду
  const timeInRange = fireRange / bulletSpeed;

  /* 3. Сколько залпов за это время */
  const shotsFired  = Math.max(1, fireRate * timeInRange);

  /* 4. Полный урон */
  const fullDmg = totalPierce * shotsFired;

  /* 5. Средний урон (текущий + лучший) */
  const bestTotal = bestNailLevelSum;
  const bestShots = Math.max(1, bestFireRate * (bestFireRange / bulletSpeed));
  const bestDmg   = bestTotal * bestShots;

  let baseDmg = (fullDmg + bestDmg) / 2;

  /* 6. Случайные коэффициенты */
  const rand1 = 0.7 + Math.random() * 0.3;
  let hp      = baseDmg * rand1;

  // НЕПРОБИВАЕМАЯ стена (как минимум, в 2 раза больше жизней, чем средний урон)
  const rand2 = Math.random() < 0.3 ? (2 + Math.random() * 10) : 1;
  hp *= rand2;

  // обновляем UI урон
  // document.getElementById('cur-dmg').textContent  = Math.round(fullDmg);
  // document.getElementById('best-dmg').textContent = Math.round(bestDmg);
  hp = Math.max(1, Math.round(hp) + 4);

  return { hp, rand2 }; 
}

/* ---------- RUNTIME FLAGS ---------- */
let started   = false;
let gameOver  = false;
let songStartTime = 0;            // момент, когда нажали «Начать»
const SONG_DURATION = 215;        // секунды

rebuildNailFormation();   // создаём первий гвоздь

/* ---------- bullets ---------- */
const bulletGeo  = new THREE.SphereGeometry(0.08,8,8);
const bigBulletGeo = new THREE.SphereGeometry(0.25,16,16);
// ⚡ 2. Shared bullet materials
const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
const bigBulletMat = new THREE.MeshStandardMaterial({ color: 0xff8800 });

const bullets = [];

/* ---------- enemies ---------- */
/* ---------- shared heart geometry ---------- */
const _heartShape = new THREE.Shape();
((s = _heartShape) => {
  s.moveTo(5, 5);
  s.bezierCurveTo(5, 5, 4, 0, 0, 0);
  s.bezierCurveTo(-6, 0, -6, 7, -6, 7);
  s.bezierCurveTo(-6, 11, -3, 15.4, 5, 19);
  s.bezierCurveTo(12, 15.4, 16, 11, 16, 7);
  s.bezierCurveTo(16, 7, 16, 0, 10, 0);
  s.bezierCurveTo(7, 0, 5, 5, 5, 5);
})();

const heartGeo = new THREE.ExtrudeGeometry(_heartShape, 8);
heartGeo.center();
heartGeo.scale(0.05, 0.05, 0.05); // 0.4 / 4 = 0.1, но ещё ×0.5 чтобы ≈0.2 размер
heartGeo.rotateZ(Math.PI);

/* ---------- стенка ---------- */
const wallGeo = new THREE.BoxGeometry(RUNWAY_WIDTH / 3, 2, 0.3);
const wallMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  transparent: true,
  opacity: 0.6,
  roughness: 0.1,
  metalness: 0.2,
  transmission: 0.7
});
const walls = [];
/* ---------- RUNWAY POOL (без new Mesh каждый кадр) ---------- */
const RUNWAY_POOL_SIZE = 6;               // 6 сегментов достаточно
const runwayPool = [];                    // {mesh, inUse, centerZ}
const runwayMat  = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
const edgeMat    = new THREE.MeshStandardMaterial({ color: 0xeeeeee });

// создаём сразу все меши один раз
for (let i = 0; i < RUNWAY_POOL_SIZE; i++) {
  const strip   = new THREE.Mesh(new THREE.PlaneGeometry(RUNWAY_WIDTH, RUNWAY_LENGTH), runwayMat);
  strip.rotation.x = -Math.PI / 2;

  const leftEdge  = new THREE.Mesh(new THREE.BoxGeometry(0.1, EDGE_HEIGHT, RUNWAY_LENGTH), edgeMat);
  const rightEdge = new THREE.Mesh(new THREE.BoxGeometry(0.1, EDGE_HEIGHT, RUNWAY_LENGTH), edgeMat);

  // спрятать за кадром
  strip.position.set(0, -0.5, 9999);
  leftEdge.position.set(-RUNWAY_WIDTH/2, -0.5 + EDGE_HEIGHT/2, 9999);
  rightEdge.position.set( RUNWAY_WIDTH/2, -0.5 + EDGE_HEIGHT/2, 9999);

  scene.add(strip, leftEdge, rightEdge);

  runwayPool.push({
    strip, leftEdge, rightEdge,
    inUse: false,
    centerZ: 0
  });
}

/* ---------- обновление дорожки без new Mesh ---------- */
function updateRunway() {
  // ставим новые сегменты впереди
  const ahead = nailGroup.position.z - 2 * RUNWAY_LENGTH;
  let lastZ = -Infinity;
  runwayPool.filter(r => r.inUse).forEach(r => lastZ = Math.max(lastZ, r.centerZ));

  if (!isFinite(lastZ) || lastZ > ahead) {
    const free = runwayPool.find(r => !r.inUse);
    if (free) {
      const z = isFinite(lastZ) ? lastZ - RUNWAY_LENGTH : 0;
      free.strip.position.z   = z;
      free.leftEdge.position.z = z;
      free.rightEdge.position.z = z;
      free.centerZ = z;
      free.inUse = true;
    }
  }

  // прячем старые
  runwayPool.forEach(r => {
    if (r.inUse && r.centerZ > nailGroup.position.z + 60) {
      r.inUse = false;
      // прячем за кадром, чтобы не мешали
      r.strip.position.z = 9999;
      r.leftEdge.position.z = 9999;
      r.rightEdge.position.z = 9999;
    }
  });
}

const enemyGeo = heartGeo;   // shared
const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff0040, roughness: 0.3, metalness: 0.2 });
let enemies = [];
let enemyLabels = []; // { group, mesh, initial }

/* ---------- gates ---------- */
const gateGeo = new THREE.BoxGeometry(2,2,0.2);
const gates = [];

/* ---------- Gate registry (scalable) ---------- */
const gateRegistry = [
  { weight: 1,  factory: () => ({ label: 'УРОВЕНЬ +1', action: 'level', val: 1 }) },
  { weight: 10, factory: () => ({ label: 'УРОВЕНЬ -1', action: 'level', val: -1 }) },
  { weight: 15, factory: () => ({ label: 'ГВОЗДИ +1', action: 'count', val: 1 }) },
  { weight: 1,  factory: () => ({ label: 'ГВОЗДИ +2', action: 'count', val: 2 }) },
  { weight: 15, factory: () => ({ label: 'ГВОЗДИ -1', action: 'count', val: -1 }) },

  { weight: 15, factory: () => {
      const base = 0.25 * (1 + Math.floor(Math.random() * 4)); // 0.25…1
      const mult = [0.5, 0.75, 1, 1.5, 2][Math.floor(Math.random() * 5)];
      const total = +(base * mult).toFixed(2);
      return { label: `СТРЕЛЬБА ${total >= 0 ? '+' : ''}${total}`, action: 'rate', val: total };
    }
  },
  { weight: 10, factory: () => ({ label: 'СТРЕЛЬБА -0.5', action: 'rate', val: -0.5 }) },

  { weight: 15, factory: () => {
      const val = 1 + Math.floor(Math.random() * 3); // 1…3
      return { label: `ДАЛЬНОСТЬ +${val}`, action: 'range', val };
    }
  },
  { weight: 10, factory: () => ({ label: 'ДАЛЬНОСТЬ -2', action: 'range', val: -2 }) },
  { weight: 5,  factory: () => ({ label: 'ДАЛЬНОСТЬ /2', action: 'range', mode: 'mul', val: 0.5 }) },
  { weight: 5,  factory: () => ({ label: 'ДАЛЬНОСТЬ ×1.2', action: 'range', mode: 'mul', val: 1.2 }) },
];

/* ---------- build cumulative distribution once ---------- */
let totalWeight = 0;
const cdf = [];
gateRegistry.forEach(({ weight, factory }) => {
  totalWeight += weight;
  cdf.push({ limit: totalWeight, factory });
});

/* ---------- universal picker ---------- */
function pickGate() {
  const roll = Math.random() * totalWeight;
  for (const { limit, factory } of cdf) {
    if (roll < limit) return factory();
  }
  return cdf[cdf.length - 1].factory(); // should never happen
}

/* ---------- dynamic spawning ---------- */
let lastSpawnZ = 0;
let lastObjectZ = 0;          // последняя занятая Z-координата объектов
const MIN_GAP = 3;            // минимальное расстояние между объектами

const SONG_LENGTH_SEC = 215;
const FPS = 60;
const levelLength = SONG_LENGTH_SEC * FPS;

function spawnGate(side, z, data){
  const gateGroup = new THREE.Group();
  gateGroup.userData = data;

  const isPositive =
  (data.mode === 'mul')
    ? data.val > 1
    : data.val > 0;

    /* полупрозрачная панель новой ширины */
    const panelMat = new THREE.MeshStandardMaterial({
      color      : isPositive ? 0x00ff00 : 0xff0000,
      transparent: true,
      opacity    : 0.3
    });
    const panel = new THREE.Mesh(new THREE.PlaneGeometry(gateWidth, 2), panelMat);
    panel.position.z = 0.01;
    gateGroup.add(panel);

    /* белая рамка */
    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.PlaneGeometry(gateWidth, 2)),
      new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    edges.position.z = 0.02;
    gateGroup.add(edges);

  /* ---------- текст-Canvas ---------- */
    const canvas = document.createElement('canvas');
    canvas.width  = 384;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');

    const [topText, bottomText] = data.label.includes(' ')
  ? data.label.split(' ')
  : ['ГЕЙТ', data.label];

    ctx.fillStyle = '#000a';
    ctx.fillRect(0, 0, 384, 256);
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';

    ctx.font = 'bold 42px sans-serif';
    ctx.textBaseline = 'top';
    ctx.fillText(topText, 192, 25);

    ctx.font = 'bold 72px sans-serif';
    ctx.textBaseline = 'middle';
    ctx.fillText(bottomText, 192, 140);


    const tex = new THREE.CanvasTexture(canvas);
    const textPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(gateWidth, 2),  // та же 3×2
      new THREE.MeshBasicMaterial({ map: tex, transparent: true })
    );
    textPlane.position.z = 0.03;
    gateGroup.add(textPlane);

    /* свечение */

    const color = isPositive ? 0x00ff00 : 0xff0000;
    const light = new THREE.PointLight(color, 1.2, 6);
    light.position.set(0, 0.5, 0);
    gateGroup.add(light);

    const glowMat = new THREE.MeshBasicMaterial({
      color, transparent: true, opacity: 0.25, side: THREE.DoubleSide
    });
    const glowPlane = new THREE.Mesh(new THREE.PlaneGeometry(gateWidth + 0.2, 2.2), glowMat);
    glowPlane.position.z = -0.05;
    gateGroup.add(glowPlane);

    /* позиция: ровно по краю полосы */
    gateGroup.position.set(side * (RUNWAY_WIDTH / 4), 0, z);
    scene.add(gateGroup);
    gates.push(gateGroup);
  };

  function spawnNarrowGate(posX, posZ, data){
    const gateGroup = new THREE.Group();
    gateGroup.userData = data;

    /* полупрозрачная панель – узкая */
    const panelMat = new THREE.MeshStandardMaterial({
      color: 0x00ff00,
      transparent: true,
      opacity: 0.3
    });
    const panel = new THREE.Mesh(
      new THREE.PlaneGeometry(narrowGateWidth, 2),
      panelMat
    );
    panel.position.z = 0.01;
    gateGroup.add(panel);

    /* белая рамка */
    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.PlaneGeometry(narrowGateWidth, 2)),
      new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    edges.position.z = 0.02;
    gateGroup.add(edges);

    /* текст без растяжения */
    const canvasW = 320;   // 400 * 0.8
    const canvasH = 320;
    const canvas = document.createElement('canvas');
    canvas.width  = canvasW;
    canvas.height = canvasH;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#000a';
    ctx.fillRect(0, 0, canvasW, canvasH);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';

    const parts = data.label.includes(' ') ? data.label.split(' ') : ['ГЕЙТ', data.label];

    ctx.font = 'bold 56px sans-serif';   // 70 * 0.8
    ctx.textBaseline = 'top';
    ctx.fillText(parts[0], canvasW / 2, 48);   // 60 * 0.8

    ctx.font = 'bold 88px sans-serif';   // 110 * 0.8
    ctx.textBaseline = 'middle';
    ctx.fillText(parts[1] || '', canvasW / 2, canvasH / 2 + 32);   // 40 * 0.8

    const tex = new THREE.CanvasTexture(canvas);
    const textPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(narrowGateWidth, 2),   // геометрия та же
      new THREE.MeshBasicMaterial({ map: tex, transparent: true })
    );
    textPlane.position.z = 0.03;
    gateGroup.add(textPlane);

    /* свечение и позиция */
    const light = new THREE.PointLight(0x00ff00, 1.2, 6);
    light.position.set(0, 0.5, 0);
    gateGroup.add(light);

    const glowMat = new THREE.MeshBasicMaterial({
      color: 0x00ff00, transparent: true, opacity: 0.25, side: THREE.DoubleSide
    });
    const glowPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(narrowGateWidth + 0.2, 2.2),
      glowMat
    );
    glowPlane.position.z = -0.05;
    gateGroup.add(glowPlane);

    gateGroup.position.set(posX, 0, posZ);
    scene.add(gateGroup);
    gates.push(gateGroup);
  }

  function applyGate(data) {
    if (data.action === 'rate') {
      fireRate = Math.max(0.2, fireRate + data.val);
    }
    if (data.action === 'range') {
      if (data.mode === 'mul') {
        fireRange = Math.max(1, fireRange * data.val);
      } else {
        fireRange = Math.max(1, fireRange + data.val);
      }
      rebuildNailFormation();
    }
    if (data.action === 'count') {
      if (data.val === -1 && nailCount === 1) {
        gameOver = true;
        showMsg('Game Over!');
        return true; // сигнал "конец"
      }
      if (data.val > 0) {
        if (data.val === 2 && nailCount === 4) {
          nailCount = 5;
          nailLevels.push(1);
          nailLevels.forEach((_, i) => nailLevels[i]++);
        } else if (nailCount === MAX_NAILS) {
          nailLevels.forEach((_, i) => nailLevels[i]++);
        } else {
          const maxLevel = Math.max(...nailLevels, 1);
          for (let i = 0; i < data.val; i++) nailLevels.push(maxLevel);
          nailCount += data.val;
        }
        redistributeLevels();
      } else {
        nailCount = Math.max(1, nailCount + data.val);
        for (let i = 0; i < -data.val; i++) nailLevels.pop();
        redistributeLevels();
      }
      rebuildNailFormation();
    }
    if (data.action === 'level') {
      for (let i = 0; i < nailCount; i++) {
        nailLevels[i] = Math.max(1, nailLevels[i] + data.val);
      }
      rebuildNailFormation();
    }

    // обновляем UI
    document.getElementById('count').textContent  = nailCount;
    document.getElementById('levels').textContent = nailLevels.reduce((a,b)=>a+b,0);
    document.getElementById('rate').textContent   = fireRate.toFixed(1);
    document.getElementById('range').textContent = fireRange.toFixed(1);
    return false;
  }

  function createWall(pos, z, delta) {
    const wall = new THREE.Mesh(wallGeo, wallMat.clone());
    wall.position.set(pos, 0, z);

    // HP
    const wallData = calcWallHP(delta);
    wall.userData.hp = wallData.hp;
    wall.userData.rand2 = wallData.rand2;

    // --- временная окраска непробиваемых ---
    if (wallData.rand2 > 1) {
      wall.material.color.set(0xff0000);
      wall.material.emissive.set(0x770000);
    }

    const hp = wall.userData.hp;
        wall.material.map = getTexture(`hp_${hp}`, (ctx) => {
          ctx.fillStyle = '#000a';
          ctx.fillRect(0, 0, 256, 256);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 96px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(hp.toString(), 128, 128);
        });
    wall.material.needsUpdate = true;

    scene.add(wall);
    walls.push(wall);
    return wall;
}

function applyToBest(gate) {
  const v = Math.abs(gate.val);      // берём модуль
  switch (gate.action) {
    case 'rate':
      bestFireRate = (gate.mode === 'mul')
        ? Math.max(0.2, bestFireRate * v)
        : Math.max(0.2, bestFireRate + (gate.val > 0 ? v : -v));
      break;

    case 'range':
      bestFireRange = (gate.mode === 'mul')
        ? Math.max(1, bestFireRange * v)
        : Math.max(1, bestFireRange + (gate.val > 0 ? v : -v));
      break;

    case 'count':
      bestNailCount = Math.max(1, Math.min(MAX_NAILS, bestNailCount + (gate.val > 0 ? v : -v)));
      bestNailLevelSum += (gate.val > 0 ? v : -v) * (v === 2 ? 2 : 1);
      break;

    case 'level':
      bestNailLevelSum += (gate.val > 0 ? v : -v) * bestNailCount;
      break;
  }

  /* UI-обновление */
  // document.getElementById('best-count').textContent  = bestNailCount;
  // document.getElementById('best-levels').textContent = bestNailLevelSum;
  // document.getElementById('best-rate').textContent   = bestFireRate.toFixed(1);
  // document.getElementById('best-range').textContent  = bestFireRange;
}

  function canPlaceAt(z) {
    return z < lastObjectZ - MIN_GAP;
  }


function spawnWave(delta){
  /* 1. мощность и кол-во */
  // общее количество "пуль за выстрел" = сумма уровней всех гвоздей
  const bulletCount = nailLevels.reduce((a, b) => a + b, 0);

  const power = Math.min(1, (fireRate - 0.5)/4 + (bulletCount - 1)/10);
  const crowdSize = 3 + Math.floor(power * power * 100 * difficultyFactor);

  /* 2. выбираем сторону кластера */
  const side     = Math.random() < 0.5 ? -1 : 1; // -1 = лево, +1 = право
  const clusterX = side * (1 + Math.random() * 2);
  const clampedClusterX = THREE.MathUtils.clamp(clusterX, -2.5, 2.5); // не выходит за бортики
  const spawnZ   = lastSpawnZ - 20;
  /* ————————  ОДНА СТРОКА  ———————— */
  if (spawnZ > nailGroup.position.z + 20) return; // не создаём, если за спиной
  

  lastSpawnZ = spawnZ;

// label – collect UUIDs while spawning this concrete batch
    let freshIds = [];
    if (crowdSize > 5) {
      const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#000a';
    ctx.fillRect(0, 0, 128, 64);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(crowdSize.toString(), 64, 32);

    const tex = new THREE.CanvasTexture(canvas);
    const labelMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
    const labelGeo = new THREE.PlaneGeometry(1, 0.5);
    const labelMesh = new THREE.Mesh(labelGeo, labelMat); // Properly define mesh
    labelMesh.position.set(0, 1.2, spawnZ); // Set Z position relative to spawnZ

    scene.add(labelMesh);

    // сохраняем UUID-список
    enemyLabels.push({ ids: freshIds, mesh: labelMesh, initial: crowdSize });
  }

  /* ---------- спавн стенок ---------- */
  if (Math.random() < 0.4 && canPlaceAt(spawnZ)) {
    const wallPositions = [-RUNWAY_WIDTH / 3, 0, RUNWAY_WIDTH / 3];
    const count = Math.random() < 0.6 ? 1 : 2;
    const taken = new Set();
    for (let i = 0; i < count; i++) {
      let pos;
      do { pos = wallPositions[Math.floor(Math.random() * 3)]; }
      while (taken.has(pos));
      taken.add(pos);
      createWall(pos, spawnZ, delta);
    }
    lastObjectZ = spawnZ;
  }

  /* --- исключаем спавн внутри стенок --- */
  const wallBoxes = walls.map(w => ({
    x: w.position.x,
    z: w.position.z,
    halfW: RUNWAY_WIDTH / 6 + 0.5,
    halfH: 1.2
  }));

  /* 3. спавним кучно */
  for (let i = 0; i < crowdSize; i++){
    let eX, eZ;
    let tooClose;
    do {
      eX = clampedClusterX + (Math.random() - 0.5) * 1.5;
      eZ = spawnZ + (Math.random() - 0.5) * 8;
      tooClose = wallBoxes.some(w =>
        Math.abs(eX - w.x) < w.halfW * 3 && Math.abs(eZ - w.z) < w.halfH * 3
      );
    } while (tooClose);
    const e = new THREE.Mesh(enemyGeo, enemyMat);
    e.position.set(
      clampedClusterX + (Math.random()-0.5)*1.5,
      0,
      spawnZ + (Math.random()-0.5)*8
    );
    e.uuid = THREE.MathUtils.generateUUID(); // ГЕНЕРИМ ДО
    scene.add(e);
    enemies.push(e);
    if (crowdSize > 5) freshIds.push(e.uuid);   // ← собираем ID только этой волны
    e.position.y = 0.3;
    e.lookAt(nailGroup.position.x, 0.3, nailGroup.position.z);
  }

  /* ---------- gates (strict lane, same Z) ---------- */
  const spawnZGate = spawnZ + Math.random() * 10;
  if (Math.random() < 0.7 && canPlaceAt(spawnZGate)) {

    // const gateWidth = RUNWAY_WIDTH / 2;
    const sides = Math.random() < 0.6
      ? [Math.random() < 0.5 ? -1 : 1]   // один гейт: лево или право
      : [-1, 1];                         // два гейта: одновременно

    if (sides.length === 1) {
      const g = pickGate();
      spawnGate(sides[0], spawnZGate, pickGate());
      // --- при спавне одиночного положительного гейта тоже прокачиваем best ---
      if (g.val > 0) {
        applyToBest(g);
      }
    } else {
      // два разных гейта
      let g1 = pickGate();
      let g2;
      do { g2 = pickGate(); } while (g2.label === g1.label);

      let pairTaken = false;   // <-- один раз на волну
      spawnGate(sides[0], spawnZGate, g1);
      spawnGate(sides[1], spawnZGate, g2);

      // связать пары
      gates[gates.length-2].userData.twin = gates[gates.length-1];
      gates[gates.length-1].userData.twin = gates[gates.length-2];

      // назначим обоим гейтам одну и ту же функцию-обработчик
      [gates[gates.length-2], gates[gates.length-1]].forEach(g => {
        g.userData.onTake = () => {
          if (pairTaken) return;
          pairTaken = true;

          // забираем только текущий
          applyGate(g.userData); // твоя логика
          gates.splice(gates.indexOf(g), 1);
          scene.remove(g);

          // второй просто fade-out
          const other = gates.find(gg => gg !== g && gg.position.z === g.position.z);
          if (other) {
            fadeOutGate(other);
            gates.splice(gates.indexOf(other), 1);
          }
        };
});
      // выбираем лучший из двух для best-параметров
      const candidates = [g1, g2];

      // 1) один положительный, один отрицательный
      const pos = candidates.filter(c => c.val > 0);
      const neg = candidates.filter(c => c.val < 0);
      let bestForBest;

      if (pos.length === 1 && neg.length === 1) {
          bestForBest = pos[0];            // всегда берём положительный
      } else {
          // 2) одинаковые знаки
          const sameSign = g1.val > 0 ? 1 : -1;

          if (g1.action === g2.action) {
              // одинаковый action → сравниваем модификацию параметра
              let v1, v2;
              switch (g1.action) {
                  case 'rate':
                      v1 = bestFireRate + g1.val;
                      v2 = bestFireRate + g2.val;
                      break;
                  case 'range':
                      v1 = (g1.mode === 'mul') ? bestFireRange * g1.val : bestFireRange + g1.val;
                      v2 = (g2.mode === 'mul') ? bestFireRange * g2.val : bestFireRange + g2.val;
                      break;
                  case 'count':
                      v1 = bestNailCount + g1.val;
                      v2 = bestNailCount + g2.val;
                      break;
                  case 'level':
                      v1 = bestNailLevelSum + g1.val * bestNailCount;
                      v2 = bestNailLevelSum + g2.val * bestNailCount;
                      break;
              }
              bestForBest = (sameSign > 0) ? (v1 >= v2 ? g1 : g2) : (v1 <= v2 ? g1 : g2);
          } else {
              // 3) разные action → utility
              const u1 = utility(g1, { rate: bestFireRate, range: bestFireRange, count: bestNailCount }, g2);
              const u2 = utility(g2, { rate: bestFireRate, range: bestFireRange, count: bestNailCount }, g1);
              bestForBest = (sameSign > 0) ? (u1 >= u2 ? g1 : g2) : (u1 <= u2 ? g1 : g2);
          }
      }
      applyToBest(bestForBest);
    }
  }
  lastObjectZ = spawnZGate;
}

/* ---------- controls ---------- */
let mouseX = 0;
window.addEventListener('mousemove', e => mouseX = (e.clientX/innerWidth - 0.5) * 6);

window.addEventListener('touchmove', e => {
  const touch = e.touches[0];
  mouseX = (touch.clientX / innerWidth - 0.5) * 6;
}, { passive: true });

/* ---------- camera ---------- */
camera.position.set(0,5,4);                       // <-- ближе
camera.lookAt(0,-1,nailGroup.position.z - 3);        // <-- ниже и точнее

let speed = 0.1;
// document.addEventListener('click', () => {
//   if (!started){ document.getElementById('bgm').play(); started = true; }
// });

/* ---------- shooting ---------- */
function shoot(time){
  if (!started || gameOver) return;
  if (time - lastShot < 1000 / fireRate) return;
  lastShot = time;

  nailGroup.children.forEach((nail, i) => {
    const level = nailLevels[i];
    const geo = level >= 3 ? bigBulletGeo : bulletGeo;
    const mat = level >= 3 ? bigBulletMat : bulletMat;

    const b = new THREE.Mesh(geo, mat);
    const nailPos = nail.position;
    b.position.set(
      nailGroup.position.x + nailPos.x,
      0,
      nailGroup.position.z - 0.5
    );
    scene.add(b);

    // пуля знает свой уровень-пробой
    bullets.push({mesh:b, vx:0, vz:-0.4, pierce:level});
  });
}


/* ---------- game-over screen ---------- */
function showMsg(text){
  document.getElementById('msgText').innerText = text;
  document.getElementById('msg').style.display = 'block';
}

/* ---------- enemy AI ---------- */
const DETECT_DISTANCE = 20;   // на каком расстоянии враг замечает игрока
const ENEMY_SPEED     = 0.1; // базовая скорость врага
const difficultyFactor = 0.5;   // <-- крутите этим для сложности (0.5–2.0)

function updateEnemiesAI() {
  const wallBoxes = walls.map(w => ({
    x: w.position.x,
    z: w.position.z,
    halfW: RUNWAY_WIDTH / 6 + 0.2,   // половина ширины стенки + запас
    halfH: 1.1                       // половина глубины
  }));

  enemies.forEach(e => {
    const dist = e.position.distanceTo(nailGroup.position);
    if (dist < DETECT_DISTANCE) {
      const dir = new THREE.Vector3()
        .subVectors(
          new THREE.Vector3(nailGroup.position.x, 0, nailGroup.position.z),
          e.position
        )
        .normalize();
      dir.y = 0;
      dir.z *= 0.2;

      // проверка пересечения со стенками
      let blocked = false;
      for (const box of wallBoxes) {
        const dx = Math.abs(e.position.x - box.x);
        const dz = Math.abs(e.position.z - box.z);
        if (dx < box.halfW && dz < box.halfH) {
          blocked = true;
          break;
        }
      }

      if (!blocked) {
        e.position.addScaledVector(dir, ENEMY_SPEED * difficultyFactor);
      }
    }
  });
}

function fadeOutGate(gate) {
  const fadeMat = gate.children.find(c => c.material.transparent)?.material;
  if (!fadeMat) { scene.remove(gate); return; }  // на всякий случай

  let alpha = 0.4;
  const fadeStep = 0.05;
  const fadeInterval = setInterval(() => {
    alpha -= fadeStep;
    fadeMat.opacity = Math.max(0, alpha);
    if (alpha <= 0) {
      clearInterval(fadeInterval);
      scene.remove(gate);
    }
  }, 16);   // ~60 fps
}

/* ---------- main loop ---------- */
let lastTime = performance.now();
function animate(time){
  requestAnimationFrame(animate);
  if (!started || gameOver) return;
  const delta = (time - lastTime) / 1000;   // секунды
  lastTime = time;
  // очистить старых врагов без uuid (защита от старых сохранений/кэша)
  enemies = enemies.filter(e => e.uuid);

  /*  ✔  ИСПРАВЛЕНИЕ 1: всегда вызываем shoot  */
  shoot(time);

  /* player movement */
  nailGroup.position.x += (mouseX - nailGroup.position.x) * 0.1;
  nailGroup.position.x = THREE.MathUtils.clamp(nailGroup.position.x, -3, 3);
  nailGroup.position.z -= speed;

  /* сжатие у краёв + ограничение */
  const halfRoad   = 3 - 0.15;   // RUNWAY_WIDTH / 2 - 0.15
  const minGap     = 0.15;
  const maxGap     = 0.5;
  const fadeZone   = halfRoad * 0.3;

  const totalLen   = (nailCount - 1) * maxGap;
  let gap          = totalLen > halfRoad * 2
    ? Math.max(minGap, (halfRoad * 2) / Math.max(1, nailCount - 1))
    : Math.max(minGap, maxGap - Math.max(0, 1 - (halfRoad - Math.abs(nailGroup.position.x)) / fadeZone) * (maxGap - minGap));

  // позиции гвоздей
  nailGroup.children.forEach((nail, i) => {
    const pos = (i - (nailCount - 1) / 2) * gap;
    nail.position.x = THREE.MathUtils.clamp(pos, -halfRoad, halfRoad);
  });

  /* индивидуальный наклон */
  const tiltBase = (mouseX - nailGroup.position.x) * 0.15;
  nailGroup.children.forEach(nail => {
    const edgeDist = halfRoad - Math.abs(nail.position.x + nailGroup.position.x);
    const factor   = Math.max(0, Math.min(1, edgeDist / halfRoad));
    nail.rotation.z = THREE.MathUtils.clamp(tiltBase * factor, -0.4, 0.4);
  });

  updateEnemiesAI();
  // ⚡ 4. Clean stale labels
  // enemyLabels = enemyLabels.filter(l => enemies.some(e => l.ids.includes(e.uuid)));

/* ---------- центральный label над группой ---------- */
for (let k = enemyLabels.length - 1; k >= 0; k--) {
  const { ids, mesh, initial } = enemyLabels[k];

  // ⚡ проверяем, есть ли хоть один живой из этой волны
  const alive = enemies.filter(e =>
    ids.includes(e.uuid) && e.position.z < nailGroup.position.z + 10
  );

  if (alive.length === 0) {
    scene.remove(mesh);
    enemyLabels.splice(k, 1);
    continue;
  }

  const center = new THREE.Vector3();
  alive.forEach(e => center.add(e.position));
  center.divideScalar(alive.length);
  center.y += 1.2;
  mesh.position.lerp(center, 0.1);

  // console.log(
  // `label #${k} ids.length=${ids.length} alive=${alive.length}`,
  // alive.map(e => e.uuid.slice(-4))
// );

  if (alive.length !== initial) {
    const canvas = mesh.material.map.image;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 128, 64);
    ctx.fillStyle = '#000a';
    ctx.fillRect(0, 0, 128, 64);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(alive.length.toString(), 64, 32);
    mesh.material.map.needsUpdate = true;
    enemyLabels[k].initial = alive.length;
  }
}

  /* continuous spawning */
  if (nailGroup.position.z - 80 < lastSpawnZ){
    spawnWave(delta);
  }

  /* bullets */
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.mesh.position.x += b.vx;
    b.mesh.position.z += b.vz;
    if (b.mesh.position.z < nailGroup.position.z - fireRange){
      scene.remove(b.mesh); bullets.splice(i,1);
    }
  }

/* bullet–enemy collision */
for (let i = bullets.length - 1; i >= 0; i--){
  const b = bullets[i];     // объект-контейнер
  const bMesh = b.mesh;     // сам меш

  for (let j = enemies.length - 1; j >= 0; j--){
    const e = enemies[j];
    const hitDist = 0.5;   // можно оставить фиксированным

    if (bMesh.position.distanceTo(e.position) < hitDist){
      b.pierce--;

      scene.remove(e);
      enemies.splice(j, 1);

      if (b.pierce <= 0){
        scene.remove(bMesh);
        bullets.splice(i, 1);
        break;              // пуля уничтожена – выходим из цикла по врагам
      }
    }
  }
}

  /* player–enemy collision */
  for (let j = enemies.length - 1; j >= 0; j--){
    const e = enemies[j];
    let hit = false;

    for (let i = nailGroup.children.length - 1; i >= 0; i--){
      const nail = nailGroup.children[i];
      const dx = nailGroup.position.x + nail.position.x - e.position.x;
      const dz = nailGroup.position.z                - e.position.z;
      const dist = Math.sqrt(dx*dx + dz*dz);

      if (dist < 0.7){
        hit = true;

        if (nailLevels[i] > 1){
          // теряем уровень
          nailLevels[i]--;
          rebuildNailFormation();
        } else {
          // удаляем гвоздь
          nailCount--;
          nailLevels.splice(i,1);
          rebuildNailFormation();
          if (nailCount === 0){
            gameOver = true;
            showMsg('Game Over!');
            return;
          }
        }
        scene.remove(e); enemies.splice(j,1);
        break;   // одно сердце – один гвоздь
      }
    }
  }

  /* ---------- player–wall collision ---------- */
  for (let i = walls.length - 1; i >= 0; i--) {
    const wall = walls[i];
    let hit = false;

    for (let j = nailGroup.children.length - 1; j >= 0; j--) {
      const nail = nailGroup.children[j];
      const dx = nailGroup.position.x + nail.position.x - wall.position.x;
      const dz = nailGroup.position.z - wall.position.z;
      if (Math.sqrt(dx * dx + dz * dz) < 1.2) {
        hit = true;

        const lostLevels = nailLevels[j];
        wall.userData.hp -= lostLevels + (nailLevels[j] === 1 ? 1 : 0); // +1 за первый уровень

        const hp = wall.userData.hp;
        wall.material.map = getTexture(`hp_${hp}`, ctx => {
          ctx.fillStyle = '#000a';
          ctx.fillRect(0, 0, 256, 256);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 96px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(hp.toString(), 128, 128);
        });
        wall.material.needsUpdate = true;

        nailLevels[j] = Math.max(0, nailLevels[j] - lostLevels);
        if (nailLevels[j] === 0) {
          nailCount--;
          nailLevels.splice(j, 1);
          rebuildNailFormation();
          if (nailCount === 0) {
            gameOver = true;
            showMsg('Game Over!');
            return;
          }
        }
        rebuildNailFormation();
        break;
      }
    }

    if (wall.userData.hp <= 0) {
      scene.remove(wall);
      walls.splice(i, 1);
      // превращаем в положительный gate (код уже есть)
    }
  }

  /* player–gate collision */
  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    let touched = false;
    for (const nail of nailGroup.children) {
      const dx = nailGroup.position.x + nail.position.x - g.position.x;
      const dz = nailGroup.position.z - g.position.z;
      if (Math.sqrt(dx*dx + dz*dz) < 1.5) { touched = true; break; }
    }
    if (!touched) continue;

    const gameOverFlag = applyGate(g.userData);
    if (gameOverFlag) return;          // Game Over

    // 2-й гейт (если пара) — fade-out
    if (g.userData.twin) {
      fadeOutGate(g.userData.twin);
      gates.splice(gates.indexOf(g.userData.twin), 1);
    }

    gates.splice(i, 1);
    scene.remove(g);
  }

  /* ---------- обработка стенок ---------- */
  for (let i = walls.length - 1; i >= 0; i--) {
    const wall = walls[i];
    for (let j = bullets.length - 1; j >= 0; j--) {
      const b = bullets[j];
      if (b.mesh.position.distanceTo(wall.position) < 1) {
        // наносим урон
        wall.userData.hp -= b.pierce;
        const hp = wall.userData.hp;
        wall.material.map = getTexture(`hp_${hp}`, ctx => {
          ctx.fillStyle = '#000a';
          ctx.fillRect(0, 0, 256, 256);
          ctx.fillStyle = '#ffffff';
          ctx.font = 'bold 96px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText(hp.toString(), 128, 128);
        });
        wall.material.needsUpdate = true;

        scene.remove(b.mesh);
        bullets.splice(j, 1);

        if (wall.userData.hp <= 0) {
          scene.remove(wall);
          walls.splice(i, 1);

          // превращаем в положительный gate
          const roll = Math.random();
          let gateData;
          if (roll < 0.45) gateData = { label: 'УРОВЕНЬ +1', action: 'level', val: 1 };
          else if (roll < 0.70) gateData = { label: 'ГВОЗДИ +1', action: 'count', val: 1 };
          else if (roll < 0.85) gateData = { label: 'ДАЛЬНОСТЬ +2', action: 'range', val: 2 };
          else gateData = { label: 'СТРЕЛЬБА +1', action: 'rate', val: 1 };

          spawnNarrowGate(wall.position.x, wall.position.z, gateData);
          applyToBest(gateData);
        }
        break;
      }
    }
  }

  

  /* win condition по реальному времени */
  const elapsedSec = (performance.now() - songStartTime) / 1000;
  const progress = Math.min(1, elapsedSec / SONG_DURATION);
  document.getElementById('progressFill').style.width = (progress * 100) + '%';

  if (elapsedSec >= SONG_DURATION){
    gameOver = true;
    showMsg('You Win!');
    return;
  }

  /* camera follow */
  camera.position.x = nailGroup.position.x;
  camera.position.z = nailGroup.position.z + 9;
  camera.lookAt(nailGroup.position.x, 0, nailGroup.position.z - 3);

  /* удаляем врагов и гейты за спиной */
  const behind = nailGroup.position.z + 15;  // порог удаления
  for (let i = enemies.length - 1; i >= 0; i--) {
    if (enemies[i].position.z > behind) {
      scene.remove(enemies[i]);
      enemies.splice(i, 1);
    }
  }
  for (let i = gates.length - 1; i >= 0; i--) {
    if (gates[i].position.z > behind) {
      scene.remove(gates[i]);
      gates.splice(i, 1);
    }
  }
  for (let i = walls.length - 1; i >= 0; i--) {
  if (walls[i].position.z > behind) {
    scene.remove(walls[i]);
    walls.splice(i, 1);
  }
}

  updateRunway();
  
  /* позиционируем баннер строго над центром толпы без наклона */
bannerMesh.position.set(
  nailGroup.position.x,
  nailGroup.position.y + 1.2,
  nailGroup.position.z
);
bannerMesh.rotation.copy(camera.rotation); // всегда смотрит в камеру (не наклоняется)
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>