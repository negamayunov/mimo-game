<!DOCTYPE html>
<html lang="en">
<head>
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<meta charset="UTF-8"/>
<title>YA SNOVA MIMO ‚Äì Good View & Crowds</title>
<style>
body{margin:0;overflow:hidden;background:#111;font-family:sans-serif;color:#fff}
canvas{display:block}
#ui{position:absolute;top:10px;left:10px;font-size:18px}
#msg{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);
     background:#0008;padding:30px 50px;font-size:28px;text-align:center;display:none}
#msg button{padding:10px 20px;font-size:20px;margin-top:15px;cursor:pointer}

#preloader{
  position:fixed; inset:0;
  background:#0a1030;
  color:#fff;
  font-family:sans-serif;
  display:flex; flex-direction:column;
  align-items:center; justify-content:center;
  gap:25px;
  z-index:10;
}
#preloader h1{ font-size:48px; margin:0 0 20px; }
#social{ display:flex; gap:20px; }
#social a{
  color:#fff; background:#ffffff20;
  padding:8px 16px; border-radius:6px;
  text-decoration:none; font-size:18px;
  transition:background .2s;
}
#social a:hover{ background:#ffffff40; }
#startBtn{
  font-size:24px; padding:12px 32px;
  border:none; border-radius:8px; cursor:pointer;
  background:#00ff88; color:#000;
}
#startBtn:disabled{ background:#666; cursor:not-allowed; }

#loadProgress{ appearance:none; }
#loadProgress::-webkit-progress-bar{ background:#222; }
#loadProgress::-webkit-progress-value{ background:#00ff88; }

#progressBar{
  position:fixed; bottom:10px; left:50%; transform:translateX(-50%);
  width:60%; height:6px; background:#222; border-radius:3px;
  overflow:hidden; z-index:5;
}
#progressFill{
  height:100%; width:0%; background:#00ff88; transition:width 0.1s;
}

.gateLabel{
  font-family:sans-serif;
  font-size:26px;
  font-weight:bold;
  color:#fff;
  text-align:center;
  width:100%;
  position:absolute;
  top:4px;
}
.gateValue{
  font-family:sans-serif;
  font-size:42px;
  font-weight:bold;
  color:#fff;
  text-align:center;
  width:100%;
  position:absolute;
  top:50%;
  transform:translateY(-50%);
}

</style>
</head>
<body>
<div id="ui">
  –ì–≤–æ–∑–¥–µ–π: <span id="count">1</span> |
  –£—Ä–æ–≤–Ω–µ–π: <span id="levels">1</span><br>
  –°–∫–æ—Ä–æ—Å—Ç—å —Å—Ç—Ä–µ–ª—å–±—ã: <span id="rate">1.0</span>/—Å–µ–∫
  <!-- –ü—Ä–æ–±–∏–≤.: <span id="pierce">1</span><br> -->
  –î–∞–ª—å–Ω–æ—Å—Ç—å: <span id="range">15</span>
</div>

<!-- <div id="best-stats" style="position:absolute; top:10px; right:10px; font-size:18px;">
  –õ—É—á—à–∏–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã:<br>
  –ì–≤–æ–∑–¥–µ–π: <span id="best-count">1</span><br>
  –£—Ä–æ–≤–Ω–µ–π: <span id="best-levels">1</span><br>
  –°–∫–æ—Ä–æ—Å—Ç—å —Å—Ç—Ä–µ–ª—å–±—ã: <span id="best-rate">1.0</span>/—Å–µ–∫<br>
  –î–∞–ª—å–Ω–æ—Å—Ç—å: <span id="best-range">15</span><br>
  –¢–µ–∫—É—â–∏–π —É—Ä–æ–Ω: <span id="cur-dmg">0</span><br>
  –õ—É—á—à–∏–π —É—Ä–æ–Ω: <span id="best-dmg">0</span>
</div> -->

<div id="msg">
  <div id="msgText"></div>
  <button onclick="location.reload()">Restart</button>
</div>
<div id="progressBar">
  <div id="progressFill"></div>
</div>

<!-- preloader + menu -->
<div id="preloader">
  <h1>MIMO!</h1>

  <div id="social">
    <a href="https://t.me/gvozdi_band"  target="_blank">Telegram</a>
    <a href="https://vk.com/gvozdi_band" target="_blank">VK</a>
    <a href="https://www.youtube.com/channel/UCzNrI47UMc8ie3cnITUW-Dg" target="_blank">YouTube</a>
  </div>

  <button id="startBtn" disabled>–ó–∞–≥—Ä—É–∑–∫–∞‚Ä¶</button>
  <progress id="loadProgress" value="0" max="100" style="width:200px;height:10px;"></progress>
  <span id="loadText">0 %</span>
</div>

<script type="module">
import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

/* ---------- TEXTURE CACHE ---------- */
const textureCache = new Map();   // key ‚Üí CanvasTexture
function getTexture(key, drawFn) {
  if (!textureCache.has(key)) {
    const canvas = document.createElement('canvas');
    canvas.width = 256;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');
    drawFn(ctx);                 // ‚Üê –≤–æ—Ç —Ç—É—Ç ctx –ø–µ—Ä–µ–¥–∞—ë—Ç—Å—è –≤ —Ç–≤–æ—é —Ñ—É–Ω–∫—Ü–∏—é
    textureCache.set(key, new THREE.CanvasTexture(canvas));
  }
  return textureCache.get(key);
}

/* ---------- preloader with progress ---------- */
const preEl      = document.getElementById('preloader');
const startBtn   = document.getElementById('startBtn');
const progressEl = document.getElementById('loadProgress');
const textEl     = document.getElementById('loadText');

let audioReady = false;
const audioSrc = 'song.mp3';            // –≤–∞—à —Ñ–∞–π–ª
const bgmEl    = new Audio();           // —Å–æ–∑–¥–∞—ë–º –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏
bgmEl.loop = true;

// –≥—Ä—É–∑–∏–º fetch -> blob
fetch(audioSrc)
  .then(r => {
    if (!r.ok) throw new Error('network');
    const total = +r.headers.get('content-length');
    let loaded = 0;
    const reader = r.body.getReader();
    const stream = new ReadableStream({
      start(controller){
        function pump(){
          reader.read().then(({done, value}) => {
            if (done){
              controller.close();
              return;
            }
            loaded += value.byteLength;
            const pct = total ? (loaded / total * 100) : 0;
            progressEl.value = pct;
            textEl.textContent = `${Math.round(pct)} %`;
            controller.enqueue(value);
            pump();
          });
        }
        pump();
      }
    });
    return new Response(stream).blob();
  })
  .then(blob => {
    bgmEl.src = URL.createObjectURL(blob);
    audioReady = true;
    progressEl.value = 100;
    textEl.textContent = '100 %';
    startBtn.disabled = false;
    startBtn.textContent = '–ù–∞—á–∞—Ç—å –∏–≥—Ä—É';
  })
  .catch(() => {
    // –µ—Å–ª–∏ —Ñ–∞–π–ª –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω ‚Äì –≤—Å—ë —Ä–∞–≤–Ω–æ –ø–æ–∑–≤–æ–ª—è–µ–º –∏–≥—Ä–∞—Ç—å –±–µ–∑ –∑–≤—É–∫–∞
    startBtn.disabled = false;
    startBtn.textContent = '–ò–≥—Ä–∞—Ç—å –±–µ–∑ –∑–≤—É–∫–∞';
  });

// —Å—Ç–∞—Ä—Ç
startBtn.addEventListener('click', () => {
  if (audioReady) bgmEl.play().catch(() => {});
  preEl.style.display = 'none';
  started = true;
  songStartTime = performance.now(); // —Ñ–∏–∫—Å–∏—Ä—É–µ–º —Å—Ç–∞—Ä—Ç
});

/* ---------- basic scene ---------- */
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0x0a1030, 15, 100);   // —Ç—É–º–∞–Ω

const camera = new THREE.PerspectiveCamera(75, innerWidth/innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setPixelRatio(window.devicePixelRatio);
renderer.setSize(innerWidth, innerHeight);
renderer.setClearColor(0x0a1030);
document.body.appendChild(renderer.domElement);

/* —Å–≤–µ—Ç */
const dirLight = new THREE.DirectionalLight(0xffffff, 1.2); // —Å—Ä–∞–∑—É –Ω—É–∂–Ω–∞—è —è—Ä–∫–æ—Å—Ç—å
dirLight.position.set(0, 10, 5);
scene.add(dirLight);

scene.add(new THREE.AmbientLight(0xffffff, 0.8)); // —á—É—Ç—å —É—Å–∏–ª–∏–º –æ–±—â–∏–π —Å–≤–µ—Ç

/* ---------- player ---------- */
/*  NEW  */
const nailBody = new THREE.ConeGeometry(0.08, 1.0, 100);
const nailHead = new THREE.CylinderGeometry(0.18, 0.18, 0.15, 16);
const playerMat = new THREE.MeshStandardMaterial({
  color: 0xc0c0c0, metalness: 0.8, roughness: 0.2
});

/* –º–∞—Å—Å–∏–≤, –∫—É–¥–∞ –±—É–¥–µ–º —Å–∫–ª–∞–¥—ã–≤–∞—Ç—å –≥—Ä—É–ø–ø—ã-–≥–≤–æ–∑–¥–∏ */
const nailGroup = new THREE.Group();   // –Ω–∞ —Å—Ü–µ–Ω–µ —Ç–æ–ª—å–∫–æ —ç—Ç–∞ –≥—Ä—É–ø–ø–∞
scene.add(nailGroup);

/* ---------- CROWD-LEVEL BANNER (—Å—Ü–µ–Ω–∞, –Ω–µ –≥—Ä—É–ø–ø–∞) ---------- */
const bannerCanvas = document.createElement('canvas');
bannerCanvas.width = 256; bannerCanvas.height = 128;
const bannerCtx = bannerCanvas.getContext('2d');

const bannerTex = new THREE.CanvasTexture(bannerCanvas);
const bannerMat = new THREE.MeshBasicMaterial({ map: bannerTex, transparent: true });
const bannerGeo = new THREE.PlaneGeometry(0.8, 0.4);
const bannerMesh = new THREE.Mesh(bannerGeo, bannerMat);

bannerMesh.position.set(0, 2.2, 0); // –≤—Ä–µ–º–µ–Ω–Ω–∞—è, –±—É–¥–µ—Ç –æ–±–Ω–æ–≤–ª—è—Ç—å—Å—è –≤ animate
scene.add(bannerMesh);

/* ------------- –ø–µ—Ä–µ—Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —É—Ä–æ–≤–Ω–µ–π ------------- */
function redistributeLevels() {
  const total = nailLevels.reduce((a, b) => a + b, 0);
  const avg   = Math.ceil(total / nailCount);

  nailLevels = Array(nailCount).fill(avg);
  bestNailCount = Math.max(bestNailCount, nailCount);
  bestNailLevelSum = Math.max(bestNailLevelSum, nailLevels.reduce((a,b)=>a+b,0));
}

/* —Ñ—É–Ω–∫—Ü–∏—è –ø–µ—Ä–µ—Å–±–æ—Ä–∫–∏ —Ç–æ–ª–ø—ã */
function rebuildNailFormation(){
  // —É–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ –º–µ—à–∏
  while (nailGroup.children.length){
    nailGroup.remove(nailGroup.children[0]);
  }

  const spacing = 0.5;   // —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —Ü–µ–Ω—Ç—Ä–∞–º–∏

  for (let i = 0; i < nailCount; i++){
    const body = new THREE.Mesh(nailBody, playerMat);
    const head = new THREE.Mesh(nailHead, playerMat);

    body.position.y = 0;
    head.position.y = 0.575;
    body.rotation.z = Math.PI;

    const single = new THREE.Group();
    const level = nailLevels[i] || 1;

    single.add(body);
    single.add(head);

    // —Ä–∞—Å—Å—Ç–∞–≤–ª—è–µ–º –≤ –æ–¥–Ω—É –ª–∏–Ω–∏—é –ø–æ X
    const offset = (i - (nailCount - 1) / 2) * spacing;
    single.position.x = offset;

    // —Ü–≤–µ—Ç–æ–º –ø–æ–∫–∞–∑—ã–≤–∞–µ–º —É—Ä–æ–≤–µ–Ω—å (–ø–æ –∂–µ–ª–∞–Ω–∏—é)
    // —Ü–≤–µ—Ç –¥–ª—è –≤—Å–µ–≥–æ –≥–≤–æ–∑–¥—è (–∏ —Å—Ç–µ—Ä–∂–Ω—è, –∏ —à–ª—è–ø–∫–∏)
    const nailMat = playerMat.clone();
    const hue = 0.44 + (level - 1) * 0.8;  // 0 = —Å–µ—Ä—ã–π, –¥–∞–ª—å—à–µ –∏–¥—ë—Ç –≤ –∑–µ–ª—ë–Ω—ã–π / –æ—Ä–∞–Ω–∂–µ–≤—ã–π
    nailMat.color.setHSL(hue, 0.9, 0.8);
    body.material = nailMat;
    head.material = nailMat;

    nailGroup.add(single);
  }

  /* update banner text */
  const totalLevel = nailLevels.reduce((a, b) => a + b, 0);
  bannerMat.map = getTexture(`level_${totalLevel}`, (ctx) => {
    ctx.canvas.width = 256; ctx.canvas.height = 128;
    ctx.fillStyle = '#000a';
    ctx.fillRect(0, 0, 256, 128);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';
    ctx.font = 'bold 64px sans-serif';
    ctx.textBaseline = 'middle';
    ctx.fillText(totalLevel.toString(), 128, 64);
  });
  bannerMat.map.needsUpdate = true;
}

/* ---------- shooting params ---------- */
let fireRate = 1;
let lastShot = 0;
let fireRange = 15; // –∏–∑–Ω–∞—á–∞–ª—å–Ω–æ –º–∞–ª–µ–Ω—å–∫–∞—è –¥–∞–ª—å–Ω–æ—Å—Ç—å (–º–æ–∂–Ω–æ –º–µ–Ω—è—Ç—å)

/*  NEW  */
const MAX_NAILS   = 5;
let nailCount   = 1;
let nailLevels  = [1];
// ---------- –ª—É—á—à–∏–π –≤–æ–∑–º–æ–∂–Ω—ã–π –Ω–∞–±–æ—Ä –∏–≥—Ä–æ–∫–∞ ----------
let bestFireRate = 1;
let bestFireRange = 15;
let bestNailCount = 1;
let bestNailLevelSum = 1;   // —Å—É–º–º–∞ —É—Ä–æ–≤–Ω–µ–π

const RUNWAY_WIDTH  = 6;            // —Å–æ–≤–ø–∞–¥–∞–µ—Ç —Å –¥–∏–∞–ø–∞–∑–æ–Ω–æ–º mouseX
const RUNWAY_LENGTH = 80;
const EDGE_HEIGHT   = 0.2;
const gateWidth = RUNWAY_WIDTH / 2;
const narrowGateWidth = RUNWAY_WIDTH / 3;

// ---------- utility-—Ñ—É–Ω–∫—Ü–∏—è –ø–æ –Ω–æ–≤–æ–º—É –ø—Ä–∞–≤–∏–ª—É ----------
function utility(gate, current, twin) {
  // 1. –µ—Å–ª–∏ action —Å–æ–≤–ø–∞–¥–∞–µ—Ç ‚Äî –≤—ã–∏–≥—Ä—ã–≤–∞–µ—Ç —Ç–æ—Ç, –∫—Ç–æ –¥–æ–±–∞–≤–∏—Ç –±–æ–ª—å—à–µ –∫ —Ç–µ–∫—É—â–µ–º—É –ø–∞—Ä–∞–º–µ—Ç—Ä—É
  if (gate.action === twin.action) {
    switch (gate.action) {
      case 'rate':  return current.rate * gate.val;
      case 'range': return current.range * gate.val;
      case 'count': return current.count * gate.val;
      case 'level': return current.count * gate.val; // –∞–Ω–∞–ª–æ–≥–∏—á–Ω–æ
      default:      return gate.val;
    }
  }

  // 2. action —Ä–∞–∑–Ω—ã–µ ‚Äî —Å—Ç–∞—Ä–∞—è –ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç–Ω–∞—è —à–∫–∞–ª–∞
  const prio = {
    level: 900,
    count: (gate.val === 2 ? 950 : 800),
    rate:  gate.val * 300,
    range: (gate.mode === 'mul' ? 450 : gate.val * 200)
  };
  return prio[gate.action] || 0;
}

function calcWallHP(delta) {
  /* 1. –°—É–º–º–∞—Ä–Ω—ã–π —É—Ä–æ–Ω –∑–∞ –û–î–ò–ù –∑–∞–ª–ø */
  const totalPierce = nailLevels.reduce((a, b) => a + b, 0);

  /* 2. –°–∫–æ–ª—å–∫–æ –∑–∞–ª–ø–æ–≤ —É—Å–ø–µ–µ—Ç –≤—ã–ø—É—Å—Ç–∏—Ç—å –∏–≥—Ä–æ–∫, –ø–æ–∫–∞ —Ü–µ–ª—å –≤ –¥–æ—Å—è–≥–∞–µ–º–æ—Å—Ç–∏
       = –¥–∞–ª—å–Ω–æ—Å—Ç—å / —Å–∫–æ—Ä–æ—Å—Ç—å –ø—É–ª–∏  (–ø—É–ª–∏ –ª–µ—Ç—è—Ç 0.4 –µ–¥/–∫–∞–¥—Ä @ 60 fps ‚âà 24 –µ–¥/—Å–µ–∫) */
  const bulletSpeed = 0.4 / delta;          // –µ–¥–∏–Ω–∏—Ü –≤ —Å–µ–∫—É–Ω–¥—É
  const timeInRange = fireRange / bulletSpeed;

  /* 3. –°–∫–æ–ª—å–∫–æ –∑–∞–ª–ø–æ–≤ –∑–∞ —ç—Ç–æ –≤—Ä–µ–º—è */
  const shotsFired  = Math.max(1, fireRate * timeInRange);

  /* 4. –ü–æ–ª–Ω—ã–π —É—Ä–æ–Ω */
  const fullDmg = totalPierce * shotsFired;

  /* 5. –°—Ä–µ–¥–Ω–∏–π —É—Ä–æ–Ω (—Ç–µ–∫—É—â–∏–π + –ª—É—á—à–∏–π) */
  const bestTotal = bestNailLevelSum;
  const bestShots = Math.max(1, bestFireRate * (bestFireRange / bulletSpeed));
  const bestDmg   = bestTotal * bestShots;

  let baseDmg = (fullDmg + bestDmg) / 2;

  /* 6. –°–ª—É—á–∞–π–Ω—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã */
  const rand1 = 0.7 + Math.random() * 0.3;
  let hp      = baseDmg * rand1;

  // –ù–ï–ü–†–û–ë–ò–í–ê–ï–ú–ê–Ø —Å—Ç–µ–Ω–∞ (–∫–∞–∫ –º–∏–Ω–∏–º—É–º, –≤ 2 —Ä–∞–∑–∞ –±–æ–ª—å—à–µ –∂–∏–∑–Ω–µ–π, —á–µ–º —Å—Ä–µ–¥–Ω–∏–π —É—Ä–æ–Ω)
  const rand2 = Math.random() < 0.3 ? (2 + Math.random() * 10) : 1;
  hp *= rand2;

  // –æ–±–Ω–æ–≤–ª—è–µ–º UI —É—Ä–æ–Ω
  // document.getElementById('cur-dmg').textContent  = Math.round(fullDmg);
  // document.getElementById('best-dmg').textContent = Math.round(bestDmg);
  hp = Math.max(1, Math.round(hp) + 4);

  return { hp, rand2 }; 
}

/* ---------- RUNTIME FLAGS ---------- */
let started   = false;
let gameOver  = false;
let songStartTime = 0;            // –º–æ–º–µ–Ω—Ç, –∫–æ–≥–¥–∞ –Ω–∞–∂–∞–ª–∏ ¬´–ù–∞—á–∞—Ç—å¬ª
const SONG_DURATION = 215;        // —Å–µ–∫—É–Ω–¥—ã

rebuildNailFormation();   // —Å–æ–∑–¥–∞—ë–º –ø–µ—Ä–≤–∏–π –≥–≤–æ–∑–¥—å

/* ---------- bullets ---------- */
const bulletGeo  = new THREE.SphereGeometry(0.08,8,8);
const bigBulletGeo = new THREE.SphereGeometry(0.25,16,16);
// ‚ö° 2. Shared bullet materials
const bulletMat = new THREE.MeshStandardMaterial({ color: 0xffff00 });
const bigBulletMat = new THREE.MeshStandardMaterial({ color: 0xff8800 });

const bullets = [];

/* ---------- enemies ---------- */
/* ---------- shared heart geometry ---------- */
const _heartShape = new THREE.Shape();
((s = _heartShape) => {
  s.moveTo(5, 5);
  s.bezierCurveTo(5, 5, 4, 0, 0, 0);
  s.bezierCurveTo(-6, 0, -6, 7, -6, 7);
  s.bezierCurveTo(-6, 11, -3, 15.4, 5, 19);
  s.bezierCurveTo(12, 15.4, 16, 11, 16, 7);
  s.bezierCurveTo(16, 7, 16, 0, 10, 0);
  s.bezierCurveTo(7, 0, 5, 5, 5, 5);
})();

const heartGeo = new THREE.ExtrudeGeometry(_heartShape, 8);
heartGeo.center();
heartGeo.scale(0.05, 0.05, 0.05); // 0.4 / 4 = 0.1, –Ω–æ –µ—â—ë √ó0.5 —á—Ç–æ–±—ã ‚âà0.2 —Ä–∞–∑–º–µ—Ä
heartGeo.rotateZ(Math.PI);

/* ---------- —Å—Ç–µ–Ω–∫–∞ ---------- */
const wallGeo = new THREE.BoxGeometry(RUNWAY_WIDTH / 3, 2, 0.3);
const wallMat = new THREE.MeshPhysicalMaterial({
  color: 0xffffff,
  transparent: true,
  opacity: 0.6,
  roughness: 0.1,
  metalness: 0.2,
  transmission: 0.7
});
const walls = [];

// –ö–≠–® –¥–ª—è HP-—Ç–µ–∫—Å—Ç—É—Ä
const hpTextureCache = new Map();

function getHPTexture(hp) {
  if (hpTextureCache.has(hp)) return hpTextureCache.get(hp);

  const canvas = document.createElement('canvas');
  canvas.width = 256;
  canvas.height = 256;
  const ctx = canvas.getContext('2d');

  ctx.fillStyle = '#000a';
  ctx.fillRect(0, 0, 256, 256);
  ctx.fillStyle = '#ffffff';
  ctx.font = 'bold 96px sans-serif';
  ctx.textAlign = 'center';
  ctx.textBaseline = 'middle';
  ctx.fillText(hp.toString(), 128, 128);

  const tex = new THREE.CanvasTexture(canvas);
  hpTextureCache.set(hp, tex);
  return tex;
}


/* ---------- RUNWAY POOL (–±–µ–∑ new Mesh –∫–∞–∂–¥—ã–π –∫–∞–¥—Ä) ---------- */
const RUNWAY_POOL_SIZE = 6;               // 6 —Å–µ–≥–º–µ–Ω—Ç–æ–≤ –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ
const runwayPool = [];                    // {mesh, inUse, centerZ}
const runwayMat  = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.8 });
const edgeMat    = new THREE.MeshStandardMaterial({ color: 0xeeeeee });

// —Å–æ–∑–¥–∞—ë–º —Å—Ä–∞–∑—É –≤—Å–µ –º–µ—à–∏ –æ–¥–∏–Ω —Ä–∞–∑
for (let i = 0; i < RUNWAY_POOL_SIZE; i++) {
  const strip   = new THREE.Mesh(new THREE.PlaneGeometry(RUNWAY_WIDTH, RUNWAY_LENGTH), runwayMat);
  strip.rotation.x = -Math.PI / 2;

  const leftEdge  = new THREE.Mesh(new THREE.BoxGeometry(0.1, EDGE_HEIGHT, RUNWAY_LENGTH), edgeMat);
  const rightEdge = new THREE.Mesh(new THREE.BoxGeometry(0.1, EDGE_HEIGHT, RUNWAY_LENGTH), edgeMat);

  // —Å–ø—Ä—è—Ç–∞—Ç—å –∑–∞ –∫–∞–¥—Ä–æ–º
  strip.position.set(0, -0.5, 9999);
  leftEdge.position.set(-RUNWAY_WIDTH/2, -0.5 + EDGE_HEIGHT/2, 9999);
  rightEdge.position.set( RUNWAY_WIDTH/2, -0.5 + EDGE_HEIGHT/2, 9999);

  scene.add(strip, leftEdge, rightEdge);

  runwayPool.push({
    strip, leftEdge, rightEdge,
    inUse: false,
    centerZ: 0
  });
}

/* ---------- –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –¥–æ—Ä–æ–∂–∫–∏ –±–µ–∑ new Mesh ---------- */
function updateRunway() {
  // —Å—Ç–∞–≤–∏–º –Ω–æ–≤—ã–µ —Å–µ–≥–º–µ–Ω—Ç—ã –≤–ø–µ—Ä–µ–¥–∏
  const ahead = nailGroup.position.z - 2 * RUNWAY_LENGTH;
  let lastZ = -Infinity;
  runwayPool.filter(r => r.inUse).forEach(r => lastZ = Math.max(lastZ, r.centerZ));

  if (!isFinite(lastZ) || lastZ > ahead) {
    const free = runwayPool.find(r => !r.inUse);
    if (free) {
      const z = isFinite(lastZ) ? lastZ - RUNWAY_LENGTH : 0;
      free.strip.position.z   = z;
      free.leftEdge.position.z = z;
      free.rightEdge.position.z = z;
      free.centerZ = z;
      free.inUse = true;
    }
  }

  // –ø—Ä—è—á–µ–º —Å—Ç–∞—Ä—ã–µ
  runwayPool.forEach(r => {
    if (r.inUse && r.centerZ > nailGroup.position.z + 60) {
      r.inUse = false;
      // –ø—Ä—è—á–µ–º –∑–∞ –∫–∞–¥—Ä–æ–º, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞–ª–∏
      r.strip.position.z = 9999;
      r.leftEdge.position.z = 9999;
      r.rightEdge.position.z = 9999;
    }
  });
}

const enemyGeo = heartGeo;   // shared
const enemyMat = new THREE.MeshStandardMaterial({ color: 0xff0040, roughness: 0.3, metalness: 0.2 });
let enemies = [];
let enemyLabels = []; // { group, mesh, initial }

/* ---------- gates ---------- */
const gateGeo = new THREE.BoxGeometry(2,2,0.2);
const gates = [];

/* ---------- Gate registry (scalable) ---------- */
const gateRegistry = [
  { weight: 1,  factory: () => ({ label: '–£–†–û–í–ï–ù–¨ +1', action: 'level', val: 1 }) },
  { weight: 10, factory: () => ({ label: '–£–†–û–í–ï–ù–¨ -1', action: 'level', val: -1 }) },
  { weight: 15, factory: () => ({ label: '–ì–í–û–ó–î–ò +1', action: 'count', val: 1 }) },
  { weight: 1,  factory: () => ({ label: '–ì–í–û–ó–î–ò +2', action: 'count', val: 2 }) },
  { weight: 15, factory: () => ({ label: '–ì–í–û–ó–î–ò -1', action: 'count', val: -1 }) },

  { weight: 15, factory: () => {
      const base = 0.25 * (1 + Math.floor(Math.random() * 4)); // 0.25‚Ä¶1
      const mult = [0.5, 0.75, 1, 1.5, 2][Math.floor(Math.random() * 5)];
      const total = +(base * mult).toFixed(2);
      return { label: `–°–¢–†–ï–õ–¨–ë–ê ${total >= 0 ? '+' : ''}${total}`, action: 'rate', val: total };
    }
  },
  { weight: 10, factory: () => ({ label: '–°–¢–†–ï–õ–¨–ë–ê -0.5', action: 'rate', val: -0.5 }) },

  { weight: 15, factory: () => {
      const val = 1 + Math.floor(Math.random() * 3); // 1‚Ä¶3
      return { label: `–î–ê–õ–¨–ù–û–°–¢–¨ +${val}`, action: 'range', val };
    }
  },
  { weight: 10, factory: () => ({ label: '–î–ê–õ–¨–ù–û–°–¢–¨ -2', action: 'range', val: -2 }) },
  { weight: 5,  factory: () => ({ label: '–î–ê–õ–¨–ù–û–°–¢–¨ /2', action: 'range', mode: 'mul', val: 0.5 }) },
  { weight: 5,  factory: () => ({ label: '–î–ê–õ–¨–ù–û–°–¢–¨ √ó1.2', action: 'range', mode: 'mul', val: 1.2 }) },
];

/* ---------- build cumulative distribution once ---------- */
let totalWeight = 0;
const cdf = [];
gateRegistry.forEach(({ weight, factory }) => {
  totalWeight += weight;
  cdf.push({ limit: totalWeight, factory });
});

/* ---------- universal picker ---------- */
function pickGate() {
  const roll = Math.random() * totalWeight;
  for (const { limit, factory } of cdf) {
    if (roll < limit) return factory();
  }
  return cdf[cdf.length - 1].factory(); // should never happen
}

/* ---------- dynamic spawning ---------- */
let lastSpawnZ = 0;
let lastObjectZ = 0;          // –ø–æ—Å–ª–µ–¥–Ω—è—è –∑–∞–Ω—è—Ç–∞—è Z-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç–∞ –æ–±—ä–µ–∫—Ç–æ–≤
const MIN_GAP = 3;            // –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–µ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É –æ–±—ä–µ–∫—Ç–∞–º–∏

const SONG_LENGTH_SEC = 215;
const FPS = 60;
const levelLength = SONG_LENGTH_SEC * FPS;

function spawnGate(side, z, data){
  const gateGroup = new THREE.Group();
  gateGroup.userData = data;

  const isPositive =
  (data.mode === 'mul')
    ? data.val > 1
    : data.val > 0;

    /* –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –ø–∞–Ω–µ–ª—å –Ω–æ–≤–æ–π —à–∏—Ä–∏–Ω—ã */
    const panelMat = new THREE.MeshStandardMaterial({
      color      : isPositive ? 0x00ff00 : 0xff0000,
      transparent: true,
      opacity    : 0.3
    });
    const panel = new THREE.Mesh(new THREE.PlaneGeometry(gateWidth, 2), panelMat);
    panel.position.z = 0.01;
    gateGroup.add(panel);

    /* –±–µ–ª–∞—è —Ä–∞–º–∫–∞ */
    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.PlaneGeometry(gateWidth, 2)),
      new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    edges.position.z = 0.02;
    gateGroup.add(edges);

  /* ---------- —Ç–µ–∫—Å—Ç-Canvas ---------- */
    const canvas = document.createElement('canvas');
    canvas.width  = 384;
    canvas.height = 256;
    const ctx = canvas.getContext('2d');

    const [topText, bottomText] = data.label.includes(' ')
  ? data.label.split(' ')
  : ['–ì–ï–ô–¢', data.label];

    ctx.fillStyle = '#000a';
    ctx.fillRect(0, 0, 384, 256);
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';

    ctx.font = 'bold 42px sans-serif';
    ctx.textBaseline = 'top';
    ctx.fillText(topText, 192, 25);

    ctx.font = 'bold 72px sans-serif';
    ctx.textBaseline = 'middle';
    ctx.fillText(bottomText, 192, 140);


    const tex = new THREE.CanvasTexture(canvas);
    const textPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(gateWidth, 2),  // —Ç–∞ –∂–µ 3√ó2
      new THREE.MeshBasicMaterial({ map: tex, transparent: true })
    );
    textPlane.position.z = 0.03;
    gateGroup.add(textPlane);

    /* —Å–≤–µ—á–µ–Ω–∏–µ */

    const color = isPositive ? 0x00ff00 : 0xff0000;
    const light = new THREE.PointLight(color, 1.2, 6);
    light.position.set(0, 0.5, 0);
    gateGroup.add(light);

    const glowMat = new THREE.MeshBasicMaterial({
      color, transparent: true, opacity: 0.25, side: THREE.DoubleSide
    });
    const glowPlane = new THREE.Mesh(new THREE.PlaneGeometry(gateWidth + 0.2, 2.2), glowMat);
    glowPlane.position.z = -0.05;
    gateGroup.add(glowPlane);

    /* –ø–æ–∑–∏—Ü–∏—è: —Ä–æ–≤–Ω–æ –ø–æ –∫—Ä–∞—é –ø–æ–ª–æ—Å—ã */
    gateGroup.position.set(side * (RUNWAY_WIDTH / 4), 0, z);
    scene.add(gateGroup);
    gates.push(gateGroup);
  };

  function spawnNarrowGate(posX, posZ, data){
    const gateGroup = new THREE.Group();
    gateGroup.userData = data;

    /* –ø–æ–ª—É–ø—Ä–æ–∑—Ä–∞—á–Ω–∞—è –ø–∞–Ω–µ–ª—å ‚Äì —É–∑–∫–∞—è */
    const panelMat = new THREE.MeshStandardMaterial({
      color: 0x00ff00,
      transparent: true,
      opacity: 0.3
    });
    const panel = new THREE.Mesh(
      new THREE.PlaneGeometry(narrowGateWidth, 2),
      panelMat
    );
    panel.position.z = 0.01;
    gateGroup.add(panel);

    /* –±–µ–ª–∞—è —Ä–∞–º–∫–∞ */
    const edges = new THREE.LineSegments(
      new THREE.EdgesGeometry(new THREE.PlaneGeometry(narrowGateWidth, 2)),
      new THREE.LineBasicMaterial({ color: 0xffffff })
    );
    edges.position.z = 0.02;
    gateGroup.add(edges);

    /* —Ç–µ–∫—Å—Ç –±–µ–∑ —Ä–∞—Å—Ç—è–∂–µ–Ω–∏—è */
    const canvasW = 320;   // 400 * 0.8
    const canvasH = 320;
    const canvas = document.createElement('canvas');
    canvas.width  = canvasW;
    canvas.height = canvasH;
    const ctx = canvas.getContext('2d');

    ctx.fillStyle = '#000a';
    ctx.fillRect(0, 0, canvasW, canvasH);
    ctx.fillStyle = '#fff';
    ctx.textAlign = 'center';

    const parts = data.label.includes(' ') ? data.label.split(' ') : ['–ì–ï–ô–¢', data.label];

    ctx.font = 'bold 56px sans-serif';   // 70 * 0.8
    ctx.textBaseline = 'top';
    ctx.fillText(parts[0], canvasW / 2, 48);   // 60 * 0.8

    ctx.font = 'bold 88px sans-serif';   // 110 * 0.8
    ctx.textBaseline = 'middle';
    ctx.fillText(parts[1] || '', canvasW / 2, canvasH / 2 + 32);   // 40 * 0.8

    const tex = new THREE.CanvasTexture(canvas);
    const textPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(narrowGateWidth, 2),   // –≥–µ–æ–º–µ—Ç—Ä–∏—è —Ç–∞ –∂–µ
      new THREE.MeshBasicMaterial({ map: tex, transparent: true })
    );
    textPlane.position.z = 0.03;
    gateGroup.add(textPlane);

    /* —Å–≤–µ—á–µ–Ω–∏–µ –∏ –ø–æ–∑–∏—Ü–∏—è */
    const light = new THREE.PointLight(0x00ff00, 1.2, 6);
    light.position.set(0, 0.5, 0);
    gateGroup.add(light);

    const glowMat = new THREE.MeshBasicMaterial({
      color: 0x00ff00, transparent: true, opacity: 0.25, side: THREE.DoubleSide
    });
    const glowPlane = new THREE.Mesh(
      new THREE.PlaneGeometry(narrowGateWidth + 0.2, 2.2),
      glowMat
    );
    glowPlane.position.z = -0.05;
    gateGroup.add(glowPlane);

    gateGroup.position.set(posX, 0, posZ);
    scene.add(gateGroup);
    gates.push(gateGroup);
  }

  function applyGate(data) {
    if (data.action === 'rate') {
      fireRate = Math.max(0.2, fireRate + data.val);
    }
    if (data.action === 'range') {
      if (data.mode === 'mul') {
        fireRange = Math.max(1, fireRange * data.val);
      } else {
        fireRange = Math.max(1, fireRange + data.val);
      }
      rebuildNailFormation();
    }
    if (data.action === 'count') {
      if (data.val === -1 && nailCount === 1) {
        gameOver = true;
        showMsg('Game Over!');
        return true; // —Å–∏–≥–Ω–∞–ª "–∫–æ–Ω–µ—Ü"
      }
      if (data.val > 0) {
        if (data.val === 2 && nailCount === 4) {
          nailCount = 5;
          nailLevels.push(1);
          nailLevels.forEach((_, i) => nailLevels[i]++);
        } else if (nailCount === MAX_NAILS) {
          nailLevels.forEach((_, i) => nailLevels[i]++);
        } else {
          const maxLevel = Math.max(...nailLevels, 1);
          for (let i = 0; i < data.val; i++) nailLevels.push(maxLevel);
          nailCount += data.val;
        }
        redistributeLevels();
      } else {
        nailCount = Math.max(1, nailCount + data.val);
        for (let i = 0; i < -data.val; i++) nailLevels.pop();
        redistributeLevels();
      }
      rebuildNailFormation();
    }
    if (data.action === 'level') {
      for (let i = 0; i < nailCount; i++) {
        nailLevels[i] = Math.max(1, nailLevels[i] + data.val);
      }
      rebuildNailFormation();
    }

    // –æ–±–Ω–æ–≤–ª—è–µ–º UI
    document.getElementById('count').textContent  = nailCount;
    document.getElementById('levels').textContent = nailLevels.reduce((a,b)=>a+b,0);
    document.getElementById('rate').textContent   = fireRate.toFixed(1);
    document.getElementById('range').textContent = fireRange.toFixed(1);
    return false;
  }

  function createWall(pos, z, delta) {
    const wall = new THREE.Mesh(wallGeo, wallMat.clone());
    wall.position.set(pos, 0, z);

    // HP
    const wallData = calcWallHP(delta);
    wall.userData.hp = wallData.hp;
    wall.userData.rand2 = wallData.rand2;

    // --- –≤—Ä–µ–º–µ–Ω–Ω–∞—è –æ–∫—Ä–∞—Å–∫–∞ –Ω–µ–ø—Ä–æ–±–∏–≤–∞–µ–º—ã—Ö ---
    if (wallData.rand2 > 1) {
      wall.material.color.set(0xff0000);
      wall.material.emissive.set(0x770000);
    }

    const hp = wall.userData.hp;
    wall.material.map = getHPTexture(hp);
    wall.material.needsUpdate = true;

    scene.add(wall);
    walls.push(wall);
    return wall;
}

function applyToBest(gate) {
  const v = Math.abs(gate.val);      // –±–µ—Ä—ë–º –º–æ–¥—É–ª—å
  switch (gate.action) {
    case 'rate':
      bestFireRate = (gate.mode === 'mul')
        ? Math.max(0.2, bestFireRate * v)
        : Math.max(0.2, bestFireRate + (gate.val > 0 ? v : -v));
      break;

    case 'range':
      bestFireRange = (gate.mode === 'mul')
        ? Math.max(1, bestFireRange * v)
        : Math.max(1, bestFireRange + (gate.val > 0 ? v : -v));
      break;

    case 'count':
      bestNailCount = Math.max(1, Math.min(MAX_NAILS, bestNailCount + (gate.val > 0 ? v : -v)));
      bestNailLevelSum += (gate.val > 0 ? v : -v) * (v === 2 ? 2 : 1);
      break;

    case 'level':
      bestNailLevelSum += (gate.val > 0 ? v : -v) * bestNailCount;
      break;
  }

  /* UI-–æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ */
  // document.getElementById('best-count').textContent  = bestNailCount;
  // document.getElementById('best-levels').textContent = bestNailLevelSum;
  // document.getElementById('best-rate').textContent   = bestFireRate.toFixed(1);
  // document.getElementById('best-range').textContent  = bestFireRange;
}

  function canPlaceAt(z) {
    return z < lastObjectZ - MIN_GAP;
  }


function spawnWave(delta){
  /* 1. –º–æ—â–Ω–æ—Å—Ç—å –∏ –∫–æ–ª-–≤–æ */
  // –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ "–ø—É–ª—å –∑–∞ –≤—ã—Å—Ç—Ä–µ–ª" = —Å—É–º–º–∞ —É—Ä–æ–≤–Ω–µ–π –≤—Å–µ—Ö –≥–≤–æ–∑–¥–µ–π
  const bulletCount = nailLevels.reduce((a, b) => a + b, 0);

  const power = Math.min(1, (fireRate - 0.5)/4 + (bulletCount - 1)/10);
  const crowdSize = 3 + Math.floor(power * power * 100 * difficultyFactor);

  /* 2. –≤—ã–±–∏—Ä–∞–µ–º —Å—Ç–æ—Ä–æ–Ω—É –∫–ª–∞—Å—Ç–µ—Ä–∞ */
  const side     = Math.random() < 0.5 ? -1 : 1; // -1 = –ª–µ–≤–æ, +1 = –ø—Ä–∞–≤–æ
  const clusterX = side * (1 + Math.random() * 2);
  const clampedClusterX = THREE.MathUtils.clamp(clusterX, -2.5, 2.5); // –Ω–µ –≤—ã—Ö–æ–¥–∏—Ç –∑–∞ –±–æ—Ä—Ç–∏–∫–∏
  const spawnZ   = lastSpawnZ - 20;
  /* ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî  –û–î–ù–ê –°–¢–†–û–ö–ê  ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî */
  if (spawnZ > nailGroup.position.z + 20) return; // –Ω–µ —Å–æ–∑–¥–∞—ë–º, –µ—Å–ª–∏ –∑–∞ —Å–ø–∏–Ω–æ–π
  

  lastSpawnZ = spawnZ;

// label ‚Äì collect UUIDs while spawning this concrete batch
    let freshIds = [];
    if (crowdSize > 5) {
      const canvas = document.createElement('canvas');
    canvas.width = 128; canvas.height = 64;
    const ctx = canvas.getContext('2d');
    ctx.fillStyle = '#000a';
    ctx.fillRect(0, 0, 128, 64);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(crowdSize.toString(), 64, 32);

    const tex = new THREE.CanvasTexture(canvas);
    const labelMat = new THREE.MeshBasicMaterial({ map: tex, transparent: true });
    const labelGeo = new THREE.PlaneGeometry(1, 0.5);
    const labelMesh = new THREE.Mesh(labelGeo, labelMat); // Properly define mesh
    labelMesh.position.set(0, 1.2, spawnZ); // Set Z position relative to spawnZ

    scene.add(labelMesh);

    // —Å–æ—Ö—Ä–∞–Ω—è–µ–º UUID-—Å–ø–∏—Å–æ–∫
    enemyLabels.push({ ids: freshIds, mesh: labelMesh, initial: crowdSize });
  }

  /* ---------- —Å–ø–∞–≤–Ω —Å—Ç–µ–Ω–æ–∫ ---------- */
  if (Math.random() < 0.4 && canPlaceAt(spawnZ)) {
    const wallPositions = [-RUNWAY_WIDTH / 3, 0, RUNWAY_WIDTH / 3];
    const count = Math.random() < 0.6 ? 1 : 2;
    const taken = new Set();
    for (let i = 0; i < count; i++) {
      let pos;
      do { pos = wallPositions[Math.floor(Math.random() * 3)]; }
      while (taken.has(pos));
      taken.add(pos);
      createWall(pos, spawnZ, delta);
    }
    lastObjectZ = spawnZ;
  }

  /* --- –∏—Å–∫–ª—é—á–∞–µ–º —Å–ø–∞–≤–Ω –≤–Ω—É—Ç—Ä–∏ —Å—Ç–µ–Ω–æ–∫ --- */
  const wallBoxes = walls.map(w => ({
    x: w.position.x,
    z: w.position.z,
    halfW: RUNWAY_WIDTH / 6 + 0.5,
    halfH: 1.2
  }));

  /* 3. —Å–ø–∞–≤–Ω–∏–º –∫—É—á–Ω–æ */
  for (let i = 0; i < crowdSize; i++){
    let eX, eZ;
    let tooClose;
    do {
      eX = clampedClusterX + (Math.random() - 0.5) * 1.5;
      eZ = spawnZ + (Math.random() - 0.5) * 8;
      tooClose = wallBoxes.some(w =>
        Math.abs(eX - w.x) < w.halfW * 3 && Math.abs(eZ - w.z) < w.halfH * 3
      );
    } while (tooClose);
    const e = new THREE.Mesh(enemyGeo, enemyMat);
    e.position.set(
      clampedClusterX + (Math.random()-0.5)*1.5,
      0,
      spawnZ + (Math.random()-0.5)*8
    );
    e.uuid = THREE.MathUtils.generateUUID(); // –ì–ï–ù–ï–†–ò–ú –î–û
    scene.add(e);
    enemies.push(e);
    if (crowdSize > 5) freshIds.push(e.uuid);   // ‚Üê —Å–æ–±–∏—Ä–∞–µ–º ID —Ç–æ–ª—å–∫–æ —ç—Ç–æ–π –≤–æ–ª–Ω—ã
    e.position.y = 0.3;
    e.lookAt(nailGroup.position.x, 0.3, nailGroup.position.z);
  }

  /* ---------- gates (strict lane, same Z) ---------- */
  const spawnZGate = spawnZ + Math.random() * 10;
  if (Math.random() < 0.7 && canPlaceAt(spawnZGate)) {

    // const gateWidth = RUNWAY_WIDTH / 2;
    const sides = Math.random() < 0.6
      ? [Math.random() < 0.5 ? -1 : 1]   // –æ–¥–∏–Ω –≥–µ–π—Ç: –ª–µ–≤–æ –∏–ª–∏ –ø—Ä–∞–≤–æ
      : [-1, 1];                         // –¥–≤–∞ –≥–µ–π—Ç–∞: –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ

    if (sides.length === 1) {
      const g = pickGate();
      spawnGate(sides[0], spawnZGate, pickGate());
      // --- –ø—Ä–∏ —Å–ø–∞–≤–Ω–µ –æ–¥–∏–Ω–æ—á–Ω–æ–≥–æ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–≥–æ –≥–µ–π—Ç–∞ —Ç–æ–∂–µ –ø—Ä–æ–∫–∞—á–∏–≤–∞–µ–º best ---
      if (g.val > 0) {
        applyToBest(g);
      }
    } else {
      // –¥–≤–∞ —Ä–∞–∑–Ω—ã—Ö –≥–µ–π—Ç–∞
      let g1 = pickGate();
      let g2;
      do { g2 = pickGate(); } while (g2.label === g1.label);

      let pairTaken = false;   // <-- –æ–¥–∏–Ω —Ä–∞–∑ –Ω–∞ –≤–æ–ª–Ω—É
      spawnGate(sides[0], spawnZGate, g1);
      spawnGate(sides[1], spawnZGate, g2);

      // —Å–≤—è–∑–∞—Ç—å –ø–∞—Ä—ã
      gates[gates.length-2].userData.twin = gates[gates.length-1];
      gates[gates.length-1].userData.twin = gates[gates.length-2];

      // –Ω–∞–∑–Ω–∞—á–∏–º –æ–±–æ–∏–º –≥–µ–π—Ç–∞–º –æ–¥–Ω—É –∏ —Ç—É –∂–µ —Ñ—É–Ω–∫—Ü–∏—é-–æ–±—Ä–∞–±–æ—Ç—á–∏–∫
      [gates[gates.length-2], gates[gates.length-1]].forEach(g => {
        g.userData.onTake = () => {
          if (pairTaken) return;
          pairTaken = true;

          // –∑–∞–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ —Ç–µ–∫—É—â–∏–π
          applyGate(g.userData); // —Ç–≤–æ—è –ª–æ–≥–∏–∫–∞
          g.userData.used = true;
          gates.splice(gates.indexOf(g), 1);
          scene.remove(g);

          // –≤—Ç–æ—Ä–æ–π –ø—Ä–æ—Å—Ç–æ fade-out
          const other = gates.find(gg => gg !== g && gg.position.z === g.position.z);
          if (other) {
            fadeOutGate(other);
            gates.splice(gates.indexOf(other), 1);
          }
        };
});
      // –≤—ã–±–∏—Ä–∞–µ–º –ª—É—á—à–∏–π –∏–∑ –¥–≤—É—Ö –¥–ª—è best-–ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤
      const candidates = [g1, g2];

      // 1) –æ–¥–∏–Ω –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π, –æ–¥–∏–Ω –æ—Ç—Ä–∏—Ü–∞—Ç–µ–ª—å–Ω—ã–π
      const pos = candidates.filter(c => c.val > 0);
      const neg = candidates.filter(c => c.val < 0);
      let bestForBest;

      if (pos.length === 1 && neg.length === 1) {
          bestForBest = pos[0];            // –≤—Å–µ–≥–¥–∞ –±–µ—Ä—ë–º –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π
      } else {
          // 2) –æ–¥–∏–Ω–∞–∫–æ–≤—ã–µ –∑–Ω–∞–∫–∏
          const sameSign = g1.val > 0 ? 1 : -1;

          if (g1.action === g2.action) {
              // –æ–¥–∏–Ω–∞–∫–æ–≤—ã–π action ‚Üí —Å—Ä–∞–≤–Ω–∏–≤–∞–µ–º –º–æ–¥–∏—Ñ–∏–∫–∞—Ü–∏—é –ø–∞—Ä–∞–º–µ—Ç—Ä–∞
              let v1, v2;
              switch (g1.action) {
                  case 'rate':
                      v1 = bestFireRate + g1.val;
                      v2 = bestFireRate + g2.val;
                      break;
                  case 'range':
                      v1 = (g1.mode === 'mul') ? bestFireRange * g1.val : bestFireRange + g1.val;
                      v2 = (g2.mode === 'mul') ? bestFireRange * g2.val : bestFireRange + g2.val;
                      break;
                  case 'count':
                      v1 = bestNailCount + g1.val;
                      v2 = bestNailCount + g2.val;
                      break;
                  case 'level':
                      v1 = bestNailLevelSum + g1.val * bestNailCount;
                      v2 = bestNailLevelSum + g2.val * bestNailCount;
                      break;
              }
              bestForBest = (sameSign > 0) ? (v1 >= v2 ? g1 : g2) : (v1 <= v2 ? g1 : g2);
          } else {
              // 3) —Ä–∞–∑–Ω—ã–µ action ‚Üí utility
              const u1 = utility(g1, { rate: bestFireRate, range: bestFireRange, count: bestNailCount }, g2);
              const u2 = utility(g2, { rate: bestFireRate, range: bestFireRange, count: bestNailCount }, g1);
              bestForBest = (sameSign > 0) ? (u1 >= u2 ? g1 : g2) : (u1 <= u2 ? g1 : g2);
          }
      }
      applyToBest(bestForBest);
    }
  }
  lastObjectZ = spawnZGate;
}

/* ---------- controls ---------- */
let mouseX = 0;
window.addEventListener('mousemove', e => mouseX = (e.clientX/innerWidth - 0.5) * 6);

window.addEventListener('touchmove', e => {
  const touch = e.touches[0];
  mouseX = (touch.clientX / innerWidth - 0.5) * 6;
}, { passive: true });

/* ---------- camera ---------- */
camera.position.set(0,5,4);                       // <-- –±–ª–∏–∂–µ
camera.lookAt(0,-1,nailGroup.position.z - 3);        // <-- –Ω–∏–∂–µ –∏ —Ç–æ—á–Ω–µ–µ

let speed = 0.1;
// document.addEventListener('click', () => {
//   if (!started){ document.getElementById('bgm').play(); started = true; }
// });

/* ---------- shooting ---------- */
function shoot(time){
  if (!started || gameOver) return;
  if (time - lastShot < 1000 / fireRate) return;
  lastShot = time;

  nailGroup.children.forEach((nail, i) => {
    const level = nailLevels[i];
    const geo = level >= 3 ? bigBulletGeo : bulletGeo;
    const mat = level >= 3 ? bigBulletMat : bulletMat;

    const b = new THREE.Mesh(geo, mat);
    const nailPos = nail.position;
    b.position.set(
      nailGroup.position.x + nailPos.x,
      0,
      nailGroup.position.z - 0.5
    );
    scene.add(b);

    // –ø—É–ª—è –∑–Ω–∞–µ—Ç —Å–≤–æ–π —É—Ä–æ–≤–µ–Ω—å-–ø—Ä–æ–±–æ–π
    bullets.push({mesh:b, vx:0, vz:-0.4, pierce:level});
  });
}


/* ---------- game-over screen ---------- */
function showMsg(text){
  document.getElementById('msgText').innerText = text;
  document.getElementById('msg').style.display = 'block';
}

/* ---------- enemy AI ---------- */
const DETECT_DISTANCE = 20;   // –Ω–∞ –∫–∞–∫–æ–º —Ä–∞—Å—Å—Ç–æ—è–Ω–∏–∏ –≤—Ä–∞–≥ –∑–∞–º–µ—á–∞–µ—Ç –∏–≥—Ä–æ–∫–∞
const ENEMY_SPEED     = 0.1; // –±–∞–∑–æ–≤–∞—è —Å–∫–æ—Ä–æ—Å—Ç—å –≤—Ä–∞–≥–∞
const difficultyFactor = 0.5;   // <-- –∫—Ä—É—Ç–∏—Ç–µ —ç—Ç–∏–º –¥–ª—è —Å–ª–æ–∂–Ω–æ—Å—Ç–∏ (0.5‚Äì2.0)

function updateEnemiesAI() {
  const wallBoxes = walls.map(w => ({
    x: w.position.x,
    z: w.position.z,
    halfW: RUNWAY_WIDTH / 6 + 0.2,   // –ø–æ–ª–æ–≤–∏–Ω–∞ —à–∏—Ä–∏–Ω—ã —Å—Ç–µ–Ω–∫–∏ + –∑–∞–ø–∞—Å
    halfH: 1.1                       // –ø–æ–ª–æ–≤–∏–Ω–∞ –≥–ª—É–±–∏–Ω—ã
  }));

  enemies.forEach(e => {
    const dist = e.position.distanceTo(nailGroup.position);
    if (dist < DETECT_DISTANCE) {
      const dir = new THREE.Vector3()
        .subVectors(
          new THREE.Vector3(nailGroup.position.x, 0, nailGroup.position.z),
          e.position
        )
        .normalize();
      dir.y = 0;
      dir.z *= 0.2;

      // –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è —Å–æ —Å—Ç–µ–Ω–∫–∞–º–∏
      let blocked = false;
      for (const box of wallBoxes) {
        const dx = Math.abs(e.position.x - box.x);
        const dz = Math.abs(e.position.z - box.z);
        if (dx < box.halfW && dz < box.halfH) {
          blocked = true;
          break;
        }
      }

      if (!blocked) {
        e.position.addScaledVector(dir, ENEMY_SPEED * difficultyFactor);
      }
    }
  });
}

function fadeOutGate(gate) {
  const fadeMat = gate.children.find(c => c.material.transparent)?.material;
  if (!fadeMat) { scene.remove(gate); return; }  // –Ω–∞ –≤—Å—è–∫–∏–π —Å–ª—É—á–∞–π

  let alpha = 0.4;
  const fadeStep = 0.05;
  const fadeInterval = setInterval(() => {
    alpha -= fadeStep;
    fadeMat.opacity = Math.max(0, alpha);
    if (alpha <= 0) {
      clearInterval(fadeInterval);
      scene.remove(gate);
    }
  }, 16);   // ~60 fps
}

/* ---------- main loop ---------- */
let lastTime = performance.now();
function animate(time){
  requestAnimationFrame(animate);
  if (!started || gameOver) return;
  const delta = (time - lastTime) / 1000;   // —Å–µ–∫—É–Ω–¥—ã
  lastTime = time;
  // –æ—á–∏—Å—Ç–∏—Ç—å —Å—Ç–∞—Ä—ã—Ö –≤—Ä–∞–≥–æ–≤ –±–µ–∑ uuid (–∑–∞—â–∏—Ç–∞ –æ—Ç —Å—Ç–∞—Ä—ã—Ö —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–π/–∫—ç—à–∞)
  enemies = enemies.filter(e => e.uuid);

  /*  ‚úî  –ò–°–ü–†–ê–í–õ–ï–ù–ò–ï 1: –≤—Å–µ–≥–¥–∞ –≤—ã–∑—ã–≤–∞–µ–º shoot  */
  shoot(time);

  /* player movement */
  nailGroup.position.x += (mouseX - nailGroup.position.x) * 0.1;
  nailGroup.position.x = THREE.MathUtils.clamp(nailGroup.position.x, -3, 3);
  nailGroup.position.z -= speed;

  /* —Å–∂–∞—Ç–∏–µ —É –∫—Ä–∞—ë–≤ + –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ */
  const halfRoad   = 3 - 0.15;   // RUNWAY_WIDTH / 2 - 0.15
  const minGap     = 0.15;
  const maxGap     = 0.5;
  const fadeZone   = halfRoad * 0.3;

  const totalLen   = (nailCount - 1) * maxGap;
  let gap          = totalLen > halfRoad * 2
    ? Math.max(minGap, (halfRoad * 2) / Math.max(1, nailCount - 1))
    : Math.max(minGap, maxGap - Math.max(0, 1 - (halfRoad - Math.abs(nailGroup.position.x)) / fadeZone) * (maxGap - minGap));

  // –ø–æ–∑–∏—Ü–∏–∏ –≥–≤–æ–∑–¥–µ–π
  nailGroup.children.forEach((nail, i) => {
    const pos = (i - (nailCount - 1) / 2) * gap;
    nail.position.x = THREE.MathUtils.clamp(pos, -halfRoad, halfRoad);
  });

  /* –∏–Ω–¥–∏–≤–∏–¥—É–∞–ª—å–Ω—ã–π –Ω–∞–∫–ª–æ–Ω */
  const tiltBase = (mouseX - nailGroup.position.x) * 0.15;
  nailGroup.children.forEach(nail => {
    const edgeDist = halfRoad - Math.abs(nail.position.x + nailGroup.position.x);
    const factor   = Math.max(0, Math.min(1, edgeDist / halfRoad));
    nail.rotation.z = THREE.MathUtils.clamp(tiltBase * factor, -0.4, 0.4);
  });

  updateEnemiesAI();
  // ‚ö° 4. Clean stale labels
  // enemyLabels = enemyLabels.filter(l => enemies.some(e => l.ids.includes(e.uuid)));

/* ---------- —Ü–µ–Ω—Ç—Ä–∞–ª—å–Ω—ã–π label –Ω–∞–¥ –≥—Ä—É–ø–ø–æ–π ---------- */
for (let k = enemyLabels.length - 1; k >= 0; k--) {
  const { ids, mesh, initial } = enemyLabels[k];

  // ‚ö° –ø—Ä–æ–≤–µ—Ä—è–µ–º, –µ—Å—Ç—å –ª–∏ —Ö–æ—Ç—å –æ–¥–∏–Ω –∂–∏–≤–æ–π –∏–∑ —ç—Ç–æ–π –≤–æ–ª–Ω—ã
  const alive = enemies.filter(e =>
    ids.includes(e.uuid) && e.position.z < nailGroup.position.z + 10
  );

  if (alive.length === 0) {
    scene.remove(mesh);
    enemyLabels.splice(k, 1);
    continue;
  }

  const center = new THREE.Vector3();
  alive.forEach(e => center.add(e.position));
  center.divideScalar(alive.length);
  center.y += 1.2;
  mesh.position.lerp(center, 0.1);

  // console.log(
  // `label #${k} ids.length=${ids.length} alive=${alive.length}`,
  // alive.map(e => e.uuid.slice(-4))
// );

  if (alive.length !== initial) {
    const canvas = mesh.material.map.image;
    const ctx = canvas.getContext('2d');
    ctx.clearRect(0, 0, 128, 64);
    ctx.fillStyle = '#000a';
    ctx.fillRect(0, 0, 128, 64);
    ctx.fillStyle = '#fff';
    ctx.font = 'bold 48px sans-serif';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText(alive.length.toString(), 64, 32);
    mesh.material.map.needsUpdate = true;
    enemyLabels[k].initial = alive.length;
  }
}

  /* continuous spawning */
  if (nailGroup.position.z - 80 < lastSpawnZ){
    spawnWave(delta);
  }

  /* bullets */
  for (let i = bullets.length - 1; i >= 0; i--){
    const b = bullets[i];
    b.mesh.position.x += b.vx;
    b.mesh.position.z += b.vz;
    if (b.mesh.position.z < nailGroup.position.z - fireRange){
      scene.remove(b.mesh); bullets.splice(i,1);
    }
  }

/* bullet‚Äìenemy collision */
for (let i = bullets.length - 1; i >= 0; i--){
  const b = bullets[i];     // –æ–±—ä–µ–∫—Ç-–∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
  const bMesh = b.mesh;     // —Å–∞–º –º–µ—à

  for (let j = enemies.length - 1; j >= 0; j--){
    const e = enemies[j];
    const hitDist = 0.5;   // –º–æ–∂–Ω–æ –æ—Å—Ç–∞–≤–∏—Ç—å —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã–º

    if (bMesh.position.distanceTo(e.position) < hitDist){
      b.pierce--;

      scene.remove(e);
      enemies.splice(j, 1);

      if (b.pierce <= 0){
        scene.remove(bMesh);
        bullets.splice(i, 1);
        break;              // –ø—É–ª—è —É–Ω–∏—á—Ç–æ–∂–µ–Ω–∞ ‚Äì –≤—ã—Ö–æ–¥–∏–º –∏–∑ —Ü–∏–∫–ª–∞ –ø–æ –≤—Ä–∞–≥–∞–º
      }
    }
  }
}

  /* player‚Äìenemy collision */
  for (let j = enemies.length - 1; j >= 0; j--){
    const e = enemies[j];
    let hit = false;

    for (let i = nailGroup.children.length - 1; i >= 0; i--){
      const nail = nailGroup.children[i];
      const dx = nailGroup.position.x + nail.position.x - e.position.x;
      const dz = nailGroup.position.z                - e.position.z;
      const dist = Math.sqrt(dx*dx + dz*dz);

      if (dist < 0.7){
        hit = true;

        if (nailLevels[i] > 1){
          // —Ç–µ—Ä—è–µ–º —É—Ä–æ–≤–µ–Ω—å
          nailLevels[i]--;
          rebuildNailFormation();
        } else {
          // —É–¥–∞–ª—è–µ–º –≥–≤–æ–∑–¥—å
          nailCount--;
          nailLevels.splice(i,1);
          rebuildNailFormation();
          if (nailCount === 0){
            gameOver = true;
            showMsg('Game Over!');
            return;
          }
        }
        scene.remove(e); enemies.splice(j,1);
        break;   // –æ–¥–Ω–æ —Å–µ—Ä–¥—Ü–µ ‚Äì –æ–¥–∏–Ω –≥–≤–æ–∑–¥—å
      }
    }
  }

  /* ---------- player‚Äìwall collision ---------- */
  for (let i = walls.length - 1; i >= 0; i--) {
    const wall = walls[i];
    let hit = false;

    for (let j = nailGroup.children.length - 1; j >= 0; j--) {
      const nail = nailGroup.children[j];
      const dx = nailGroup.position.x + nail.position.x - wall.position.x;
      const dz = nailGroup.position.z - wall.position.z;
      if (Math.sqrt(dx * dx + dz * dz) < 1.2) {
        hit = true;

        const lostLevels = nailLevels[j];
        wall.userData.hp -= lostLevels + (nailLevels[j] === 1 ? 1 : 0); // +1 –∑–∞ –ø–µ—Ä–≤—ã–π —É—Ä–æ–≤–µ–Ω—å

        const hp = wall.userData.hp;
        wall.material.map = getHPTexture(hp);
        wall.material.needsUpdate = true;

        nailLevels[j] = Math.max(0, nailLevels[j] - lostLevels);
        if (nailLevels[j] === 0) {
          nailCount--;
          nailLevels.splice(j, 1);
          rebuildNailFormation();
          if (nailCount === 0) {
            gameOver = true;
            showMsg('Game Over!');
            return;
          }
        }
        rebuildNailFormation();
        break;
      }
    }

    if (wall.userData.hp <= 0) {
      scene.remove(wall);
      walls.splice(i, 1);
      // –ø—Ä–µ–≤—Ä–∞—â–∞–µ–º –≤ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π gate (–∫–æ–¥ —É–∂–µ –µ—Å—Ç—å)
    }
  }

  /* player‚Äìgate collision */
  for (let i = gates.length - 1; i >= 0; i--) {
    const g = gates[i];
    if (!g.visible || g.userData.used) continue;

    const gateX = g.position.x;
    const gateZ = g.position.z;

    // üí° –æ–ø—Ä–µ–¥–µ–ª–∏–º —à–∏—Ä–∏–Ω—É –≥–µ–π—Ç–∞ –ø–æ –ø–æ–ª–æ–∂–µ–Ω–∏—é
    const gateW = (Math.abs(gateX) < 0.1) ? RUNWAY_WIDTH / 3 / 2 : RUNWAY_WIDTH / 2 / 2;
    const gateH = 1.0; // —Ç–æ–ª—â–∏–Ω–∞ –≥–µ–π—Ç–∞ –ø–æ Z

    let touched = false;

    for (const nail of nailGroup.children) {
      const nailX = nailGroup.position.x + nail.position.x;
      const nailZ = nailGroup.position.z;

      const dx = Math.abs(nailX - gateX);
      const dz = Math.abs(nailZ - gateZ);

      if (dx <= gateW && dz <= gateH) {
        touched = true;
        break;
      }
    }

    if (!touched) continue;

    if (typeof g.userData.onTake === 'function') {
      g.userData.onTake();
    } else {
      g.userData.used = true;
      const gameOverFlag = applyGate(g.userData);
      if (gameOverFlag) return;

      fadeOutGate(g);
      scene.remove(g);
      gates.splice(i, 1);
    }
  }




  /* ---------- –æ–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–µ–Ω–æ–∫ ---------- */
  for (let i = walls.length - 1; i >= 0; i--) {
    const wall = walls[i];
    for (let j = bullets.length - 1; j >= 0; j--) {
      const b = bullets[j];
      if (b.mesh.position.distanceTo(wall.position) < 1) {
        // –Ω–∞–Ω–æ—Å–∏–º —É—Ä–æ–Ω
        wall.userData.hp -= b.pierce;
        const hp = wall.userData.hp;
        wall.material.map = getHPTexture(hp);
        wall.material.needsUpdate = true;

        scene.remove(b.mesh);
        bullets.splice(j, 1);

        if (wall.userData.hp <= 0) {
          scene.remove(wall);
          walls.splice(i, 1);

          // –ø—Ä–µ–≤—Ä–∞—â–∞–µ–º –≤ –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω—ã–π gate
          const roll = Math.random();
          let gateData;
          if (roll < 0.45) gateData = { label: '–£–†–û–í–ï–ù–¨ +1', action: 'level', val: 1 };
          else if (roll < 0.70) gateData = { label: '–ì–í–û–ó–î–ò +1', action: 'count', val: 1 };
          else if (roll < 0.85) gateData = { label: '–î–ê–õ–¨–ù–û–°–¢–¨ +2', action: 'range', val: 2 };
          else gateData = { label: '–°–¢–†–ï–õ–¨–ë–ê +1', action: 'rate', val: 1 };

          spawnNarrowGate(wall.position.x, wall.position.z, gateData);
          applyToBest(gateData);
        }
        break;
      }
    }
  }

  

  /* win condition –ø–æ —Ä–µ–∞–ª—å–Ω–æ–º—É –≤—Ä–µ–º–µ–Ω–∏ */
  const elapsedSec = (performance.now() - songStartTime) / 1000;
  const progress = Math.min(1, elapsedSec / SONG_DURATION);
  document.getElementById('progressFill').style.width = (progress * 100) + '%';

  if (elapsedSec >= SONG_DURATION){
    gameOver = true;
    showMsg('You Win!');
    return;
  }

  /* camera follow */
  camera.position.x = nailGroup.position.x;
  camera.position.z = nailGroup.position.z + 9;
  camera.lookAt(nailGroup.position.x, 0, nailGroup.position.z - 3);

  /* —É–¥–∞–ª—è–µ–º –≤—Ä–∞–≥–æ–≤ –∏ –≥–µ–π—Ç—ã –∑–∞ —Å–ø–∏–Ω–æ–π */
  const behind = nailGroup.position.z + 15;  // –ø–æ—Ä–æ–≥ —É–¥–∞–ª–µ–Ω–∏—è
  for (let i = enemies.length - 1; i >= 0; i--) {
    if (enemies[i].position.z > behind) {
      scene.remove(enemies[i]);
      enemies.splice(i, 1);
    }
  }
  for (let i = gates.length - 1; i >= 0; i--) {
    if (gates[i].position.z > behind) {
      scene.remove(gates[i]);
      gates.splice(i, 1);
    }
  }
  for (let i = walls.length - 1; i >= 0; i--) {
  if (walls[i].position.z > behind) {
    scene.remove(walls[i]);
    walls.splice(i, 1);
  }
}

  updateRunway();
  
  /* –ø–æ–∑–∏—Ü–∏–æ–Ω–∏—Ä—É–µ–º –±–∞–Ω–Ω–µ—Ä —Å—Ç—Ä–æ–≥–æ –Ω–∞–¥ —Ü–µ–Ω—Ç—Ä–æ–º —Ç–æ–ª–ø—ã –±–µ–∑ –Ω–∞–∫–ª–æ–Ω–∞ */
bannerMesh.position.set(
  nailGroup.position.x,
  nailGroup.position.y + 1.2,
  nailGroup.position.z
);
bannerMesh.rotation.copy(camera.rotation); // –≤—Å–µ–≥–¥–∞ —Å–º–æ—Ç—Ä–∏—Ç –≤ –∫–∞–º–µ—Ä—É (–Ω–µ –Ω–∞–∫–ª–æ–Ω—è–µ—Ç—Å—è)
  renderer.render(scene,camera);
}
animate();
</script>
</body>
</html>